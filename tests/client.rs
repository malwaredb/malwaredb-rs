use malwaredb_client::config::Config;
use malwaredb_server::db::sqlite::Sqlite;
use malwaredb_server::db::DatabaseType;
use malwaredb_server::State;

use std::{env, fs};

use anyhow::Context;
use chrono::Local;
use malwaredb_client::cli;
use uuid::Uuid;

const ADMIN_UNAME: &str = "admin";
const ADMIN_PASSWORD: &str = "password12345";

async fn state() -> (State, u32, String) {
    // Each test needs a separate file, or else they'll clobber each other.
    let mut db_file = env::temp_dir();
    db_file.push(format!("testing_sqlite_{}.db", Uuid::new_v4()));
    if std::path::Path::new(&db_file).exists() {
        fs::remove_file(&db_file)
            .context(format!("failed to delete old SQLite file {db_file:?}"))
            .unwrap();
    }

    let db_type = DatabaseType::SQLite(
        Sqlite::new(db_file.to_str().unwrap())
            .context(format!("failed to create SQLite instance for {db_file:?}"))
            .unwrap(),
    );

    let db_config = db_type.get_config().await.unwrap();

    let mut state = State::default();
    state.port = 8080;
    state.db_config = db_config;
    state.db_type = db_type;

    state
        .db_type
        .set_password(ADMIN_UNAME, ADMIN_PASSWORD)
        .await
        .context("Failed to set admin password")
        .unwrap();

    let source_id = state
        .db_type
        .create_source("temp-source", None, None, Local::now(), true)
        .await
        .unwrap();

    state
        .db_type
        .add_group_to_source(0, source_id)
        .await
        .unwrap();

    let token = state
        .db_type
        .authenticate(ADMIN_UNAME, ADMIN_PASSWORD)
        .await
        .unwrap();

    (state, source_id as u32, token)
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn client_integration() {
    let (state, source_id, token) = state().await;

    let server = tokio::spawn(async move {
        state
            .serve()
            .await
            .expect("MalwareDB failed to .serve() in tokio::spawn()")
    });
    assert!(!server.is_finished());

    // In case start-up time is needed
    tokio::time::sleep(std::time::Duration::new(1, 0)).await;

    let client_config = Config {
        url: "http://127.0.0.1:8080".to_string(),
        api_key: token,
    };

    let client_command = cli::submit::SubmitSamples {
        source_id,
        max_depth: 1,
        password: None,
        debug: 1,
        files: vec!["crates/types/testdata/elf/elf_haiku_x86".into()],
    };
    client_command
        .exec(&client_config)
        .await
        .expect("failed to upload a file");

    server.abort();
}
