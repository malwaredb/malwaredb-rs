use crate::config::Config;
use malwaredb_types::doc::{is_zip_file_doc, PK_HEADER};

use std::io::{Read, Seek, SeekFrom};
use std::path::PathBuf;
use std::process::ExitCode;

use anyhow::{bail, Result};
use base64::engine::general_purpose;
use base64::Engine;
use clap::{Parser, ValueHint};
use flate2::read::GzDecoder;
use reqwest::StatusCode;
use sha2::{Digest, Sha256};
use walkdir::WalkDir;

pub const GZIP_MAGIC: [u8; 2] = [0x1fu8, 0x8bu8];

/// Submit one or more samples to the server by source ID
#[derive(Parser, Clone, Debug, PartialEq)]
pub struct SubmitSamples {
    /// The source which is the origin for this file
    #[arg(short, long)]
    pub source_id: u32,

    /// Max depth, useful if there might be a recursive symlink
    #[arg(short, long, default_value = "100")]
    pub max_depth: usize,

    /// Password(s) needed to open protected Zip files, should any be encountered
    #[arg(short, long)]
    pub password: Option<String>,

    /// Turn debugging information on
    #[arg(short, long, action = clap::ArgAction::Count)]
    pub debug: u8,

    /// The file(s) to send, walking directories and following symlinks
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    pub files: Vec<PathBuf>,
}

impl SubmitSamples {
    pub async fn exec(&self, config: &Config) -> Result<ExitCode> {
        let mut counter = 0u32;
        for path in &self.files {
            if path.is_file() {
                if let Ok(count) = self.submit_file(config, path).await {
                    counter += count;
                }
            } else if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(true)
                    .max_depth(self.max_depth)
                    .into_iter()
                    .flatten()
                {
                    let entry = entry.path().to_path_buf();
                    if entry.is_file() {
                        if let Ok(count) = self.submit_file(config, &entry).await {
                            counter += count;
                        }
                    }
                }
            }
        }

        println!("Submitted {counter} files.");

        Ok(ExitCode::SUCCESS)
    }

    async fn submit_file(&self, config: &Config, path: &PathBuf) -> Result<u32> {
        let mut header = [0u8; 2];
        let mut file = std::fs::File::open(path)?;
        if file.read(&mut header)? != 2 {
            bail!("Failed to read header for {:?}", path);
        }

        if header == PK_HEADER && !is_zip_file_doc(path).unwrap_or(false) {
            if self.debug > 1 {
                println!("Assuming {path:?} is an archive of files to be submitted.");
            }
            let mut counter = 0;
            file.seek(SeekFrom::Start(0))?;
            let mut archive = zip::ZipArchive::new(file)?;
            if self.debug > 1 {
                println!("{path:?} has {} items", archive.len());
            }

            for i in 0..archive.len() {
                let mut file = if let Some(password) = &self.password {
                    match archive
                        .by_index_decrypt(i, password.as_bytes())
                        .expect("unable to get Zip object with password")
                    {
                        Ok(f) => f,
                        Err(_) => {
                            bail!("Invalid password");
                        }
                    }
                } else {
                    match archive.by_index(i) {
                        Ok(f) => f,
                        Err(e) => {
                            bail!("ZipError: {e}");
                        }
                    }
                };

                let mut contents = Vec::new();
                std::io::copy(&mut file, &mut contents).unwrap();
                if self.debug > 2 {
                    println!("{} len: {}", file.name(), contents.len());
                }
                if self.submit_buffer(config, &contents, file.name()).await {
                    if self.debug > 0 {
                        println!("Sent {} successfully", file.name());
                    }
                    counter += 1;
                }
            }

            Ok(counter)
        } else {
            let buffer = if header == GZIP_MAGIC {
                let mut decompressor = GzDecoder::new(std::fs::File::open(path)?);
                let mut decompressed: Vec<u8> = vec![];
                decompressor.read_to_end(&mut decompressed)?;
                decompressed
            } else {
                std::fs::read(path)?
            };

            if self
                .submit_buffer(config, &buffer, path.to_str().unwrap())
                .await
            {
                Ok(1)
            } else {
                Ok(0)
            }
        }
    }

    async fn submit_buffer(&self, config: &Config, contents: &[u8], fname: &str) -> bool {
        let mut hasher = Sha256::new();
        hasher.update(contents);
        let result = hasher.finalize();

        let encoded = general_purpose::STANDARD.encode(contents);

        let payload = malwaredb_api::NewSample {
            file_name: fname.to_string(),
            source_id: self.source_id,
            file_contents_b64: encoded,
            sha256: hex::encode(result),
        };

        let client = reqwest::Client::new();
        match client
            .post(format!("{}{}", config.url, malwaredb_api::UPLOAD_SAMPLE))
            .header(malwaredb_api::MDB_API_HEADER, &config.api_key)
            .json(&payload)
            .send()
            .await
        {
            Ok(res) => {
                if res.status() != StatusCode::OK {
                    eprintln!("Code {} sending {fname}", res.status());
                }
                if self.debug > 3 {
                    println!("Response: {res:?}");
                }
                res.status() == StatusCode::OK
            }
            Err(e) => {
                eprintln!("Error sending sample: {e}");
                false
            }
        }
    }
}
