use crate::config::Config;

use std::path::PathBuf;
use std::process::ExitCode;

use anyhow::Result;
use base64::engine::general_purpose;
use base64::Engine;
use clap::{Parser, ValueHint};
use reqwest::StatusCode;
use sha2::{Digest, Sha256};

/// Submit a sample to the server
#[derive(Parser, Clone, Debug, PartialEq)]
pub struct SubmitSample {
    /// The source which is the origin for this file
    #[arg(short, long)]
    source_id: u32,

    /// The file to send
    #[arg(short, long, value_name = "FILE", value_hint = ValueHint::FilePath)]
    file: PathBuf,
}

impl SubmitSample {
    pub async fn exec(&self, config: &Config) -> Result<ExitCode> {
        let contents = std::fs::read(&self.file)?;

        let mut hasher = Sha256::new();
        hasher.update(&contents);
        let result = hasher.finalize();

        let encoded = general_purpose::STANDARD.encode(&contents);

        let payload = api::NewSample {
            file_name: None,
            key: config.api_key.clone(),
            source_id: self.source_id,
            file_contents_b64: encoded,
            sha256: hex::encode(result),
        };

        let client = reqwest::Client::new();
        let res = client
            .post(format!("{}{}", config.url, api::UPLOAD_SAMPLE))
            .json(&payload)
            .send()
            .await?;

        if res.status() != StatusCode::OK {
            eprintln!("Received code {}", res.status());
            return Ok(ExitCode::FAILURE);
        }

        Ok(ExitCode::SUCCESS)
    }
}
