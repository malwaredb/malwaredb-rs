use crate::MdbClient;
use malwaredb_types::doc::{is_zip_file_doc, PK_HEADER};

use std::io::{Read, Seek, SeekFrom};
use std::path::PathBuf;
use std::process::ExitCode;

use anyhow::{bail, Result};
use clap::{Parser, ValueHint};
use flate2::read::GzDecoder;
use walkdir::WalkDir;

pub const GZIP_MAGIC: [u8; 2] = [0x1fu8, 0x8bu8];

/// Submit one or more samples to the server by source ID
#[derive(Parser, Clone, Debug, PartialEq)]
pub struct SubmitSamples {
    /// The source which is the origin for this file
    #[arg(short, long)]
    pub source_id: u32,

    /// Max depth, useful if there might be a recursive symlink
    #[arg(short, long, default_value = "100")]
    pub max_depth: usize,

    /// Password(s) needed to open protected Zip files, should any be encountered
    #[arg(short, long)]
    pub password: Option<String>,

    /// Turn debugging information on
    #[arg(short, long, action = clap::ArgAction::Count)]
    pub debug: u8,

    /// The file(s) to send, walking directories and following symlinks
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    pub files: Vec<PathBuf>,
}

impl SubmitSamples {
    pub async fn exec(&self, config: &MdbClient) -> Result<ExitCode> {
        let mut counter = 0u32;
        for path in &self.files {
            if path.is_file() {
                if let Ok(count) = self.submit_file(config, path).await {
                    counter += count;
                }
            } else if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(true)
                    .max_depth(self.max_depth)
                    .into_iter()
                    .flatten()
                {
                    let entry = entry.path().to_path_buf();
                    if entry.is_file() {
                        if let Ok(count) = self.submit_file(config, &entry).await {
                            counter += count;
                        }
                    }
                }
            }
        }

        println!("Submitted {counter} files.");

        Ok(ExitCode::SUCCESS)
    }

    async fn submit_file(&self, config: &MdbClient, path: &PathBuf) -> Result<u32> {
        let mut header = [0u8; 2];
        let mut file = std::fs::File::open(path)?;
        if file.read(&mut header)? != 2 {
            bail!("Failed to read header for {:?}", path);
        }

        if header == PK_HEADER && !is_zip_file_doc(path).unwrap_or(false) {
            if self.debug > 1 {
                println!("Assuming {path:?} is an archive of files to be submitted.");
            }
            let mut counter = 0;
            file.seek(SeekFrom::Start(0))?;
            let mut archive = zip::ZipArchive::new(file)?;
            if self.debug > 1 {
                println!("{path:?} has {} items", archive.len());
            }

            for i in 0..archive.len() {
                let mut file = if let Some(password) = &self.password {
                    archive
                        .by_index_decrypt(i, password.as_bytes())
                        .expect("unable to get Zip object with password")
                } else {
                    match archive.by_index(i) {
                        Ok(f) => f,
                        Err(e) => {
                            bail!("ZipError: {e}");
                        }
                    }
                };

                let mut contents = Vec::new();
                std::io::copy(&mut file, &mut contents).unwrap();
                if self.debug > 2 {
                    println!("{} len: {}", file.name(), contents.len());
                }
                if let Ok(success) = config.submit(&contents, file.name(), self.source_id).await {
                    if success {
                        if self.debug > 0 {
                            println!("Sent {} successfully", file.name());
                        }
                        counter += 1;
                    }
                }
            }

            Ok(counter)
        } else {
            let buffer = if header == GZIP_MAGIC {
                let mut decompressor = GzDecoder::new(std::fs::File::open(path)?);
                let mut decompressed: Vec<u8> = vec![];
                decompressor.read_to_end(&mut decompressed)?;
                decompressed
            } else {
                std::fs::read(path)?
            };

            match config
                .submit(&buffer, path.to_str().unwrap(), self.source_id)
                .await
            {
                Ok(_) => Ok(1),
                Err(e) => {
                    eprintln!("Error submitting {path:?}: {e}");
                    Ok(0)
                }
            }
        }
    }
}
