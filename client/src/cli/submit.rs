use crate::config::Config;
use malwaredb_types::doc::{is_zip_file_doc, PK_HEADER};

use std::io::{Read, Seek, SeekFrom};
use std::path::PathBuf;
use std::process::ExitCode;

use anyhow::{bail, Result};
use base64::engine::general_purpose;
use base64::Engine;
use clap::{Parser, ValueHint};
use reqwest::StatusCode;
use sha2::{Digest, Sha256};
use walkdir::WalkDir;

/// Submit one or more samples to the server by source ID
#[derive(Parser, Clone, Debug, PartialEq)]
pub struct SubmitSamples {
    /// The source which is the origin for this file
    #[arg(short, long)]
    source_id: u32,

    /// Max depth, useful if there might be a recursive symlink
    #[arg(short, long, default_value = "100")]
    max_depth: usize,

    /// Password(s) needed to open protected Zip files, should any be encountered
    #[arg(short, long)]
    pub password: Option<String>,

    /// The file(s) to send, walking directories and following symlinks
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    files: Vec<PathBuf>,
}

impl SubmitSamples {
    pub async fn exec(&self, config: &Config) -> Result<ExitCode> {
        let mut counter = 0u32;
        for path in &self.files {
            if path.is_file() {
                if let Ok(count) = self.submit_file(config, path).await {
                    counter += count;
                }
            } else if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(true)
                    .max_depth(self.max_depth)
                    .into_iter()
                    .flatten()
                {
                    let entry = entry.path().to_path_buf();
                    if entry.is_file() {
                        if let Ok(count) = self.submit_file(config, &entry).await {
                            counter += count;
                        }
                    }
                }
            }
        }

        println!("Submitted {counter} files.");

        Ok(ExitCode::SUCCESS)
    }

    async fn submit_file(&self, config: &Config, path: &PathBuf) -> Result<u32> {
        let mut header = [0u8; 2];
        let mut file = std::fs::File::open(path)?;
        if file.read(&mut header)? != 2 {
            bail!("Failed to read header for {:?}", path);
        }

        if header == PK_HEADER && is_zip_file_doc(path).unwrap_or(false) {
            let mut counter = 0;
            file.seek(SeekFrom::Start(0))?;
            let mut archive = zip::ZipArchive::new(file)?;

            for i in 0..archive.len() {
                let mut file = if let Some(password) = &self.password {
                    match archive
                        .by_index_decrypt(i, password.as_bytes())
                        .expect("unable to get Zip object with password")
                    {
                        Ok(f) => f,
                        Err(_) => {
                            bail!("Invalid password");
                        }
                    }
                } else {
                    match archive.by_index(i) {
                        Ok(f) => f,
                        Err(e) => {
                            bail!("ZipError: {e}");
                        }
                    }
                };
                if (*file.name()).ends_with('/') {
                    continue;
                }
                let mut contents = Vec::new();

                std::io::copy(&mut file, &mut contents).unwrap();
                if self.submit_buffer(config, &contents, file.name()).await? {
                    counter += 1;
                }
            }

            Ok(counter)
        } else if self
            .submit_buffer(config, &std::fs::read(path)?, path.to_str().unwrap())
            .await?
        {
            Ok(1)
        } else {
            Ok(0)
        }
    }

    async fn submit_buffer(&self, config: &Config, contents: &[u8], fname: &str) -> Result<bool> {
        let mut hasher = Sha256::new();
        hasher.update(contents);
        let result = hasher.finalize();

        let encoded = general_purpose::STANDARD.encode(contents);

        let payload = malwaredb_api::NewSample {
            file_name: fname.to_string(),
            key: config.api_key.clone(),
            source_id: self.source_id,
            file_contents_b64: encoded,
            sha256: hex::encode(result),
        };

        let client = reqwest::Client::new();
        let res = client
            .post(format!("{}{}", config.url, malwaredb_api::UPLOAD_SAMPLE))
            .json(&payload)
            .send()
            .await?;

        Ok(res.status() != StatusCode::OK)
    }
}
