use crate::MdbClient;
pub mod report;
pub mod retrieval;
pub mod similar;
pub mod submit;

use std::process::ExitCode;

use anyhow::Context;
use clap::{Parser, Subcommand};
use dialoguer::Password;
use home::home_dir;
use malwaredb_api::Labels;

pub const VERSION: &str = concat!(
    "v",
    env!("CARGO_PKG_VERSION"),
    "-",
    env!("VERGEN_GIT_DESCRIBE"),
    " ",
    env!("VERGEN_BUILD_DATE")
);

/// Malware Database Client
///
/// Malware Database maintains the bookkeeping for unknown, malicious, and benign binaries
/// using a database, and optionally storing the files in a given location for later retrieval.
#[derive(Debug, Parser)]
#[command(author, about, version = VERSION)]
pub struct Options {
    #[clap(subcommand)]
    cmd: Subcommands,
}

impl Options {
    pub async fn execute(&self, mdb_client: MdbClient) -> anyhow::Result<ExitCode> {
        match &self.cmd {
            Subcommands::Whoami => {
                let client = reqwest::Client::new();
                let resp = client
                    .get(format!(
                        "{}{}",
                        mdb_client.url,
                        malwaredb_api::USER_INFO_URL
                    ))
                    .header(malwaredb_api::MDB_API_HEADER, &mdb_client.api_key)
                    .send()
                    .await?
                    .json::<malwaredb_api::GetUserInfoResponse>()
                    .await
                    .context("server error, or invalid API key")?;

                println!("UserID: {}", resp.id);
                if resp.groups.is_empty() {
                    println!("You aren't part of any groups.");
                } else {
                    println!("You're part of {} groups:", resp.groups.len());
                    for group in resp.groups {
                        println!("\t{group}");
                    }
                }
                // Access to sources is done by groups, so no groups already means no sources.
                if !resp.sources.is_empty() {
                    println!("You have access to {} sources:", resp.sources.len());
                    for source in resp.sources {
                        println!("\t{source}");
                    }
                }

                if resp.is_admin {
                    println!("You are an administrator of this MalwareDB instance.");
                }

                Ok(ExitCode::SUCCESS)
            }
            Subcommands::Login(cmd) => cmd.execute().await,
            Subcommands::Logout => {
                if let Some(mut home_config) = home_dir() {
                    home_config.push(".mdb_client.toml");
                    if home_config.exists() {
                        std::fs::remove_file(home_config)?;
                    }
                }
                Ok(ExitCode::SUCCESS)
            }
            Subcommands::ResetKey => {
                let client = reqwest::Client::new();
                let resp = client
                    .get(format!(
                        "{}{}",
                        mdb_client.url,
                        malwaredb_api::USER_LOGOUT_URL
                    ))
                    .header(malwaredb_api::MDB_API_HEADER, &mdb_client.api_key)
                    .send()
                    .await
                    .context("server error, or invalid API key")?;

                if resp.status().is_success() {
                    if let Some(mut home_config) = home_dir() {
                        home_config.push(".mdb_client.toml");
                        if home_config.exists() {
                            std::fs::remove_file(home_config)?;
                        }
                    }
                    Ok(ExitCode::SUCCESS)
                } else {
                    Ok(ExitCode::FAILURE)
                }
            }
            Subcommands::ServerInfo => {
                let resp =
                    reqwest::get(format!("{}{}", mdb_client.url, malwaredb_api::SERVER_INFO))
                        .await?
                        .json::<malwaredb_api::ServerInfo>()
                        .await?;
                println!("MalwareDB version {} on {}", resp.mdb_version, resp.os_name);
                println!("Memory Used: {}", resp.memory_used);
                println!("Users: {}", resp.num_users);
                println!("Samples: {}", resp.num_samples);
                println!("Database size: {}", resp.db_size);
                println!("Uptime: {}", resp.uptime);
                Ok(ExitCode::SUCCESS)
            }
            Subcommands::ServerTypes => {
                let resp = reqwest::get(format!(
                    "{}{}",
                    mdb_client.url,
                    malwaredb_api::SUPPORTED_FILE_TYPES
                ))
                .await?
                .json::<malwaredb_api::SupportedFileTypes>()
                .await?;
                for data_type in resp.types {
                    print!("{}", data_type.name);
                    if let Some(desc) = data_type.description {
                        print!(" {desc}");
                    }
                    if data_type.is_executable {
                        print!(" -- is executable");
                    }
                    println!();
                    for magic in data_type.magic {
                        println!("\t{magic}");
                    }
                }
                Ok(ExitCode::SUCCESS)
            }
            Subcommands::ListLabels => {
                let client = reqwest::Client::new();
                let resp = client
                    .get(format!("{}{}", mdb_client.url, malwaredb_api::LIST_LABELS))
                    .header(malwaredb_api::MDB_API_HEADER, &mdb_client.api_key)
                    .send()
                    .await?
                    .json::<Labels>()
                    .await
                    .context("server error, or invalid API key")?;

                println!("{resp}");

                Ok(ExitCode::SUCCESS)
            }
            Subcommands::SubmitSamples(cmd) => cmd.exec(&mdb_client).await,
            Subcommands::SampleReport(cmd) => cmd.exec(&mdb_client).await,
            Subcommands::RetrieveSample(cmd) => cmd.exec(&mdb_client).await,
            Subcommands::FindSimilar(cmd) => cmd.exec(&mdb_client).await,
        }
    }
}

#[derive(Subcommand, Clone, Debug, PartialEq)]
pub enum Subcommands {
    /// Show information about your account, including available groups and data sources
    Whoami,
    /// Login with your username and password to fetch & store your API key
    Login(Login),
    /// Remove your API key from this system
    Logout,
    /// Invalidate your API key, and logout from this system
    ResetKey,
    /// Show information about the server
    ServerInfo,
    /// Show the data types and magic numbers of supported file types
    ServerTypes,
    /// List labels, a hierarchical taxonomy for file samples
    ListLabels,
    /// Submit one or more samples to the server by source ID
    SubmitSamples(submit::SubmitSamples),
    /// Retrieve a sample from the server by hash
    RetrieveSample(retrieval::RetrieveSample),
    /// Retrieve a report for a sample from the server by hash
    SampleReport(report::SampleReport),
    /// Find similar samples
    FindSimilar(similar::Similar),
}

/// Login to a MalwareDB instance, saving your API key in `.mdb_client.toml` in your home directory
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Login {
    /// URL of the server to connect to
    pub url: String,

    /// Username
    pub uname: String,
}

impl Login {
    async fn execute(&self) -> anyhow::Result<ExitCode> {
        let password = Password::new()
            .with_prompt(format!("Password for {}", self.uname))
            .interact()?;
        let api_request = malwaredb_api::GetAPIKeyRequest {
            user: self.uname.clone(),
            password,
        };
        let client = reqwest::Client::new();
        let res = client
            .post(format!("{}{}", self.url, malwaredb_api::USER_LOGIN_URL))
            .json(&api_request)
            .send()
            .await?
            .json::<malwaredb_api::GetAPIKeyResponse>()
            .await?;
        if let Some(key) = res.key {
            MdbClient {
                url: self.url.clone(),
                api_key: key,
            }
            .save()?;
            Ok(ExitCode::SUCCESS)
        } else {
            eprintln!("Failed to get API key.");
            if let Some(msg) = res.message {
                eprintln!("Response: {msg}");
            }
            Ok(ExitCode::FAILURE)
        }
    }
}
