use crate::config::Config;

use std::process::ExitCode;

use clap::{Parser, Subcommand};
use dialoguer::Password;

/// Malware Database Client
///
/// Malware Database maintains the bookkeeping for unknown, malicious, and benign binaries
/// using a database, and optionally storing the files in a given location for later retrieval.
#[derive(Debug, Parser)]
#[command(author, version, about)]
pub struct Options {
    #[clap(subcommand)]
    cmd: Subcommands,
}

impl Options {
    pub async fn execute(&self) -> anyhow::Result<ExitCode> {
        match &self.cmd {
            Subcommands::Whoami => {
                let config = Config::load()?;
                let api_request = api::EmptyAuthenticatingPost {
                    key: config.api_key,
                };
                let client = reqwest::Client::new();
                let resp = client
                    .post(format!("{}{}", config.url, api::USER_INFO_URL))
                    .json(&api_request)
                    .send()
                    .await?
                    .json::<api::GetUserInfoResponse>()
                    .await?;

                println!("UserID: {}", resp.id);
                if resp.groups.is_empty() {
                    println!("You aren't part of any groups.");
                } else {
                    println!("You're part of {} groups:\n", resp.groups.len());
                    for group in resp.groups {
                        println!("\t{group}");
                    }
                }
                // Access to sources is done by groups, so no groups already means no sources.
                if !resp.sources.is_empty() {
                    println!("You have access to {} sources:\n", resp.sources.len());
                    for source in resp.sources {
                        println!("\t{source}");
                    }
                }

                Ok(ExitCode::SUCCESS)
            }
            Subcommands::Login(cmd) => cmd.execute().await,
            Subcommands::Logout => {
                eprintln!("Not implemented");
                Ok(ExitCode::SUCCESS)
            }
            Subcommands::ServerInfo => {
                let config = Config::load()?;
                let resp = reqwest::get(format!("{}{}", config.url, api::SERVER_INFO))
                    .await?
                    .json::<api::ServerInfo>()
                    .await?;
                println!("MalwareDB version {} on {}", resp.mdb_version, resp.os_name);
                println!("Memory Used: {}", resp.memory_used);
                println!("Users: {}", resp.num_users);
                println!("Samples: {}", resp.num_samples);
                println!("Database size: {}", resp.db_size);
                println!("Uptime: {}", resp.uptime);
                Ok(ExitCode::SUCCESS)
            }
        }
    }
}

#[derive(Subcommand, Clone, Debug, PartialEq)]
enum Subcommands {
    /// Show information about your account, including available groups and data sources
    Whoami,
    Login(Login),
    Logout,
    /// Show information about the server
    ServerInfo,
}

/// Login to a MalwareDB instance, saving your API key in `.mdb_client.toml` in your home directory
#[derive(Clone, Debug, Parser, PartialEq)]
struct Login {
    /// URL of the server to connect to
    url: String,

    /// Username
    uname: String,
}

impl Login {
    async fn execute(&self) -> anyhow::Result<ExitCode> {
        let password = Password::new()
            .with_prompt(format!("Password for {}", self.uname))
            .interact()?;
        let api_request = api::GetAPIKeyRequest {
            user: self.uname.clone(),
            password,
        };
        let client = reqwest::Client::new();
        let res = client
            .post(format!("{}{}", self.url, api::USER_LOGIN_URL))
            .json(&api_request)
            .send()
            .await?
            .json::<api::GetAPIKeyResponse>()
            .await?;
        if let Some(key) = res.key {
            Config {
                url: self.url.clone(),
                api_key: key,
            }
            .save()?;
            Ok(ExitCode::SUCCESS)
        } else {
            eprintln!("Failed to get API key.");
            if let Some(msg) = res.message {
                eprintln!("Response: {msg}");
            }
            Ok(ExitCode::FAILURE)
        }
    }
}
