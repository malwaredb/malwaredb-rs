pub(crate) mod cli;
#[cfg(feature = "admin-gui")]
pub(crate) mod gui;

use std::process::ExitCode;

use clap::{CommandFactory, Parser};
#[cfg(feature = "bench")]
use tracing_flame::FlameLayer;
use tracing_subscriber::filter::{filter_fn, FilterExt};
use tracing_subscriber::fmt::format::FmtSpan;
use tracing_subscriber::{prelude::*, EnvFilter};

/// MDB version
pub const MDB_VERSION: &str = env!("CARGO_PKG_VERSION");

#[tokio::main]
async fn main() -> anyhow::Result<ExitCode> {
    let app = cli::Options::parse();

    let env_filter =
        EnvFilter::builder().parse_lossy(app.logger.log_filter.as_ref().unwrap_or(&"".to_owned()));

    let target_filter = filter_fn(|meta| {
        let target = meta.target();
        [
            "malwaredb",
            "malwaredb-server",
            "malwaredb-types",
            "deadpool-postgres",
            "postgres",
            #[cfg(feature = "sqlite")]
            "rusqlite",
        ]
        .into_iter()
        .any(|name| target.eq(name) || target.starts_with(&format!("{name}::")))
    });
    let log_filter = env_filter.and(target_filter);

    let fmt_layer = tracing_subscriber::fmt::layer()
        .with_writer(move || -> Box<dyn std::io::Write> {
            match app.logger.log_target {
                cli::LogTarget::Stdout => Box::new(std::io::stdout()),
                cli::LogTarget::Stderr => Box::new(std::io::stderr()),
            }
        })
        .with_span_events(FmtSpan::NEW | FmtSpan::CLOSE)
        .with_filter(log_filter);

    let registry = tracing_subscriber::registry().with(fmt_layer);

    #[cfg(feature = "bench")]
    let (flame_layer, _guard) = if let Some(profile) = &app.logger.profile {
        use std::fs::File;

        use anyhow::Context;

        let profile = File::create(profile).context("failed to create profile file")?;
        let flame_layer = FlameLayer::new(profile);
        let guard = flame_layer.flush_on_drop();
        (Some(flame_layer), Some(guard))
    } else {
        (None, None)
    };
    #[cfg(feature = "bench")]
    let registry = registry.with(flame_layer);

    registry.init();

    if let Some(generator) = app.generator {
        let mut cmd = cli::Options::command();
        eprintln!("Generating completion file for {generator:?}...");
        cli::print_completions(generator, &mut cmd);
        return Ok(ExitCode::SUCCESS);
    }

    app.execute().await
}
