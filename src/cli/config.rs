#[cfg(any(feature = "admin", feature = "admin-gui", feature = "vt"))]
use malwaredb_server::State;

use std::fmt::{Debug, Formatter};
use std::net::IpAddr;
use std::path::PathBuf;
use std::str::FromStr;

use anyhow::{bail, Context};
use bytesize::ByteSize;
use clap::{Parser, ValueHint};
use home::home_dir;
use serde::{Deserialize, Deserializer};
use zeroize::Zeroizing;

#[cfg(all(not(target_os = "macos"), target_family = "unix"))]
const CONFIG_PATHS: [&str; 2] = [
    "/etc/mdb_server/mdb_config.toml",
    "/usr/local/etc/mdb_server/mdb_config.toml",
];

#[cfg(target_os = "macos")]
const CONFIG_PATHS: [&str; 1] = ["/Library/Preferences/MalwareDB/mdb_config.toml"];

#[cfg(target_family = "windows")]
const CONFIG_PATHS: [&str; 1] = ["C:\\Program Files\\MalwareDB\\mdb_config.toml"];

// Catch-all
#[cfg(all(not(target_family = "windows"), not(target_family = "unix")))]
const CONFIG_PATHS: [&str; 1] = ["mdb_config.toml"];

/// MalwareDB configuration parameters
#[derive(Clone, Parser, PartialEq, Deserialize)]
pub struct Config {
    /// The port which will be used to listen for connections.
    #[arg(short, long, default_value = "8443")]
    pub port: u16,

    /// The directory to store malware samples, if we're keeping them.
    #[arg(long, value_hint = ValueHint::DirPath)]
    pub dir: Option<PathBuf>,

    /// IP address to use for listening for connections
    #[arg(short, long, default_value = "127.0.0.1")]
    pub ip: IpAddr,

    /// Maximum size for a file upload, in bytes
    #[arg(short, long, default_value = "100 MB")]
    pub max_upload_size: ByteSize,

    /// Database connection string
    #[arg(long)]
    #[serde(deserialize_with = "from_db_string")]
    pub db: Zeroizing<String>,

    /// VT API Key, if MalwareDB is to cache VT results
    #[cfg(feature = "vt")]
    #[arg(short, long = "vt_key")]
    #[serde(default, deserialize_with = "option_zeroize_string")]
    pub vt_api_key: Option<Zeroizing<String>>,
}

fn from_db_string<'de, D>(deserializer: D) -> Result<Zeroizing<String>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = Deserialize::deserialize(deserializer)?;

    Ok(Zeroizing::new(s))
}

#[cfg(feature = "vt")]
fn option_zeroize_string<'de, D>(deserializer: D) -> Result<Option<Zeroizing<String>>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = Deserialize::deserialize(deserializer)?;

    Ok(Some(Zeroizing::new(s)))
}

impl Config {
    #[cfg(any(feature = "admin", feature = "admin-gui", feature = "vt"))]
    pub async fn state(&self) -> anyhow::Result<State> {
        State::new(
            self.port,
            self.dir.clone(),
            self.max_upload_size.0 as usize,
            self.ip,
            &self.db,
            #[cfg(feature = "vt")]
            self.vt_api_key.clone(),
        )
        .await
    }

    pub fn from_found_files() -> anyhow::Result<Self> {
        if let Some(mut home_config) = home_dir() {
            home_config.push(".mdb_server");
            home_config.push("mdb_config.toml");
            if home_config.exists() {
                return Self::from_file(&home_config);
            }
        }

        for system_path in CONFIG_PATHS {
            let system_path = PathBuf::from_str(system_path)?;
            if system_path.exists() {
                return Self::from_file(&system_path);
            }
        }

        bail!(
            "could not automatically find a configuration file, checked: ~/.mdb_server/mdb_config.toml, {}",
            CONFIG_PATHS.join(",")
        )
    }

    pub fn from_file(path: &PathBuf) -> anyhow::Result<Self> {
        let config = std::fs::read_to_string(path)
            .context(format!("failed to read config file {}", path.display()))?;
        let cfg: Config = toml::from_str(&config)
            .context(format!("failed to parse config file {}", path.display()))?;
        Ok(cfg)
    }
}

impl Debug for Config {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalwareDB listening on {}:{}", self.ip, self.port)?;
        match &self.dir {
            Some(path) => write!(f, " saving files to {path:?}"),
            None => write!(f, " not saving files"),
        }
    }
}
