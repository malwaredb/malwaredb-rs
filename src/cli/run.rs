use super::config::Config;
use malwaredb_server::State;

use std::process::ExitCode;

use clap::{Parser, Subcommand};

/// Malware Database Server
///
/// `load` will parse a provided config file for the needed parameters
///
/// `config` allows config parameters to be provided on the command line
///
/// Neither, and MalwareDB will attempt to find a config file in `~/.mdb_server/mdb_config.toml`, `/etc/mdb_server/mdb_config.toml`, or `/usr/local/etc/mdb_server/mdb_config.toml`
#[derive(Clone, Parser, Debug, PartialEq)]
pub struct Run {
    /// First run: enable compression of samples
    #[arg(long)]
    pub compress: Option<bool>,

    /// First run: Allow MalwareDB to send samples to VirusTotal if not already there
    #[cfg(feature = "vt")]
    #[arg(long)]
    pub send_files_to_vt: Option<bool>,

    #[cfg(not(feature = "vt"))]
    #[clap(skip)]
    send_files_to_vt: Option<bool>,

    #[clap(subcommand)]
    pub cmd: Option<Subcommands>,
}

impl Run {
    pub async fn state(&self) -> anyhow::Result<State> {
        let cfg = match &self.cmd {
            Some(Subcommands::Load(loader)) => loader.config()?,
            Some(Subcommands::Config(config)) => config.clone(),
            None => Config::from_found_files()?,
        };

        if self.compress.is_some() || self.send_files_to_vt.is_some() {
            let compress = self.compress.unwrap_or(false);
            #[cfg(feature = "vt")]
            let send_to_vt = self.send_files_to_vt.unwrap_or(false);

            State::new_first_run(
                cfg.port,
                cfg.dir.clone(),
                cfg.max_upload_size.0 as usize,
                cfg.ip,
                &cfg.db,
                #[cfg(feature = "vt")]
                cfg.vt_api_key,
                compress,
                #[cfg(feature = "vt")]
                send_to_vt,
            )
            .await
        } else {
            State::new(
                cfg.port,
                cfg.dir.clone(),
                cfg.max_upload_size.0 as usize,
                cfg.ip,
                &cfg.db,
                #[cfg(feature = "vt")]
                cfg.vt_api_key,
            )
            .await
        }
    }

    pub async fn execute(&self) -> anyhow::Result<ExitCode> {
        let state = self.state().await?;
        state.serve().await?;
        Ok(ExitCode::SUCCESS)
    }
}

/// Provide a path to a configuration file
#[derive(Clone, Parser, Debug, PartialEq)]
pub struct Load {
    #[arg(value_name = "FILE", value_hint = clap::ValueHint::FilePath)]
    file: std::path::PathBuf,
}

impl Load {
    pub fn config(&self) -> anyhow::Result<Config> {
        Config::from_file(&self.file)
    }
}

#[derive(Subcommand, Clone, Debug, PartialEq)]
pub enum Subcommands {
    Load(Load),
    Config(Config),
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::IpAddr;
    use std::str::FromStr;

    use anyhow::Context;

    const DB_FILE: &str = "testing_sqlite.db";

    #[tokio::test]
    async fn state_info() {
        let state = State::new(
            8080,
            None,
            10 * 1024,
            IpAddr::from_str("127.0.0.1").unwrap(),
            &format!("file:{DB_FILE}"),
            #[cfg(feature = "vt")]
            None,
        )
        .await
        .unwrap();

        let info = state.get_info().await.unwrap();
        eprintln!("State info(): {info:?}");

        std::fs::remove_file(DB_FILE)
            .context(format!("failed to delete SQLite file {DB_FILE}"))
            .unwrap();
    }
}
