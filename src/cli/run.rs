use super::config::Config;
use server::State;

use std::process::ExitCode;

use clap::{Parser, Subcommand};

/// Malware Database Server
///
/// `load` will parse a provided config file for the needed parameters
///
/// `config` allows config parameters to be provided on the command line
///
/// Neither, and MalwareDB will attempt to find a config file in `~/.mdb_server/mdb_config.toml`, `/etc/mdb_server/mdb_config.toml`, or `/usr/local/etc/mdb_server/mdb_config.toml`
#[derive(Clone, Parser, Debug, PartialEq)]
pub struct Run {
    #[clap(subcommand)]
    pub cmd: Option<Subcommands>,
}

impl Run {
    pub fn state(&self) -> anyhow::Result<State> {
        let cfg = match &self.cmd {
            Some(Subcommands::Load(loader)) => loader.config()?,
            Some(Subcommands::Config(config)) => config.clone(),
            None => Config::from_found_files()?,
        };

        State::new(cfg.port, cfg.dir.clone(), cfg.ip, &cfg.db)
    }

    pub fn execute(&self) -> anyhow::Result<ExitCode> {
        let _state = self.state()?;
        println!("Hello, world!");
        Ok(ExitCode::SUCCESS)
    }
}

/// Provide a path to a configuration file
#[derive(Clone, Parser, Debug, PartialEq)]
pub struct Load {
    #[arg(value_name = "FILE", value_hint = clap::ValueHint::FilePath)]
    file: std::path::PathBuf,
}

impl Load {
    pub fn config(&self) -> anyhow::Result<Config> {
        Config::from_file(&self.file)
    }
}

#[derive(Subcommand, Clone, Debug, PartialEq)]
pub enum Subcommands {
    Load(Load),
    Config(Config),
}
