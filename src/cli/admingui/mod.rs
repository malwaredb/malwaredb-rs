use crate::cli::config::Config;
use malwaredb_server::State;

use anyhow::{anyhow, Result};
use std::process::ExitCode;

use clap::{Args, ValueHint};
use fltk::{
    app, button, enums, frame, group,
    group::{Group, Pack, Tabs},
    input,
    prelude::{GroupExt, InputExt, WidgetBase, WidgetExt, WindowExt},
    window::Window,
};
use fltk_table::{SmartTable, TableOpts};

#[derive(Clone, Debug, Args, PartialEq)]
pub struct AdminGui {
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    config_file: std::path::PathBuf,
}

async fn draw_users_tab(state: &State) -> Result<()> {
    let users = state.db_type.list_users().await?;
    const USERS_COLUMNS: i32 = 3;
    let mut upack = Pack::new(15, 45, 400, 400, "");
    upack.set_spacing(10);
    let mut utable = SmartTable::default()
        .with_size(500, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: users.len() as i32,
            cols: USERS_COLUMNS,
            editable: false,
            ..Default::default()
        });

    utable.set_col_header_value(0, "ID");
    utable.set_col_header_value(1, "User Name");
    utable.set_col_header_value(2, "Email");
    utable.set_col_width(2, 150);

    for (i, user) in users.iter().enumerate() {
        for j in 0..USERS_COLUMNS {
            match j {
                0 => utable.set_cell_value(i as i32, j, &(user.id).to_string()),
                1 => utable.set_cell_value(i as i32, j, &user.uname),
                2 => utable.set_cell_value(i as i32, j, &user.email.replace('@', "@@")),
                _ => {}
            }
        }
    }

    let mut bp = group::Flex::default().column();

    let mut username_row = group::Flex::default().row();
    frame::Frame::default()
        .with_label("Username:")
        .with_align(enums::Align::Inside | enums::Align::Right);
    let mut username_input = input::Input::default();
    username_row.fixed(&username_input, 180);
    username_row.end();

    let mut email_row = group::Flex::default().row();
    frame::Frame::default()
        .with_label("Email:")
        .with_align(enums::Align::Inside | enums::Align::Right);
    let email = input::Input::default();
    email_row.fixed(&email, 180);
    email_row.end();

    let mut button_row = group::Flex::default().row();
    let mut save_button = button::Button::default().with_label("Save");
    save_button.set_color(enums::Color::from_rgb(225, 225, 225));
    button_row.fixed(&save_button, 100);

    bp.fixed(&username_row, 30);
    bp.fixed(&email_row, 30);
    bp.fixed(&button_row, 30);

    bp.end();

    upack.end();

    utable.set_callback(move |table| {
        let mut rid = -1;
        for row_id in 0..table.row_count() {
            if table.row_selected(row_id) {
                rid = row_id;
                break;
            }
        }
        if rid >= 0 {
            let uid = table.cell_value(rid, 0);
            let uname = table.cell_value(rid, 1);
            username_input.set_value(&uname);
            println!("User selected {uid}: {uname}");
        } else {
            username_input.set_value("");
        }
    });

    Ok(())
}

async fn draw_groups_tab(state: &State) -> Result<()> {
    let groups = state.db_type.list_groups(true, true).await?;
    const GROUPS_COLUMNS: i32 = 5;
    let mut gpack = Pack::new(15, 45, 300, 400, "");
    gpack.set_spacing(10);
    let mut gtable = SmartTable::default()
        .with_size(400, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: groups.len() as i32,
            cols: GROUPS_COLUMNS,
            editable: false,
            ..Default::default()
        });
    gpack.end();

    gtable.set_col_header_value(0, "ID");
    gtable.set_col_header_value(1, "Name");
    gtable.set_col_header_value(2, "Desc");
    gtable.set_col_header_value(3, "Members");
    gtable.set_col_header_value(4, "Sources");

    for (i, group) in groups.iter().enumerate() {
        for j in 0..GROUPS_COLUMNS {
            match j {
                0 => gtable.set_cell_value(i as i32, j, &(group.id).to_string()),
                1 => gtable.set_cell_value(i as i32, j, &group.name),
                2 => gtable.set_cell_value(i as i32, j, &group.description),
                3 => gtable.set_cell_value(
                    i as i32,
                    j,
                    &(group.members.as_ref().unwrap().len()).to_string(),
                ),
                4 => gtable.set_cell_value(
                    i as i32,
                    j,
                    &(group.sources.as_ref().unwrap().len()).to_string(),
                ),
                _ => {}
            }
        }
    }
    Ok(())
}

async fn draw_sources_tab(state: &State) -> Result<()> {
    let sources = state.db_type.list_sources().await?;
    const SOURCES_COLUMNS: i32 = 5;
    let mut spack = Pack::new(15, 45, 400, 400, "");
    spack.set_spacing(10);

    let mut stable = SmartTable::default()
        .with_size(450, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: sources.len() as i32,
            cols: SOURCES_COLUMNS,
            editable: false,
            ..Default::default()
        });
    spack.end();

    stable.set_col_header_value(0, "ID");
    stable.set_col_header_value(1, "Name");
    stable.set_col_header_value(2, "Desc");
    stable.set_col_header_value(3, "URL");
    stable.set_col_header_value(4, "Date");

    for (i, source) in sources.iter().enumerate() {
        for j in 0..SOURCES_COLUMNS {
            match j {
                0 => stable.set_cell_value(i as i32, j, &(source.id).to_string()),
                1 => stable.set_cell_value(i as i32, j, &source.name),
                2 => stable.set_cell_value(
                    i as i32,
                    j,
                    source.description.as_ref().unwrap_or(&"".to_string()),
                ),
                3 => stable.set_cell_value(
                    i as i32,
                    j,
                    source.url.as_ref().unwrap_or(&"".to_string()),
                ),
                4 => stable.set_cell_value(i as i32, j, &source.date.to_string()),
                _ => {}
            }
        }
    }
    Ok(())
}

async fn draw_gallery(state: &State) -> Result<()> {
    let tab = Tabs::new(10, 10, 600, 450, "");

    let users_tab = Group::new(10, 35, 500, 450, "Users\t\t");
    draw_users_tab(state).await?;
    users_tab.end();

    let groups_tab = Group::new(10, 35, 500, 450, "Groups\t\t");
    draw_groups_tab(state).await?;
    groups_tab.end();

    let sources_tab = Group::new(10, 35, 500, 450, "Sources\t\t");
    draw_sources_tab(state).await?;
    sources_tab.end();

    tab.end();

    Ok(())
}

impl AdminGui {
    pub async fn execute(&self) -> Result<ExitCode> {
        let state = Config::from_file(&self.config_file)?.state().await?;

        let app = app::App::default().with_scheme(app::Scheme::Gtk);
        app::background(221, 221, 221);

        let mut wind = Window::default()
            .with_size(500, 450)
            .with_label(&format!("MalwareDB {}", crate::MDB_VERSION))
            .center_screen();

        draw_gallery(&state).await?;

        wind.make_resizable(true);
        wind.end();
        wind.show();

        app.run().and(Ok(ExitCode::SUCCESS)).map_err(|e| {
            eprintln!("FltkError: {e}");
            anyhow!(e)
        })
    }
}
