use crate::cli::config::Config;
use server::State;

use anyhow::{anyhow, Result};
use std::process::ExitCode;

use clap::{Args, ValueHint};
use fltk::{
    app,
    group::{Group, Pack, Tabs},
    prelude::{GroupExt, WidgetBase, WidgetExt, WindowExt},
    window::Window,
};
use fltk_table::{SmartTable, TableOpts};

#[derive(Clone, Debug, Args, PartialEq)]
pub struct AdminGui {
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    config_file: std::path::PathBuf,
}

async fn draw_gallery(state: &State) -> Result<()> {
    let tab = Tabs::new(10, 10, 500 - 20, 450 - 20, "");

    let users_tab = Group::new(10, 35, 500 - 20, 450 - 45, "Users\t\t");
    let users = state.db_type.list_users().await?;
    const USERS_COLUMNS: i32 = 3;
    let mut upack = Pack::new(15, 45, 300, 400, "");
    upack.set_spacing(10);
    let mut utable = SmartTable::default()
        .with_size(400, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: users.len() as i32,
            cols: USERS_COLUMNS,
            editable: false,
            ..Default::default()
        });

    utable.set_col_header_value(0, "ID");
    utable.set_col_header_value(1, "User Name");
    utable.set_col_header_value(2, "Email");
    upack.end();

    for (i, user) in users.iter().enumerate() {
        for j in 0..USERS_COLUMNS {
            match j {
                0 => utable.set_cell_value(i as i32, j, &(user.id).to_string()),
                1 => utable.set_cell_value(i as i32, j, &user.uname),
                2 => utable.set_cell_value(i as i32, j, &user.email),
                _ => {}
            }
        }
    }
    eprintln!("{utable:?}");

    users_tab.end();

    let groups_tab = Group::new(10, 35, 500 - 30, 450 - 25, "Groups\t\t");
    let groups = state.db_type.list_groups(true, true).await?;
    const GROUPS_COLUMNS: i32 = 5;
    let mut gpack = Pack::new(15, 45, 300, 400, "");
    gpack.set_spacing(10);
    let mut gtable = SmartTable::default()
        .with_size(400, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: groups.len() as i32,
            cols: GROUPS_COLUMNS,
            editable: false,
            ..Default::default()
        });
    gpack.end();

    gtable.set_col_header_value(0, "ID");
    gtable.set_col_header_value(1, "Name");
    gtable.set_col_header_value(2, "Desc");
    gtable.set_col_header_value(3, "Members");
    gtable.set_col_header_value(4, "Sources");

    for (i, group) in groups.iter().enumerate() {
        for j in 0..GROUPS_COLUMNS {
            match j {
                0 => gtable.set_cell_value(i as i32, j, &(group.id).to_string()),
                1 => gtable.set_cell_value(i as i32, j, &group.name),
                2 => gtable.set_cell_value(i as i32, j, &group.description),
                3 => gtable.set_cell_value(
                    i as i32,
                    j,
                    &(group.members.as_ref().unwrap().len()).to_string(),
                ),
                4 => gtable.set_cell_value(
                    i as i32,
                    j,
                    &(group.sources.as_ref().unwrap().len()).to_string(),
                ),
                _ => {}
            }
        }
    }
    groups_tab.end();

    let sources_tab = Group::new(10, 35, 500 - 30, 450 - 25, "Sources\t\t");
    let sources = state.db_type.list_sources().await?;
    const SOURCES_COLUMNS: i32 = 5;
    let mut spack = Pack::new(15, 45, 400, 400, "");
    spack.set_spacing(10);

    let mut stable = SmartTable::default()
        .with_size(450, 300)
        .center_of_parent()
        .with_opts(TableOpts {
            rows: sources.len() as i32,
            cols: SOURCES_COLUMNS,
            editable: false,
            ..Default::default()
        });
    spack.end();

    stable.set_col_header_value(0, "ID");
    stable.set_col_header_value(1, "Name");
    stable.set_col_header_value(2, "Desc");
    stable.set_col_header_value(3, "URL");
    stable.set_col_header_value(4, "Date");

    for (i, source) in sources.iter().enumerate() {
        for j in 0..SOURCES_COLUMNS {
            match j {
                0 => stable.set_cell_value(i as i32, j, &(source.id).to_string()),
                1 => stable.set_cell_value(i as i32, j, &source.name),
                2 => stable.set_cell_value(
                    i as i32,
                    j,
                    source.description.as_ref().unwrap_or(&"".to_string()),
                ),
                3 => stable.set_cell_value(
                    i as i32,
                    j,
                    source.url.as_ref().unwrap_or(&"".to_string()),
                ),
                4 => stable.set_cell_value(i as i32, j, &source.date.to_string()),
                _ => {}
            }
        }
    }

    sources_tab.end();

    tab.end();

    Ok(())
}

impl AdminGui {
    pub async fn execute(&self) -> Result<ExitCode> {
        let state = Config::from_file(&self.config_file)?.state().await?;

        let app = app::App::default().with_scheme(app::Scheme::Gtk);
        app::background(221, 221, 221);

        let mut wind = Window::default()
            .with_size(500, 450)
            .with_label(&format!("MalwareDB {}", crate::MDB_VERSION))
            .center_screen();

        draw_gallery(&state).await?;

        wind.make_resizable(true);
        wind.end();
        wind.show();

        app.run().and(Ok(ExitCode::SUCCESS)).map_err(|e| {
            eprintln!("FltkError: {e}");
            anyhow!(e)
        })
    }
}
