use crate::cli::config::Config;

use std::process::ExitCode;

use chrono::{Local, NaiveDate, NaiveDateTime, NaiveTime};
use clap::{Parser, ValueHint};

/// Grant a group access to a data source
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct AddGroup {
    /// Group ID
    #[arg(short, long)]
    pub gid: u32,

    /// Source ID
    #[arg(short, long)]
    pub sid: u32,
}

impl AddGroup {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;

        let groups = state.db_type.list_groups().await?;
        if !groups.iter().any(|g| g.id as u32 == self.gid) {
            panic!("Group ID {} is not valid.", self.gid);
        }

        let sources = state.db_type.list_sources().await?;
        if !sources.iter().any(|s| s.id as u32 == self.sid) {
            panic!("Source ID {} is not valid.", self.sid);
        }

        state
            .db_type
            .add_group_to_source(self.gid as i32, self.sid as i32)
            .await?;
        Ok(ExitCode::SUCCESS)
    }
}

/// Create a new source
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Create {
    /// Name
    #[arg(long)]
    pub name: String,

    /// Description
    #[arg(long)]
    pub description: Option<String>,

    /// This source's URL
    #[arg(long, value_hint = ValueHint::Url)]
    pub url: Option<String>,

    /// First acquisition date in 'YYYY-MM-DD' format
    #[arg(long)]
    pub date: NaiveDate,

    /// Whether or not the data in this source can be shared externally
    #[arg(long)]
    pub releasable: bool,

    /// Are the files from this source known to be malware or otherwise malicious?
    #[arg(long)]
    pub malicious: Option<bool>,
}

impl Create {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;

        // The known time
        let time = NaiveTime::default();
        // Naive date time, with no time zone information
        let datetime = NaiveDateTime::new(self.date, time);

        let sid = state
            .db_type
            .create_source(
                &self.name,
                self.description.as_deref(),
                self.url.as_deref(),
                datetime.and_local_timezone(Local).unwrap(),
                self.releasable,
                self.malicious,
            )
            .await?;
        println!("Source {} created with ID {sid}", self.name);

        Ok(ExitCode::SUCCESS)
    }
}

/// List sources
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct List {}

impl List {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        for source in state.db_type.list_sources().await? {
            println!("{source}");
        }
        Ok(ExitCode::SUCCESS)
    }
}
