use crate::cli::config::Config;

use std::process::ExitCode;

use chrono::{Local, NaiveDate, NaiveDateTime, NaiveTime};
use clap::{Parser, ValueHint};

/// Grant a group access to a data source
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct AddGroup {
    /// Group ID
    #[arg(short, long)]
    pub gid: i32,

    /// Source ID
    #[arg(short, long)]
    pub sid: i32,
}

impl AddGroup {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        state
            .db_type
            .add_group_to_source(self.gid, self.sid)
            .await?;
        Ok(ExitCode::SUCCESS)
    }
}

/// Create a new source
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Create {
    /// Name
    #[arg(long)]
    pub name: String,

    /// Description
    #[arg(long)]
    pub description: Option<String>,

    /// This source's URL
    #[arg(long, value_hint = ValueHint::Url)]
    pub url: Option<String>,

    /// First acquisition date in 'YYYY-MM-DD' format
    #[arg(long)]
    pub date: NaiveDate,

    /// Whether or not the data in this source can be shared externally
    #[arg(long)]
    pub releasable: bool,
}

impl Create {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;

        // The known time
        let time = NaiveTime::default();
        // Naive date time, with no time zone information
        let datetime = NaiveDateTime::new(self.date, time);

        let sid = state
            .db_type
            .create_source(
                &self.name,
                self.description.as_deref(),
                self.url.as_deref(),
                datetime.and_local_timezone(Local).unwrap(),
                self.releasable,
            )
            .await?;
        println!("Source {} created with ID {sid}", self.name);

        Ok(ExitCode::SUCCESS)
    }
}

/// List sources
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct List {}

impl List {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        for source in state.db_type.list_sources().await? {
            println!("{source}");
        }
        Ok(ExitCode::SUCCESS)
    }
}
