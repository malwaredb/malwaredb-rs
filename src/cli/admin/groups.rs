use super::super::config::Config;

use std::process::ExitCode;

use clap::{Parser, ValueHint};

/// Add a user to a group
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct AddUser {
    /// User ID
    #[arg(short, long)]
    pub uid: i32,

    /// Group ID
    #[arg(short, long)]
    pub gid: i32,
}

impl AddUser {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        state.db_type.add_user_to_group(self.uid, self.gid).await?;
        Ok(ExitCode::SUCCESS)
    }
}

/// Create a new group
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Create {
    /// Name
    #[arg(short, long, value_hint = ValueHint::Username)]
    pub name: String,

    /// Description
    #[arg(short, long, value_hint = ValueHint::EmailAddress)]
    pub description: String,

    /// Parent group
    #[arg(short, long, value_hint = ValueHint::Unknown)]
    pub parent: Option<i32>,
}

impl Create {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;

        let gid = state
            .db_type
            .create_group(&self.name, &self.description, self.parent)
            .await?;

        println!("Created group {} with ID: {gid}.", self.name);

        Ok(ExitCode::SUCCESS)
    }
}

/// List groups, optionally showing membership
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct List {
    /// Show members of each group
    #[arg(short, long, default_value = "false")]
    pub show_members: bool,
}

impl List {
    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;

        for group in state.db_type.list_groups(self.show_members).await? {
            println!("{group}");
        }
        Ok(ExitCode::SUCCESS)
    }
}
