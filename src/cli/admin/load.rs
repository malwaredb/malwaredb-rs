use crate::cli::config::Config;
use malwaredb_server::db::types::{FileMetadata, FileType};
use malwaredb_server::State;
use malwaredb_types::KnownType;

use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::ExitCode;

use anyhow::{bail, Result};
use clap::Parser;
use malwaredb_types::doc::is_zip_file_doc;
use walkdir::WalkDir;

/// Bulk load files into MalwareDB
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Load {
    /// The id number for the source to be used as the origin of the files added
    #[arg(short, long)]
    pub source_id: u32,

    /// The user id to use as the uploading person for the files added
    #[arg(short, long)]
    pub user_id: u32,

    /// Maximum depth for directory recursion
    #[arg(short, long, default_value = "100")]
    pub max_depth: usize,

    /// Whether or not symbolic links should be followed
    #[arg(short = 'l', long, default_value = "false")]
    pub follow_links: bool,

    /// Password(s) needed to open protected Zip files, should any be encountered
    #[arg(short, long)]
    pub password: Option<String>,

    /// The files and/or directories of files to be added
    pub paths: Vec<PathBuf>,
}

impl Load {
    async fn add_bytes(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        fname: &str,
        contents: &[u8],
    ) -> Result<bool> {
        let db_file_type = {
            let mut id = None;
            for db_file_type in db_file_types {
                for magic in &db_file_type.magic {
                    if contents.starts_with(magic) {
                        id = Some(db_file_type.id);
                    }
                }
            }
            id
        };

        if let Some(type_id) = db_file_type {
            let known_type = KnownType::new(contents)?;
            let meta_data = FileMetadata::new(contents, fname);

            if state
                .db_type
                .add_file(
                    &meta_data,
                    known_type,
                    self.user_id as i32,
                    self.source_id as i32,
                    type_id,
                )
                .await?
            {
                state.store_bytes(contents)?;
                return Ok(true);
            }
        }

        Ok(false)
    }

    async fn load_file_path(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        path: &Path,
    ) -> Result<u32> {
        let contents = std::fs::read(path)?;
        let fname = path.file_name().unwrap().to_str().unwrap().to_string();

        let mut file = std::fs::File::open(path)?;
        let mut header = [0u8; 2];
        if file.read(&mut header)? != 2 {
            bail!("Failed to read header for {:?}", path);
        } else if header == [0x50u8, 0x4bu8] {
            if let Ok(false) = is_zip_file_doc(path) {
                return self.add_from_zip(state, db_file_types, path).await;
            }
        }

        self.add_bytes(state, db_file_types, &fname, &contents)
            .await
            .and(Ok(1))
    }

    pub async fn execute(&self, config: &Config) -> Result<ExitCode> {
        let state = config.state().await?;
        let db_file_types = state.db_type.get_known_data_types().await?;
        let mut counter = 0u32;

        for path in self.paths.iter() {
            if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(self.follow_links)
                    .max_depth(self.max_depth)
                    .into_iter()
                    .flatten()
                {
                    if entry.file_type().is_file() {
                        counter += self
                            .load_file_path(&state, &db_file_types, entry.path())
                            .await?;
                    }
                }
            } else {
                counter += self
                    .load_file_path(&state, &db_file_types, path.as_path())
                    .await?;
            }
        }

        println!("Inserted records for {counter} files.");

        Ok(ExitCode::SUCCESS)
    }

    #[allow(unused)]
    async fn add_from_zip(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        path: &Path,
    ) -> Result<u32> {
        let file = std::fs::File::open(path)?;

        let mut counter = 0;
        let mut archive = zip::ZipArchive::new(file)?;
        for i in 0..archive.len() {
            let mut file = if let Some(password) = &self.password {
                match archive
                    .by_index_decrypt(i, password.as_bytes())
                    .expect("unable to get Zip object with password")
                {
                    Ok(f) => f,
                    Err(_) => {
                        bail!("Invalid password");
                    }
                }
            } else {
                match archive.by_index(i) {
                    Ok(f) => f,
                    Err(e) => {
                        bail!("ZipError: {e}");
                    }
                }
            };
            if (*file.name()).ends_with('/') {
                continue;
            }
            let mut contents = Vec::new();

            std::io::copy(&mut file, &mut contents).unwrap();
            if self
                .add_bytes(state, db_file_types, file.name(), &contents)
                .await?
            {
                counter += 1;
            }
        }

        Ok(counter)
    }
}
