use crate::cli::config::Config;
use server::db::types::{FileMetadata, FileType};
use server::State;
use std::io::Read;
use types::KnownType;

use std::path::{Path, PathBuf};
use std::process::ExitCode;

use clap::Parser;
use walkdir::WalkDir;

/// Bulk load files into MalwareDB
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Load {
    /// The id number for the source to be used as the origin of the files added
    #[arg(short, long)]
    pub source_id: u32,

    /// The user id to use as the uploading person for the files added
    #[arg(short, long)]
    pub user_id: u32,

    /// Maximum depth for directory recursion
    #[arg(short, long, default_value = "100")]
    pub max_depth: usize,

    /// Whether or not symbolic links should be followed
    #[arg(short = 'l', long, default_value = "false")]
    pub follow_links: bool,

    /// Password(s) needed to open protected Zip files, should any be encountered
    #[arg(long, default_values_t = vec!["infected".to_string(), "password".to_string(), "1234".to_string()])]
    pub passwords: Vec<String>,

    /// The files and/or directories of files to be added
    pub paths: Vec<PathBuf>,
}

impl Load {
    async fn add_bytes(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        fname: &str,
        contents: &[u8],
    ) -> anyhow::Result<bool> {
        let db_file_type = {
            let mut id = None;
            for db_file_type in db_file_types {
                for magic in &db_file_type.magic {
                    if contents.starts_with(magic) {
                        id = Some(db_file_type.id);
                    }
                }
            }
            id
        };

        if let Some(type_id) = db_file_type {
            let known_type = KnownType::new(contents)?;
            let meta_data = FileMetadata::new(contents, fname);

            if state
                .db_type
                .add_file(
                    &meta_data,
                    known_type,
                    self.user_id as i32,
                    self.source_id as i32,
                    type_id,
                )
                .await?
            {
                state.store_bytes(contents)?;
                return Ok(true);
            }
        }

        Ok(false)
    }

    async fn load_file_path(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        path: &Path,
    ) -> anyhow::Result<bool> {
        let contents = std::fs::read(path)?;
        let fname = path.file_name().unwrap().to_str().unwrap().to_string();

        self.add_bytes(state, db_file_types, &fname, &contents)
            .await
    }

    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        let db_file_types = state.db_type.get_known_data_types().await?;
        let mut counter = 0u32;

        for path in self.paths.iter() {
            if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(self.follow_links)
                    .max_depth(self.max_depth)
                    .into_iter()
                    .flatten()
                {
                    if entry.file_type().is_file() {
                        let mut file = std::fs::File::open(entry.path())?;
                        let mut header = [0u8; 2];
                        if file.read(&mut header)? != 2 {
                            eprintln!("Failed to read header for {:?}", entry.path());
                        } else if header == [0x50u8, 0x4bu8] {
                            eprintln!("{:?} appears to be a zip file", entry.path());
                        }
                        // Call `self.add_from_zip()` once we have logic to determine between a
                        // Zip-based office document vs. an archive of files to be loaded
                        if self
                            .load_file_path(&state, &db_file_types, entry.path())
                            .await?
                        {
                            counter += 1;
                        }
                    }
                }
            } else if self
                .load_file_path(&state, &db_file_types, path.as_path())
                .await?
            {
                counter += 1;
            }
        }

        println!("Inserted records for {counter} files.");

        Ok(ExitCode::SUCCESS)
    }

    #[allow(unused)]
    async fn add_from_zip(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        path: &Path,
    ) -> anyhow::Result<u32> {
        let file = std::fs::File::open(path)?;

        let mut counter = 0;
        let mut archive = zip::ZipArchive::new(file)?;
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            if (*file.name()).ends_with('/') {
                continue;
            }
            let mut contents = Vec::new();

            std::io::copy(&mut file, &mut contents).unwrap();
            if self
                .add_bytes(state, db_file_types, file.name(), &contents)
                .await?
            {
                counter += 1;
            }
        }

        Ok(counter)
    }
}
