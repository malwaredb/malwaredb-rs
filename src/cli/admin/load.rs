use crate::cli::config::Config;
use server::db::types::{FileMetadata, FileType};
use server::State;
use types::KnownType;

use std::path::{Path, PathBuf};
use std::process::ExitCode;

use clap::Parser;
use walkdir::WalkDir;

/// Bulk load files into MalwareDB
#[derive(Clone, Debug, Parser, PartialEq)]
pub struct Load {
    /// The id number for the source to be used as the origin of the files added
    #[arg(short, long)]
    pub source_id: u32,

    /// The user id to use as the uploading person for the files added
    #[arg(short, long)]
    pub user_id: u32,

    /// Maximum depth for directory recursion
    #[arg(short, long, default_value = "100")]
    pub max_depth: usize,

    /// Whether or not symbolic links should be followed
    #[arg(short = 'l', long, default_value = "false")]
    pub follow_links: bool,

    /// The files and/or directories of files to be added
    pub paths: Vec<PathBuf>,
}

impl Load {
    async fn load_file_path(
        &self,
        state: &State,
        db_file_types: &Vec<FileType>,
        path: &Path,
    ) -> anyhow::Result<bool> {
        let contents = std::fs::read(path)?;

        let db_file_type = {
            let mut id = None;
            for db_file_type in db_file_types {
                for magic in &db_file_type.magic {
                    if contents.starts_with(magic) {
                        id = Some(db_file_type.id);
                    }
                }
            }
            id
        };

        if let Some(type_id) = db_file_type {
            let known_type = KnownType::new(&contents)?;
            let meta_data = FileMetadata::new(&contents);

            if state
                .db_type
                .add_file(
                    &meta_data,
                    known_type,
                    self.user_id as i32,
                    self.source_id as i32,
                    type_id,
                )
                .await?
            {
                state.store_bytes(&contents)?;
                return Ok(true);
            }
        }

        Ok(false)
    }

    pub async fn execute(&self, config: &Config) -> anyhow::Result<ExitCode> {
        let state = config.state().await?;
        let db_file_types = state.db_type.get_known_data_types().await?;
        let mut counter = 0u32;

        for path in self.paths.iter() {
            if path.is_dir() {
                for entry in WalkDir::new(path)
                    .follow_links(self.follow_links)
                    .max_depth(self.max_depth)
                    .into_iter()
                {
                    let entry = entry.unwrap();
                    let entry = entry.path();
                    if entry.is_file() && self.load_file_path(&state, &db_file_types, entry).await?
                    {
                        counter += 1;
                    }
                }
            } else if self
                .load_file_path(&state, &db_file_types, path.as_path())
                .await?
            {
                counter += 1;
            }
        }

        println!("Inserted records for {counter} files.");

        Ok(ExitCode::SUCCESS)
    }
}
