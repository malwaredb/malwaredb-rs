mod groups;
mod load;
mod sources;
mod users;
use super::config::Config;

use std::process::ExitCode;

use clap::{Args, Subcommand, ValueHint};

/// Administrative Options for Malware Database Server
#[derive(Clone, Debug, Args, PartialEq)]
pub struct Admin {
    /// Config file, needed for the database connection information
    #[arg(short = 'c', value_name = "FILE", value_hint = ValueHint::FilePath)]
    pub config_file: std::path::PathBuf,

    /// Administrative subcommands
    #[clap(subcommand)]
    pub action: AdminActions,
}

impl Admin {
    pub async fn execute(&self) -> anyhow::Result<ExitCode> {
        let cfg = Config::from_file(&self.config_file)?;
        match &self.action {
            AdminActions::AddUserToGroup(cmd) => cmd.execute(&cfg).await,
            AdminActions::ClearAPIKeys(cmd) => cmd.execute(&cfg).await,
            AdminActions::ResetPassword(cmd) => cmd.execute(&cfg).await,
            AdminActions::AddGroupToSource(cmd) => cmd.execute(&cfg).await,
            AdminActions::BulkAdd(cmd) => cmd.execute(&cfg).await,
            AdminActions::Create(sub) => sub.execute(&cfg).await,
            AdminActions::List(sub) => sub.execute(&cfg).await,
        }
    }
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum AdminActions {
    AddUserToGroup(groups::AddUser),
    ClearAPIKeys(users::ResetAPIKeys),
    ResetPassword(users::ResetPassword),
    AddGroupToSource(sources::AddGroup),

    /// Bulk load files
    BulkAdd(load::Load),

    /// Create users, groups, sources
    #[clap(subcommand)]
    Create(CreateActions),

    /// List users, groups, sources
    #[clap(subcommand)]
    List(ListActions),
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum CreateActions {
    /// Create a user account
    User(users::Create),

    /// Create a group
    Group(groups::Create),

    /// Create a sample source
    Source(sources::Create),
}

impl CreateActions {
    pub async fn execute(&self, cfg: &Config) -> anyhow::Result<ExitCode> {
        match self {
            CreateActions::User(cmd) => cmd.execute(cfg).await,
            CreateActions::Group(cmd) => cmd.execute(cfg).await,
            CreateActions::Source(cmd) => cmd.execute(cfg).await,
        }
    }
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum ListActions {
    /// List users
    Users(users::List),
    /// List groups
    Groups(groups::List),
    /// List sources
    Sources(sources::List),
    /// List types
    Types,
}

impl ListActions {
    pub async fn execute(&self, cfg: &Config) -> anyhow::Result<ExitCode> {
        match self {
            ListActions::Users(cmd) => cmd.execute(cfg).await,
            ListActions::Groups(cmd) => cmd.execute(cfg).await,
            ListActions::Sources(cmd) => cmd.execute(cfg).await,
            ListActions::Types => {
                let state = cfg.state().await?;
                for data_type in state.db_type.get_known_data_types().await? {
                    print!("{}", data_type.name);
                    if let Some(desc) = data_type.description {
                        print!(" {desc}");
                    }
                    if data_type.executable {
                        print!(" -- is executable");
                    }
                    println!();
                    for magic in data_type.magic {
                        println!("\t{}", hex::encode(magic));
                    }
                }
                Ok(ExitCode::SUCCESS)
            }
        }
    }
}
