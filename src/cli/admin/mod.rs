mod compression;
mod config;
mod groups;
mod keys;
mod labels;
mod load;
mod sources;
mod users;

#[cfg(feature = "vt")]
mod vt;

use super::config::Config;

use std::process::ExitCode;

use clap::{Args, Subcommand, ValueHint};

/// Administrative Options for Malware Database Server
#[derive(Clone, Debug, Args, PartialEq)]
pub struct Admin {
    /// Config file: specify or search; needed for the database connection information.
    /// Specifying the path is best to avoid mix-up between instances.
    #[arg(short = 'c', value_name = "FILE", value_hint = ValueHint::FilePath)]
    pub config_file: Option<std::path::PathBuf>,

    /// Administrative subcommands
    #[clap(subcommand)]
    pub action: AdminActions,
}

impl Admin {
    pub async fn execute(&self) -> anyhow::Result<ExitCode> {
        if let AdminActions::DefaultConfig(default_config) = &self.action {
            return default_config.execute();
        }

        let cfg = if let Some(path) = &self.config_file {
            Config::from_file(path)
        } else {
            Config::from_found_files()
        }?;

        match &self.action {
            AdminActions::AddUserToGroup(cmd) => cmd.execute(&cfg).await,
            AdminActions::ClearAPIKeys(cmd) => cmd.execute(&cfg).await,
            AdminActions::ResetPassword(cmd) => cmd.execute(&cfg).await,
            AdminActions::AddGroupToSource(cmd) => cmd.execute(&cfg).await,
            AdminActions::BulkAdd(cmd) => cmd.execute(&cfg).await,
            AdminActions::Create(sub) => sub.execute(&cfg).await,
            AdminActions::List(sub) => sub.execute(&cfg).await,
            AdminActions::Compression(comp) => comp.execute(&cfg).await,
            #[cfg(feature = "vt")]
            AdminActions::VirusTotal(vt) => vt.execute(&cfg).await,
            AdminActions::DefaultConfig(_df) => unreachable!(),
            AdminActions::Stats => {
                let state = cfg.state().await?;
                let db_info = state.db_type.db_info().await?;
                println!(
                    "Number of samples: {}\nNumber of users: {}\nNumber of groups: {}\nNumber of sources: {}\nDatabase size: {}\nDatabase version: {}",
                    db_info.num_files, db_info.num_users, db_info.num_groups, db_info.num_sources, db_info.size, db_info.version
                );

                if db_info.num_files > 0 {
                    println!("File counts by type:");
                    let file_types_counts = state.db_type.file_types_counts().await?;
                    for (name, count) in file_types_counts {
                        println!("{name}: {count}");
                    }
                }

                Ok(ExitCode::SUCCESS)
            }
        }
    }
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum AdminActions {
    AddUserToGroup(groups::AddUser),
    ClearAPIKeys(users::ResetAPIKeys),
    ResetPassword(users::ResetPassword),
    AddGroupToSource(sources::AddGroup),
    /// Some information about the contents of the Database
    Stats,

    /// Show (or toggle) the state of MalwareDB storing incoming files with gzip compression
    Compression(compression::Compression),

    /// Show (or toggle) the state of MalwareDB submitting samples to VirusTotal
    #[cfg(feature = "vt")]
    VirusTotal(vt::VirusTotal),

    /// Bulk load files
    BulkAdd(load::Load),

    /// Create users, groups, sources
    #[clap(subcommand)]
    Create(CreateActions),

    /// List users, groups, sources
    #[clap(subcommand)]
    List(ListActions),

    /// Create an example config file optionally in the operating system-specific location
    DefaultConfig(config::CreateDefaultConfig),
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum CreateActions {
    /// Create a user account
    User(users::Create),

    /// Create a group
    Group(groups::Create),

    /// Create a key to be used for file encryption
    Key(keys::Create),

    /// Create a sample source
    Source(sources::Create),

    /// Create a label
    Label(labels::Create),
}

impl CreateActions {
    pub async fn execute(&self, cfg: &Config) -> anyhow::Result<ExitCode> {
        match self {
            CreateActions::User(cmd) => cmd.execute(cfg).await,
            CreateActions::Group(cmd) => cmd.execute(cfg).await,
            CreateActions::Key(cmd) => cmd.execute(cfg).await,
            CreateActions::Source(cmd) => cmd.execute(cfg).await,
            CreateActions::Label(cmd) => cmd.execute(cfg).await,
        }
    }
}

#[derive(Clone, Subcommand, Debug, PartialEq)]
pub enum ListActions {
    /// List users, accounts which may access MalwareDB
    Users(users::List),
    /// List file encryption key information
    Keys(keys::List),
    /// List groups, collections of users which may access sample(s)
    Groups(groups::List),
    /// List sources, the origins of file samples
    Sources(sources::List),
    /// List file types known to and supported by MalwareDB
    Types,
    /// List labels, a hierarchical taxonomy for file samples
    Labels(labels::List),
}

impl ListActions {
    pub async fn execute(&self, cfg: &Config) -> anyhow::Result<ExitCode> {
        match self {
            ListActions::Users(cmd) => cmd.execute(cfg).await,
            ListActions::Keys(cmd) => cmd.execute(cfg).await,
            ListActions::Groups(cmd) => cmd.execute(cfg).await,
            ListActions::Sources(cmd) => cmd.execute(cfg).await,
            ListActions::Labels(cmd) => cmd.execute(cfg).await,
            ListActions::Types => {
                let state = cfg.state().await?;
                for data_type in state.db_type.get_known_data_types().await? {
                    print!("{}", data_type.name);
                    if let Some(desc) = data_type.description {
                        print!(" {desc}");
                    }
                    if data_type.executable {
                        print!(" -- is executable");
                    }
                    println!();
                    for magic in data_type.magic {
                        println!("\t{}", hex::encode(magic));
                    }
                }
                Ok(ExitCode::SUCCESS)
            }
        }
    }
}
