mod data_loader;
mod updater;
use crate::cli::config::Config;

use std::process::ExitCode;

use anyhow::Result;
use clap::{Parser, Subcommand};

#[derive(Parser, Clone, Debug)]
pub struct VtOption {
    #[clap(subcommand)]
    pub vt: Vt,
}

/// Modes of operation for VT: either we query the data or load data already queried and saved.
#[derive(Subcommand, Clone, Debug)]
pub enum Vt {
    /// Run the VT update agent which queries VT for reports for files in the database and exits when finished
    Updater(updater::Updater),

    /// Load serialized VirusTotal data into MalwareDB, if the sample file is already known to MalwareDB
    Loader(data_loader::DataLoader),
}

impl VtOption {
    pub async fn execute(self) -> Result<ExitCode> {
        match self.vt {
            Vt::Updater(u) => u.execute().await,
            Vt::Loader(l) => l.execute().await,
        }
    }
}

/// VirusTotal config either from disk or command line
#[derive(Subcommand, Clone, Debug)]
enum VtConfig {
    /// Load VirusTotal config from a file
    Load(Load),

    /// VirusTotal config is passed on the command line
    Config(Config),
}

#[derive(Clone, Parser, Debug)]
struct Load {
    #[arg(value_name = "FILE", value_hint = clap::ValueHint::FilePath)]
    pub file: std::path::PathBuf,
}

impl Load {
    fn config(self) -> Result<Config> {
        Config::from_file(&self.file)
    }
}

impl VtConfig {
    pub fn config(self) -> Result<Config> {
        match self {
            VtConfig::Load(loader) => loader.config(),
            VtConfig::Config(config) => Ok(config),
        }
    }
}
