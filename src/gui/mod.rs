use crate::cli::config::Config;

use std::process::ExitCode;
use std::rc::Rc;

use anyhow::{ensure, Context, Result};
use clap::{Args, ValueHint};
use slint::{Model, ModelRc, SharedString, StandardListViewItem, VecModel};
use tracing::{debug, error};

slint::include_modules!();

#[derive(Clone, Debug, Args, PartialEq)]
pub struct AdminGui {
    #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
    config_file: std::path::PathBuf,
}

impl AdminGui {
    pub async fn execute(&self) -> Result<ExitCode> {
        let state = Config::from_file(&self.config_file)?.state().await?;
        let users = state
            .db_type
            .list_users()
            .await
            .context("failed to list users")?;

        let gui_usernames: Vec<StandardListViewItem> = users
            .iter()
            .map(|u| StandardListViewItem::from(SharedString::from(u.uname.clone())))
            .collect();

        let gui_usernames = VecModel::from(gui_usernames);

        let gui_users: Vec<GuiUser> = users
            .iter()
            .map(|u| GuiUser {
                id: u.id,
                uname: u.uname.clone().into(),
                email: u.email.clone().into(),
                fname: u.fname.clone().into(),
                lname: u.lname.clone().into(),
                active: u.has_api_key,
            })
            .collect();

        let groups = state
            .db_type
            .list_groups(false, false)
            .await
            .context("failed to list groups")?;
        let gui_groupnames: Vec<StandardListViewItem> = groups
            .iter()
            .map(|g| StandardListViewItem::from(SharedString::from(g.name.clone())))
            .collect();
        let gui_groupnames = VecModel::from(gui_groupnames);
        let gui_groups: Vec<GuiGroup> = groups
            .iter()
            .map(|g| GuiGroup {
                id: g.id,
                name: g.name.clone().into(),
                description: g.description.clone().into(),
                parent: g.parent.clone().unwrap_or("".into()).clone().into(),
            })
            .collect();

        ensure!(gui_users[0].id == 0, "the first user should be ID 0");
        ensure!(
            gui_users[0].uname == "admin",
            "the admin user should be ID 0"
        );

        let gui_users = VecModel::from(gui_users);
        let gui_groups = VecModel::from(gui_groups);

        let gui = AdminWindow::new()?;
        let ui_handle = gui.as_weak();

        gui.set_users_list(ModelRc::new(gui_usernames));
        gui.set_groups_list(ModelRc::new(gui_groupnames));

        let gui_users = ModelRc::from(Rc::new(gui_users));
        gui.set_users(gui_users);

        let gui_groups = ModelRc::from(Rc::new(gui_groups));
        gui.set_groups(gui_groups);

        gui.on_users_save_button_pressed(move || {
            let gui = ui_handle.upgrade().unwrap();
            gui.set_user_status("".into());
            let uid = gui.get_users_index();
            let uname = gui.get_user_name();
            let fname = gui.get_user_fname();
            let lname = gui.get_user_lname();
            let email = gui.get_user_email();

            if uid < 0 {
                gui.set_user_status("uid should never be negative".into());
                error!("uid should never be negative");
                return;
            }
            if uname.len() < 3 {
                gui.set_user_status("username too short".into());
                error!("username too short");
                return;
            }
            if fname.len() < 3 {
                gui.set_user_status("first name too short".into());
                error!("first name too short");
                return;
            }
            if lname.len() < 3 {
                gui.set_user_status("last name too short".into());
                error!("last name too short");
                return;
            }
            if email.len() < 6 {
                gui.set_user_status("email too short".into());
                error!("email too short");
                return;
            }
            if !email.contains('@') {
                gui.set_user_status("email doesn't appear valid".into());
                error!("email doesn't appear valid");
                return;
            }

            let handle = tokio::runtime::Handle::current();
            let _ = handle.enter();
            futures::executor::block_on(
                state.db_type.edit_user(uid, &uname, &fname, &lname, &email),
            )
            .expect("failed to update database");

            let password = gui.get_user_password();
            if password.len() > 1 {
                futures::executor::block_on(state.db_type.set_password(&uname, &password))
                    .expect("failed to update password");
                debug!("Set new password for {uid}!");
            } else {
                debug!(
                    "Not setting password for {uid}, {} is too short",
                    password.len()
                );
            }

            let users_list = gui.get_users_list();
            users_list.set_row_data(uid as usize, StandardListViewItem::from(uname.clone()));

            let users = gui.get_users();
            if let Some(mut row) = users.row_data(uid as usize) {
                row.uname = uname;
                row.fname = fname;
                row.lname = lname;
                row.email = email;
                users.set_row_data(uid as usize, row);
            }
        });

        gui.run().unwrap();
        Ok(ExitCode::SUCCESS)
    }
}
