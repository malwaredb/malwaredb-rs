use crate::utils::{bytes_offset_match, u16_from_offset, u32_from_offset};
use crate::{Architecture, ExecutableFile, OperatingSystem, Ordering, Section, Sections};
use types::KnownType;

use std::fmt::{Display, Formatter};

use anyhow::{bail, Context, Result};

// Microsoft documentation:
// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
// Wikipedia entry:
// https://en.wikipedia.org/wiki/Portable_Executable

const EXE_MAGIC: [u8; 2] = [b'M', b'Z'];
const PE_MAGIC: [u8; 4] = [0x50, 0x45, 0x00, 0x00];

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum SubType {
    /// MS-DOS, IBM DOS, FreeDOS executable
    DosExe,

    /// .Net executable, PE32
    DotNet,

    /// Portable Executable, MS Windows
    PE32,

    /// 64-bit Portable Executable, MS Windows
    PE32_64,

    /// New Executable, 16-bit, Windows 3.1
    NE,

    /// Linear Executable, IBM OS/2
    LE,
}

impl Display for SubType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SubType::DosExe => write!(f, "MZ DOS executable"),
            SubType::DotNet => write!(f, ".Net executable"),
            SubType::PE32 => write!(f, "Portable Executable (PE32)"),
            SubType::PE32_64 => write!(f, "64-bit Portable Executable (PE32+)"),
            SubType::NE => write!(f, "New Executable"),
            SubType::LE => write!(f, "Linear Executable"),
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum SubSystem {
    Unknown,
    WindowsGUI,
    WindowsCLI,
    OS2CLI,
    POSIX,
    NativeCode,
    NativeDriver,
    WindowsCE,
    EFI,
    EFIBoot,
    EFIRom,
    EFIRuntimeDriver,
    Xbox,
    WindowsBoot,
}

impl Display for SubSystem {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SubSystem::Unknown => write!(f, "Unknown subsystem"),
            SubSystem::WindowsGUI => write!(f, "Windows GUI"),
            SubSystem::WindowsCLI => write!(f, "Windows CLI"),
            SubSystem::OS2CLI => write!(f, "OS/2 CLI"),
            SubSystem::POSIX => write!(f, "Posix"),
            SubSystem::NativeCode => write!(f, "Native Code"),
            SubSystem::NativeDriver => write!(f, "Native Driver"),
            SubSystem::WindowsCE => write!(f, "Windows CE"),
            SubSystem::EFI => write!(f, "EFI"),
            SubSystem::EFIBoot => write!(f, "EFI boot"),
            SubSystem::EFIRom => write!(f, "EFI ROM"),
            SubSystem::EFIRuntimeDriver => write!(f, "EFI driver with runtime"),
            SubSystem::Xbox => write!(f, "Xbox"),
            SubSystem::WindowsBoot => write!(f, "Windows Boot"),
        }
    }
}

impl From<u16> for SubSystem {
    fn from(value: u16) -> Self {
        match value {
            1 => SubSystem::NativeCode,
            2 => SubSystem::WindowsGUI,
            3 => SubSystem::WindowsCLI,
            5 => SubSystem::OS2CLI,
            7 => SubSystem::POSIX,
            8 => SubSystem::NativeDriver,
            9 => SubSystem::WindowsCE,
            10 => SubSystem::EFI,
            11 => SubSystem::EFIBoot,
            12 => SubSystem::EFIRuntimeDriver,
            13 => SubSystem::EFIRom,
            14 => SubSystem::Xbox,
            16 => SubSystem::WindowsBoot,
            _ => SubSystem::Unknown,
        }
    }
}

#[derive(Clone, Debug)]
pub struct EXE<'a> {
    pub is64bit: bool,
    pub has_overlay: Option<bool>,
    pub arch: Architecture,
    pub sub_type: SubType,
    pub os: OperatingSystem,
    pub subsystem: Option<SubSystem>,
    pub sections: Option<Sections>,
    pub contents: &'a [u8],
}

impl<'a> EXE<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        if !(contents[0] == EXE_MAGIC[0] && contents[1] == EXE_MAGIC[1]) {
            bail!("Not a MZ, MS-DOS, or PE32 file");
        }

        let offset = u32_from_offset(contents, 0x3C, Ordering::LittleEndian);
        if offset as usize > contents.len()
            || offset as usize + PE_MAGIC.len() > contents.len()
            || !bytes_offset_match(contents, offset as usize, &PE_MAGIC)
        {
            return Ok(Self {
                is64bit: false,
                has_overlay: None,
                arch: Architecture::X86,
                sub_type: SubType::DosExe,
                os: OperatingSystem::DOS,
                subsystem: None,
                sections: None,
                contents,
            });
        }

        let mut sections = Sections::default();
        sections.0.push(Section {
            name: "DOS Header".into(),
            is_executable: false,
            size: 0x3F,
            offset: 0,
        });
        sections.0.push(Section {
            name: "DOS Stub".into(),
            is_executable: true,
            size: (offset - 0x3F) as usize,
            offset: 0x3F,
        });
        sections.0.push(Section {
            name: "COFF Header".into(),
            is_executable: false,
            size: 20,
            offset: offset as usize,
        });

        let machine = u16_from_offset(contents, (offset + 4) as usize, Ordering::LittleEndian);

        // A EXE-specific mapping from numbers to architecture is needed, as if differs by file type
        let arch = match machine {
            0x284 | 0x184 => Architecture::Alpha,
            0x1c0 => Architecture::ARM,
            0x1c4 | 0x1c2 => Architecture::ARMThumb,
            0xAA64 => Architecture::ARM64,
            0x1a2 | 0x1a3 => Architecture::HitachiSH3, // 0x1a3 is SH3 DSP
            0x1a6 => Architecture::HitachiSH4,
            0x1a8 => Architecture::HitachiSH5,
            0x6232 => Architecture::LoongArch32,
            0x6264 => Architecture::LoongArch64,
            0x169 | 0x266 | 0x366 | 0x466 | 0x166 => Architecture::MIPSEL,
            0x1f0 | 0x1f1 => Architecture::PowerPCLE, // 0x1f1 is PPCLE with FPU
            0x5032 => Architecture::RISCV,
            0x5064 => Architecture::RISCV64,
            0x5128 => Architecture::RISCV128,
            0x14c => Architecture::X86,
            0x8664 => Architecture::X86_64,
            0 => Architecture::Unknown,
            other => Architecture::Other(other),
        };

        let characteristics =
            u16_from_offset(contents, (offset + 22) as usize, Ordering::LittleEndian);
        let num_sections = u16_from_offset(contents, (offset + 6) as usize, Ordering::LittleEndian);

        let offset = u32_from_offset(contents, 0x3C, Ordering::LittleEndian) + 25;
        let is64bit = contents[offset as usize] == 0x02;
        let (sub_type, offset) = {
            if contents[offset as usize] == 0x02 {
                (
                    SubType::PE32_64,
                    u32_from_offset(contents, 0x3C, Ordering::LittleEndian) + 248,
                )
            } else {
                (
                    SubType::PE32,
                    u32_from_offset(contents, 0x3C, Ordering::LittleEndian) + 232,
                )
            }
        };

        let sub_type = {
            if u32_from_offset(contents, offset as usize, Ordering::LittleEndian) > 0 {
                SubType::DotNet
            } else {
                sub_type
            }
        };

        let mut subsystem = None;
        let mut has_overlay = false;
        if (characteristics & 0x0002) != 0 {
            let mut offset = u32_from_offset(contents, 0x3C, Ordering::LittleEndian) + 24;
            subsystem = Some(
                u16_from_offset(contents, (offset + 68) as usize, Ordering::LittleEndian).into(),
            );
            sections.0.push(Section {
                name: "Optional Header".into(),
                is_executable: false,
                size: 240,
                offset: offset as usize,
            });
            if is64bit {
                offset += 240;
            } else {
                offset += 224;
            }
            let mut sections_offset = 0;
            for _sec_num in 0..num_sections {
                let section_name =
                    String::from_utf8(contents[offset as usize..(offset + 8) as usize].to_vec())?;
                let section_size =
                    u32_from_offset(contents, (offset + 16) as usize, Ordering::LittleEndian);
                let section_offset =
                    u32_from_offset(contents, (offset + 20) as usize, Ordering::LittleEndian);
                let section_characteristics =
                    u32_from_offset(contents, (offset + 36) as usize, Ordering::LittleEndian);
                let section_executable = (section_characteristics & 0x00000020) != 0
                    || (section_characteristics & 0x20000000) != 0;

                sections.0.push(Section {
                    name: section_name,
                    is_executable: section_executable,
                    size: section_size as usize,
                    offset: section_offset as usize,
                });

                if section_size + section_offset > sections_offset {
                    sections_offset = section_size + section_offset;
                }
                offset += 40; // Section entries are 40 bytes
            }
            has_overlay = sections_offset > 0 && contents.len() - sections_offset as usize > 0;
        } else {
            sections.0.push(Section {
                name: "Optional Header".into(),
                is_executable: false,
                size: 112,
                offset: offset as usize,
            });
        }

        Ok(Self {
            is64bit,
            has_overlay: Some(has_overlay),
            arch,
            sub_type,
            os: OperatingSystem::Windows,
            subsystem,
            sections: Some(sections),
            contents,
        })
    }
}

impl<'a> ExecutableFile for EXE<'a> {
    fn type_name(&self) -> String {
        self.sub_type.to_string()
    }

    fn architecture(&self) -> &Architecture {
        &self.arch
    }

    fn pointer_size(&self) -> usize {
        if self.sub_type == SubType::PE32_64 {
            64
        } else {
            32
        }
    }

    fn operating_system(&self) -> &OperatingSystem {
        &self.os
    }

    fn num_sections(&self) -> usize {
        if let Some(sections) = &self.sections {
            sections.0.len()
        } else {
            0
        }
    }

    fn sections(&self) -> Result<&Sections> {
        self.sections
            .as_deref()
            .ok_or_else(|| anyhow::Error::msg("No sections"))
            .context("")
    }
}

impl<'a> KnownType for EXE<'a> {
    const MAGIC: &'static [u8] = &[b'M', b'Z'];
}

impl<'a> Display for EXE<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "EXE file:")?;
        writeln!(f, "\tSubtype: {}", self.sub_type)?;
        writeln!(f, "\tOS: {}", self.os)?;
        if let Some(subsys) = &self.subsystem {
            writeln!(f, "\tSubsystem: {subsys}")?;
        }
        if let Some(sections) = &self.sections {
            writeln!(f, "\t{} sections:", sections.0.len())?;
            for section in sections.0.iter() {
                writeln!(f, "\t\t{}", section)?;
            }
        }
        if self.has_overlay == Some(true) {
            writeln!(f, "\tHas extra bytes at the end (overlay).")?;
        }
        writeln!(f, "\tSize: {}", self.contents.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn arm64_gnu() {
        const BYTES: &[u8] = include_bytes!("../../testdata/exe/pe64_win32_console_arm64_gnu.exe");

        let exe = EXE::from(BYTES).unwrap();
        assert_eq!(exe.arch, Architecture::ARM64);
        assert_eq!(exe.sub_type, SubType::PE32_64);
        assert_eq!(exe.subsystem, Some(SubSystem::WindowsCLI));
    }

    #[test]
    fn x86_64_gnu() {
        const BYTES: &[u8] = include_bytes!("../../testdata/exe/pe64_win32_console_x86_64_gnu.exe");

        let exe = EXE::from(BYTES).unwrap();
        assert_eq!(exe.arch, Architecture::X86_64);
        assert_eq!(exe.sub_type, SubType::PE32_64);
        assert_eq!(exe.subsystem, Some(SubSystem::WindowsCLI));
    }

    #[test]
    fn dot_net_mono() {
        const BYTES: &[u8] = include_bytes!("../../testdata/exe/pe32_dotnet.exe");

        let exe = EXE::from(BYTES).unwrap();
        assert_eq!(exe.arch, Architecture::X86);
        assert_eq!(exe.sub_type, SubType::DotNet);
        assert_eq!(exe.subsystem, Some(SubSystem::WindowsCLI));
    }
}
