use crate::{Architecture, Imports, OperatingSystem, Ordering, Sections};
use std::fmt::{Display, Formatter};

use crate::utils::u16_from_offset;
use anyhow::Result;

// Wikipedia article:
// https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

pub const MAGIC: [u8; 4] = [0x7f, 0x45, 0x4c, 0x46];

#[derive(Clone, Debug)]
pub struct Elf<'a> {
    pub arch: Architecture,
    pub has_overlay: Option<bool>,
    pub os: OperatingSystem,
    pub sections: Option<Sections>,
    pub imports: Option<Imports>,
    pub contents: &'a [u8],
}

impl<'a> Elf<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        let is_64bit = contents[4] == 2;
        let is_big_endian = contents[5] == 2;
        let os = match contents[7] {
            0 => OperatingSystem::UnknownUnixLike,
            1 => OperatingSystem::HPUX,
            2 => OperatingSystem::NetBSD,
            3 => OperatingSystem::Linux,
            6 => OperatingSystem::Solaris,
            7 => OperatingSystem::AIX,
            8 => OperatingSystem::Irix,
            9 => OperatingSystem::FreeBSD,
            0xC => OperatingSystem::OpenBSD,
            x => OperatingSystem::Other(format!("0x{x:02x}")),
        };

        let arch = {
            if is_big_endian {
                u16_from_offset(contents, 0x12, Ordering::BigEndian)
            } else {
                u16_from_offset(contents, 0x12, Ordering::LittleEndian)
            }
        };

        let arch = match arch {
            // https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
            0 => Architecture::Unknown,
            2 => Architecture::Sparc,
            3 => Architecture::X86,
            4 => Architecture::M68k,
            5 => Architecture::M88k,
            8 => Architecture::MIPS,
            0x0A => Architecture::MIPSEL,
            0x14 => {
                if is_big_endian {
                    Architecture::PowerPC
                } else {
                    Architecture::PowerPCLE
                }
            }
            0x15 => {
                if is_big_endian {
                    Architecture::PowerPC64
                } else {
                    Architecture::PowerPC64LE
                }
            }

            0x28 => Architecture::ARM,
            0x29 => Architecture::Alpha,
            0x2b => Architecture::Sparc64,

            0x32 => Architecture::Itanium,
            0x3E => Architecture::X86_64,

            0xB7 => Architecture::ARM64,

            0xF3 => {
                if is_64bit {
                    Architecture::RISCV64
                } else {
                    Architecture::RISCV
                }
            }

            x => Architecture::Other(format!("0x{x:02x}")),
        };

        Ok(Self {
            arch,
            has_overlay: None,
            os,
            sections: None,
            imports: None,
            contents,
        })
    }
}

impl<'a> Display for Elf<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "ELF file:")?;
        writeln!(f, "\tOS: {}", self.os)?;
        if let Some(sections) = &self.sections {
            writeln!(f, "\t{} sections:", sections.0.len())?;
            for section in sections.0.iter() {
                writeln!(f, "\t\t{}", section)?;
            }
        }
        if self.has_overlay == Some(true) {
            writeln!(f, "\tHas extra bytes at the end (overlay).")?;
        }
        writeln!(f, "\tSize: {}", self.contents.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arm32() {
        const BYTES: &[u8] = include_bytes!("../../testdata/elf/elf_arm");

        let elf = Elf::from(BYTES).unwrap();
        assert_eq!(elf.arch, Architecture::ARM);
    }

    #[test]
    fn test_arm64() {
        const BYTES: &[u8] = include_bytes!("../../testdata/elf/elf_arm64");

        let elf = Elf::from(BYTES).unwrap();
        assert_eq!(elf.arch, Architecture::ARM64);
    }

    #[test]
    fn test_ppc64le() {
        const BYTES: &[u8] = include_bytes!("../../testdata/elf/elf_ppc64le");

        let elf = Elf::from(BYTES).unwrap();
        eprintln!("{elf}");
        assert_eq!(elf.arch, Architecture::PowerPC64LE);
    }

    #[test]
    fn test_riscv() {
        const BYTES: &[u8] = include_bytes!("../../testdata/elf/elf_riscv64");

        let elf = Elf::from(BYTES).unwrap();
        assert_eq!(elf.arch, Architecture::RISCV64);
    }
}
