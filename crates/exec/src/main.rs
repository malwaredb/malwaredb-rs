use exec;
use std::env;

fn main() {
    #[cfg(not(any(
        feature = "default",
        feature = "elf",
        feature = "macho",
        feature = "pe32",
        feature = "pef"
    )))]
    compile_error!("No features selected, this program won't do anything.");

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <path to executable file>", args[0]);
        std::process::exit(10);
    }
    for arg in &args[1..] {
        let contents = match std::fs::read(arg) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("Failed to read {arg}: {e}");
                continue;
            }
        };

        #[cfg(feature = "elf")]
        if let Ok(elf) = exec::elf::Elf::from(&contents) {
            println!("{arg} is an ELF:\n{elf}");
            continue;
        }

        #[cfg(feature = "pe32")]
        if let Ok(exe) = exec::pe32::EXE::from(&contents) {
            println!("{arg} is an EXE:\n{exe}");
            continue;
        }

        #[cfg(feature = "macho")]
        if let Ok(fmacho) = exec::macho::fat::FatMacho::from(&contents) {
            println!("{arg} is a Fat Mach-O:\n{fmacho}");
            continue;
        }

        #[cfg(feature = "macho")]
        if let Ok(macho) = exec::macho::Macho::from(&contents) {
            println!("{arg} is a Mach-O:\n{macho}");
            continue;
        }

        #[cfg(feature = "pef")]
        if let Ok(pef) = exec::pef::Pef::from(&contents) {
            println!("{arg} is a PEF:\n{pef}");
            continue;
        }

        eprintln!("{arg} isn't a known executable file.");
    }
}
