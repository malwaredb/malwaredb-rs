// Convenience functions for reading data types from binary blobs

use crate::Ordering;

pub fn u16_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> u16 {
    let bytes: [u8; 2] = [contents[offset], contents[offset + 1]];
    if endian == Ordering::BigEndian {
        u16::from_be_bytes(bytes)
    } else {
        u16::from_le_bytes(bytes)
    }
}

pub fn u32_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> u32 {
    let bytes: [u8; 4] = [
        contents[offset],
        contents[offset + 1],
        contents[offset + 2],
        contents[offset + 3],
    ];
    if endian == Ordering::BigEndian {
        u32::from_be_bytes(bytes)
    } else {
        u32::from_le_bytes(bytes)
    }
}

pub fn u64_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> u64 {
    let bytes: [u8; 8] = [
        contents[offset],
        contents[offset + 1],
        contents[offset + 2],
        contents[offset + 3],
        contents[offset + 4],
        contents[offset + 5],
        contents[offset + 6],
        contents[offset + 7],
    ];
    if endian == Ordering::BigEndian {
        u64::from_be_bytes(bytes)
    } else {
        u64::from_le_bytes(bytes)
    }
}

pub fn f32_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> f32 {
    let bytes: [u8; 4] = [
        contents[offset],
        contents[offset + 1],
        contents[offset + 2],
        contents[offset + 3],
    ];
    if endian == Ordering::BigEndian {
        f32::from_be_bytes(bytes)
    } else {
        f32::from_le_bytes(bytes)
    }
}

pub fn f64_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> f64 {
    let bytes: [u8; 8] = [
        contents[offset],
        contents[offset + 1],
        contents[offset + 2],
        contents[offset + 3],
        contents[offset + 4],
        contents[offset + 5],
        contents[offset + 6],
        contents[offset + 7],
    ];
    if endian == Ordering::BigEndian {
        f64::from_be_bytes(bytes)
    } else {
        f64::from_le_bytes(bytes)
    }
}

pub fn string_from_offset(contents: &[u8], offset: usize) -> String {
    let mut bytes = Vec::new();
    let mut position = offset;
    loop {
        bytes.push(contents[position]);
        position += 1;
        if contents[position] == 0 {
            break;
        }
    }

    String::from_utf8(bytes).unwrap()
}

pub fn bytes_offset_match(haystack: &[u8], offset: usize, needle: &[u8]) -> bool {
    if offset >= haystack.len() || haystack.len() - offset < needle.len() {
        return false;
    }

    let mut matches = true;

    for index in 0..needle.len() {
        if haystack[offset + index] != needle[index] {
            matches = false;
            break;
        }
    }

    matches
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    const TWO_BYTES: [u8; 2] = [0x12, 0x34];
    const FOUR_BYTES: [u8; 4] = [0x12, 0x34, 0x56, 0x78];

    #[test]
    fn u16_le() {
        assert_eq!(
            u16_from_offset(&TWO_BYTES, 0, Ordering::LittleEndian),
            13330
        );
    }

    #[test]
    fn u16_be() {
        assert_eq!(u16_from_offset(&TWO_BYTES, 0, Ordering::BigEndian), 4660);
    }

    #[test]
    fn u32_le() {
        assert_eq!(
            u32_from_offset(&FOUR_BYTES, 0, Ordering::LittleEndian),
            2018915346
        );
    }

    #[test]
    fn u32_be() {
        assert_eq!(
            u32_from_offset(&FOUR_BYTES, 0, Ordering::BigEndian),
            305419896
        );
    }

    #[test]
    fn f32_le() {
        assert_eq!(
            f32_from_offset(&FOUR_BYTES, 0, Ordering::LittleEndian),
            f32::from_str("1.73782444e+34").unwrap()
        );
    }

    #[test]
    fn f32_be() {
        assert_eq!(
            f32_from_offset(&FOUR_BYTES, 0, Ordering::BigEndian),
            f32::from_str("5.69045661e-28").unwrap()
        );
    }
}
