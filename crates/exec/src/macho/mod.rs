pub mod fat;

use crate::utils::{bytes_offset_match, u16_from_offset};
use crate::{Architecture, ExecutableType, Imports, OperatingSystem, Ordering, Sections};

use std::fmt::{Display, Formatter};

use anyhow::{bail, Result};

// Apple's Mach-O loader:
// https://opensource.apple.com/source/xnu/xnu-2050.18.24/EXTERNAL_HEADERS/mach-o/loader.h

const MAGIC32: [u8; 4] = [0xfe, 0xed, 0xfa, 0xce];
const CIGAM32: [u8; 4] = [0xce, 0xfa, 0xed, 0xfe];
const MAGIC64: [u8; 4] = [0xfe, 0xed, 0xfa, 0xcf];
const CIGAM64: [u8; 4] = [0xcf, 0xfa, 0xed, 0xfe];

#[derive(Clone, Debug)]
pub struct Macho<'a> {
    pub is64bit: bool,
    pub arch: Architecture,
    pub has_overlay: Option<bool>,
    pub ordering: Ordering,
    pub executable_type: ExecutableType,
    pub os: OperatingSystem,
    pub sections: Option<Sections>,
    pub imports: Option<Imports>,
    pub contents: &'a [u8],
}

impl<'a> Macho<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        let (is_64bit, ordering) = {
            if bytes_offset_match(contents, 0, &MAGIC32) {
                (false, Ordering::BigEndian)
            } else if bytes_offset_match(contents, 0, &CIGAM32) {
                (false, Ordering::LittleEndian)
            } else if bytes_offset_match(contents, 0, &MAGIC64) {
                (true, Ordering::BigEndian)
            } else if bytes_offset_match(contents, 0, &CIGAM64) {
                (true, Ordering::LittleEndian)
            } else {
                bail!("Not a Mach-O file");
            }
        };

        let arch = match u16_from_offset(contents, 4, ordering) {
            0x06 => Architecture::M68k,
            0x07 => {
                if is_64bit {
                    Architecture::X86_64
                } else {
                    Architecture::X86
                }
            }
            0x8 => {
                if is_64bit {
                    Architecture::MIPS64
                } else {
                    Architecture::MIPS
                }
            }
            0x0C => {
                if is_64bit {
                    Architecture::ARM64
                } else {
                    Architecture::ARM
                }
            }
            0x0D => Architecture::M88k,
            0x0E => {
                if is_64bit {
                    Architecture::Sparc64
                } else {
                    Architecture::Sparc
                }
            }
            0x10 => Architecture::Alpha,
            0x12 => {
                if is_64bit {
                    Architecture::PowerPC64
                } else {
                    Architecture::PowerPC
                }
            }
            other => Architecture::Other(other),
        };

        let exec_type = u16_from_offset(contents, 4, ordering);
        let exec_type = {
            if (exec_type & 0x02) != 0 || (exec_type & 0x05) != 0 {
                ExecutableType::Program
            } else if (exec_type & 0x06) != 0 || (exec_type & 0x09) != 0 {
                ExecutableType::Library
            } else if (exec_type & 0x04) != 0 {
                ExecutableType::Core
            } else {
                ExecutableType::Unknown(exec_type)
            }
        };

        Ok(Self {
            is64bit: is_64bit,
            arch,
            has_overlay: None,
            ordering,
            executable_type: exec_type,
            os: OperatingSystem::MacOS,
            sections: None,
            imports: None,
            contents,
        })
    }
}

impl<'a> Display for Macho<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Mach-O file:")?;
        writeln!(f, "\tOS: {}", self.os)?;
        writeln!(f, "\tArchitecture: {}", self.arch)?;
        writeln!(f, "\tOrdering: {}", self.ordering)?;
        writeln!(f, "\tType: {}", self.executable_type)?;
        if let Some(sections) = &self.sections {
            writeln!(f, "\t{} sections:", sections.0.len())?;
            for section in sections.0.iter() {
                writeln!(f, "\t\t{}", section)?;
            }
        }
        if self.has_overlay == Some(true) {
            writeln!(f, "\tHas extra bytes at the end (overlay).")?;
        }
        writeln!(f, "\tSize: {}", self.contents.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arm64() {
        const BYTES: &[u8] = include_bytes!("../../testdata/macho/macho_arm64");

        let macho = Macho::from(BYTES).unwrap();
        assert!(macho.is64bit);
        assert_eq!(macho.executable_type, ExecutableType::Program);
        assert_eq!(macho.arch, Architecture::ARM64);
    }

    #[test]
    fn test_x86_64() {
        const BYTES: &[u8] = include_bytes!("../../testdata/macho/macho_x86_64");

        let macho = Macho::from(BYTES).unwrap();
        assert!(macho.is64bit);
        assert_eq!(macho.executable_type, ExecutableType::Program);
        assert_eq!(macho.arch, Architecture::X86_64);
    }
}
