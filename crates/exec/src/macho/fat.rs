use crate::macho::Macho;
use crate::utils::{bytes_offset_match, u32_from_offset};
use types::KnownType;

use std::fmt::{Display, Formatter};

use crate::Ordering;
use anyhow::{bail, Result};

const MAGIC: [u8; 4] = [0xCA, 0xFE, 0xBA, 0xBE];

#[derive(Clone, Debug)]
pub struct FatMacho<'a> {
    pub binaries: Vec<Macho<'a>>,
    pub has_overlay: Option<bool>,
    pub contents: &'a [u8],
}

impl<'a> FatMacho<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        if !bytes_offset_match(contents, 0, &MAGIC) {
            bail!("Not a Fat Mach-O file");
        }

        let contained_binaries = u32_from_offset(contents, 4, Ordering::BigEndian) as usize;

        if contained_binaries > 0x20 {
            // Might be a Java .class file
            // https://stackoverflow.com/questions/73546728/magic-value-collision-between-macho-fat-binaries-and-java-class-files
            bail!("Not a Fat Mach-O file");
        }

        let mut binaries = Vec::with_capacity(contained_binaries);
        let mut offset_counter = 8;
        for _contained_binary_offset in 0..contained_binaries {
            let offset =
                u32_from_offset(contents, offset_counter + 8, Ordering::BigEndian) as usize;
            let size = u32_from_offset(contents, offset_counter + 12, Ordering::BigEndian) as usize;
            binaries.push(Macho::from(&contents[offset..offset + size])?);
            offset_counter += 20;
        }

        Ok(Self {
            binaries,
            has_overlay: None,
            contents,
        })
    }
}

impl<'a> KnownType for FatMacho<'a> {
    const MAGIC: &'static [u8] = &MAGIC;
}

impl<'a> Display for FatMacho<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(
            f,
            "Fat Mach-O containing {} architectures:",
            self.binaries.len()
        )?;
        for bin in self.binaries.iter() {
            writeln!(f, "{bin}")?;
        }
        writeln!(f, "\tSize: {}", self.contents.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn three_arch() {
        const BYTES: &[u8] = include_bytes!("../../testdata/macho/macho_fat_arm64_x86_64");

        let macho = FatMacho::from(BYTES).unwrap();
        assert_eq!(macho.binaries.len(), 2);
    }

    #[test]
    fn four_arch() {
        const BYTES: &[u8] =
            include_bytes!("../../testdata/macho/macho_fat_arm64_ppc_ppc64_x86_64");

        let macho = FatMacho::from(BYTES).unwrap();
        assert_eq!(macho.binaries.len(), 4);
    }
}
