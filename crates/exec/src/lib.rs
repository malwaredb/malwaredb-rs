use anyhow::Result;
use std::fmt::{Display, Formatter};
use std::ops::Deref;

#[cfg(feature = "elf")]
pub mod elf;

#[cfg(feature = "pe32")]
pub mod pe32;

pub mod utils;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum Architecture {
    Alpha,
    ARM,
    ARMThumb,
    ARM64,
    HitachiSH3,
    HitachiSH4,
    HitachiSH5,
    Itanium,
    LoongArch32,
    LoongArch64,
    M68k,
    M88k,
    MIPS,
    MIPS64,
    MIPSEL,
    MIPSEL64,
    PowerPC,
    PowerPC64,
    PowerPCLE,
    PowerPC64LE,
    RISCV,
    RISCV64,
    RISCV128,
    Sparc,
    Sparc64,
    X86,
    X86_64,
    Other(u16),
    Unknown,
}

impl Display for Architecture {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Architecture::Alpha => write!(f, "DEC Alpha"),
            Architecture::ARM => write!(f, "ARM"),
            Architecture::ARMThumb => write!(f, "ARM Thumb"),
            Architecture::ARM64 => write!(f, "ARM64"),
            Architecture::HitachiSH3 => write!(f, "Hitachi SH3"),
            Architecture::HitachiSH4 => write!(f, "Hitachi SH4"),
            Architecture::HitachiSH5 => write!(f, "Hitachi SH5"),
            Architecture::Itanium => write!(f, "Intel Itanium"),
            Architecture::LoongArch32 => write!(f, "LoongArch"),
            Architecture::LoongArch64 => write!(f, "LoongArch64"),
            Architecture::M68k => write!(f, "M68k"),
            Architecture::M88k => write!(f, "M88k"),
            Architecture::MIPS => write!(f, "MIPS"),
            Architecture::MIPS64 => write!(f, "MIPS64"),
            Architecture::MIPSEL => write!(f, "MIPSEL"),
            Architecture::MIPSEL64 => write!(f, "MIPSEL64"),
            Architecture::PowerPC => write!(f, "PowerPC"),
            Architecture::PowerPC64 => write!(f, "PowerPC64"),
            Architecture::PowerPCLE => write!(f, "PowerPCLE"),
            Architecture::PowerPC64LE => write!(f, "PowerPC64LE"),
            Architecture::RISCV => write!(f, "RISC-V"),
            Architecture::RISCV64 => write!(f, "RISC-V 64"),
            Architecture::RISCV128 => write!(f, "RISC-V 128"),
            Architecture::Sparc => write!(f, "Sparc"),
            Architecture::Sparc64 => write!(f, "Sparc64"),
            Architecture::X86 => write!(f, "x86"),
            Architecture::X86_64 => write!(f, "x86_64"),
            Architecture::Other(other) => write!(f, "Other: 0x{other:02x}"),
            Architecture::Unknown => write!(f, "Unknown architecture, or architecture-independent"),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum OperatingSystem {
    AIX,
    Linux,
    FreeBSD,
    OpenBSD,
    NetBSD,
    HPUX,
    Irix,
    Solaris,
    UnknownUnixLike,
    Haiku,
    MacOS,
    DOS,
    Windows,
    Other(u16),
}

impl Display for OperatingSystem {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            OperatingSystem::AIX => write!(f, "AIX"),
            OperatingSystem::Linux => write!(f, "Linux"),
            OperatingSystem::FreeBSD => write!(f, "FreeBSD"),
            OperatingSystem::OpenBSD => write!(f, "OpenBSD"),
            OperatingSystem::NetBSD => write!(f, "NetBSD"),
            OperatingSystem::HPUX => write!(f, "HP-UX"),
            OperatingSystem::Irix => write!(f, "Irix"),
            OperatingSystem::Solaris => write!(f, "Solaris"),
            OperatingSystem::UnknownUnixLike => write!(f, "Unknown Unix or Unix-like"),
            OperatingSystem::Haiku => write!(f, "Haiku"),
            OperatingSystem::MacOS => write!(f, "Mac OS (or maybe iOS)"),
            OperatingSystem::DOS => write!(f, "MS-DOS or compatible"),
            OperatingSystem::Windows => write!(f, "Windows"),
            OperatingSystem::Other(other) => write!(f, "Other: 0x{other:02x}"),
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Ordering {
    BigEndian,
    LittleEndian,
    BiEndian,
}

impl Display for Ordering {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Ordering::BigEndian => write!(f, "Big Endian"),
            Ordering::LittleEndian => write!(f, "Little Endian"),
            Ordering::BiEndian => write!(f, "Bi-Endian"),
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ExecutableType {
    /// Core file, from a crash
    Core,

    /// Shared library
    Library,

    /// Directly executable program or application
    Program,

    Unknown,
}

impl Display for ExecutableType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            ExecutableType::Core => write!(f, "Core file"),
            ExecutableType::Library => write!(f, "Shared library"),
            ExecutableType::Program => write!(f, "Program/Application"),
            ExecutableType::Unknown => write!(f, "Unknown"),
        }
    }
}

trait ExecutableFile {
    fn type_name(&self) -> String;

    fn architecture(&self) -> &Architecture;
    fn pointer_size(&self) -> usize;
    fn operating_system(&self) -> &OperatingSystem;

    fn num_sections(&self) -> usize;
    fn sections(&self) -> Result<&Sections>;
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Section {
    pub name: String,
    pub is_executable: bool,
    pub size: usize,
    pub offset: usize,
}

#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Sections(Vec<Section>);

impl Display for Section {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} at 0x{:02x}, size 0x{:02x}",
            self.name, self.offset, self.size
        )?;
        if self.is_executable {
            write!(f, " - executable")?;
        }
        Ok(())
    }
}

impl Display for Sections {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        for section in self.0.iter() {
            writeln!(f, "{section}")?;
        }
        Ok(())
    }
}

impl Deref for Sections {
    type Target = Sections;

    fn deref(&self) -> &Self::Target {
        // Seems silly, but seems required for making an Option<Sections> into Result<&Sections>
        self
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Import {
    pub library: String,
    pub function: String,
}

impl Display for Import {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.library, self.function)
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Imports(Vec<Import>);

impl Display for Imports {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        for import in self.0.iter() {
            writeln!(f, "{import}")?;
        }
        Ok(())
    }
}
