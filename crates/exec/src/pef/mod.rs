use crate::utils::{
    bytes_offset_match, i32_from_offset, string_from_offset, u16_from_offset, u32_from_offset,
};
use crate::{Architecture, ExecutableFile, OperatingSystem, Ordering, Section, Sections};
use types::KnownType;

use std::fmt::{Display, Formatter};

use anyhow::{bail, Context, Result};

// Documentation:
// https://web.archive.org/web/20020219190852/http://developer.apple.com/techpubs/mac/runtimehtml/RTArch-91.html#HEADING=91-0

const MAGIC: [u8; 8] = [0x4a, 0x6f, 0x79, 0x21, 0x70, 0x65, 0x66, 0x66]; // Joy!peff
const PWPC: [u8; 4] = [0x70, 0x77, 0x70, 0x63];
const M68K: [u8; 4] = [0x6d, 0x36, 0x38, 0x6b];

const HEADER_SIZE: usize = 40;
const SECTION_HEADER_SIZE: usize = 28;

pub struct Pef<'a> {
    /// Instruction set architecture for this binary
    pub arch: Architecture,

    /// Byte ordering for this binary
    pub ordering: Ordering,

    /// Operating System for this binary, likely Classic Mac OS
    pub os: OperatingSystem,

    /// Sections of this binary
    pub sections: Option<Sections>,

    /// The array containing the raw bytes used to parse this program
    pub contents: &'a [u8],
}

impl<'a> Pef<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        if !bytes_offset_match(contents, 0, &MAGIC) {
            bail!("Not a PEF file");
        }

        let arch = {
            if bytes_offset_match(contents, 8, &PWPC) {
                Architecture::PowerPC
            } else if bytes_offset_match(contents, 8, &M68K) {
                Architecture::M68k
            } else {
                Architecture::Unknown
            }
        };

        let section_count = u16_from_offset(contents, 32, Ordering::BigEndian);

        let inst_section_count = u16_from_offset(contents, 34, Ordering::BigEndian);

        let mut sections = Sections::default();
        for section_index in 0..section_count as usize + inst_section_count as usize {
            let offset_this_section = HEADER_SIZE + section_index * SECTION_HEADER_SIZE;

            let section_name_offset =
                i32_from_offset(contents, offset_this_section, Ordering::BigEndian);
            let section_name = {
                if section_name_offset > 0 {
                    string_from_offset(contents, section_name_offset as usize)
                } else {
                    format!("Unnamed section {section_index}")
                }
            };

            let offset =
                u32_from_offset(contents, offset_this_section + 24, Ordering::BigEndian) as usize;
            let size =
                u32_from_offset(contents, offset_this_section + 20, Ordering::BigEndian) as usize;

            let kind = contents[offset_this_section + 28];

            sections.0.push(Section {
                name: section_name,
                is_executable: kind == 0 || kind == 8,
                size,
                offset,
            });
        }

        Ok(Self {
            arch,
            ordering: Ordering::BigEndian,
            os: OperatingSystem::MacOS_Classic,
            sections: Some(sections),
            contents,
        })
    }
}

impl<'a> ExecutableFile for Pef<'a> {
    fn type_name(&self) -> String {
        "PEF".into()
    }

    fn architecture(&self) -> &Architecture {
        &self.arch
    }

    fn pointer_size(&self) -> usize {
        32
    }

    fn operating_system(&self) -> &OperatingSystem {
        &self.os
    }

    fn num_sections(&self) -> usize {
        if let Some(sections) = &self.sections {
            sections.0.len()
        } else {
            0
        }
    }

    fn sections(&self) -> anyhow::Result<&Sections> {
        self.sections
            .as_deref()
            .ok_or_else(|| anyhow::Error::msg("No sections"))
            .context("")
    }
}

impl<'a> KnownType for Pef<'a> {
    const MAGIC: &'static [u8] = &MAGIC;
}

impl<'a> Display for Pef<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "PEF file:")?;
        writeln!(f, "\tOS: {}", self.os)?;
        writeln!(f, "\tArchitecture: {}", self.arch)?;
        writeln!(f, "\tOrdering: {}", self.ordering)?;
        if let Some(sections) = &self.sections {
            writeln!(f, "\t{} sections:", sections.0.len())?;
            for section in sections.0.iter() {
                writeln!(f, "\t\t{}", section)?;
            }
        }
        writeln!(f, "\tSize: {}", self.contents.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rstest::rstest;

    #[test]
    fn beos() {
        const BYTES: &[u8] = include_bytes!("../../testdata/pef/BeApp");

        let pef = Pef::from(BYTES).unwrap();
        assert_eq!(pef.arch, Architecture::PowerPC);
    }

    #[rstest]
    #[case(include_bytes!("../../testdata/pef/MacOS_1"))]
    #[case(include_bytes!("../../testdata/pef/MacOS_2"))]
    fn macos(#[case] bytes: &[u8]) {
        let pef = Pef::from(bytes).unwrap();
        assert_eq!(pef.arch, Architecture::PowerPC);
    }
}
