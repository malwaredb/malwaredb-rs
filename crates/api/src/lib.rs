#[allow(unused)]
use std::time::Duration;

use chrono::serde::ts_seconds_option;
use chrono::{DateTime, Utc};
use duration_string::DurationString;
use serde::{Deserialize, Serialize};

/// MDB version
pub const MDB_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Login API endpoint, POST
pub const USER_LOGIN_URL: &str = "/v1/users/getkey";

/// User logs in with username and password
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAPIKeyRequest {
    pub user: String,
    pub password: String,
}

/// Response includes the key, if the credentials were correct,
/// and possibly show a message related to errors or warnings.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAPIKeyResponse {
    pub key: Option<String>,
    pub message: Option<String>,
}

/// User's get self information API endpoint, POST
/// User `EmptyAuthenticatingPost` to authenticate
pub const USER_INFO_URL: &str = "/v1/users/info";

/// User gets information about their account
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetUserInfoResponse {
    pub id: i32,
    pub username: String,
    pub groups: Vec<String>,
    pub sources: Vec<String>,
}

/// Server information, request is empty, GET
pub const SERVER_INFO: &str = "/v1/server/info";

/// Information about the server
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct ServerInfo {
    pub os_name: String,
    pub os_version: String,
    pub memory_used: String,
    pub mdb_version: String,
    pub db_version: String,
    pub db_size: String,
    pub num_samples: u64,
    pub num_users: u64,
    pub uptime: DurationString,
}

/// File types supported by MalwareDB, request is empty, GET
pub const SUPPORTED_FILE_TYPES: &str = "/v1/server/types";

/// One record of supported file types
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SupportedFileType {
    pub name: String,
    pub magic: Vec<String>,
    pub is_executable: bool,
    pub description: Option<String>,
}

/// All of the supported types, the response
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SupportedFileTypes {
    pub types: Vec<SupportedFileType>,
    pub message: Option<String>,
}

/// Endpoint for the sources, per-user, POST
pub const GET_SOURCES: &str = "/v1/sources/list";

/// Generic POST for authenticating with the API key
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct EmptyAuthenticatingPost {
    pub key: String,
}

/// Source record
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SourceInfo {
    pub id: u64,
    pub name: String,
    pub description: Option<String>,
    pub url: Option<String>,
    #[serde(with = "ts_seconds_option")]
    pub first_acquisition: Option<DateTime<Utc>>,
}

/// Sources response
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Sources {
    pub sources: Vec<SourceInfo>,
    pub message: Option<String>,
}

/// API endpoint for uploading a sample, POST
pub const UPLOAD_SAMPLE: &str = "/v1/samples/upload";

/// New file sample being sent to MalwareDB
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NewSample {
    /// The original file name, might not be known
    pub file_name: Option<String>,

    /// User's API key, must be validated before anything else
    pub key: String,

    /// ID of the source for this sample
    pub source_id: u64,

    /// Base64 encoding of the binary file
    pub file_contents_b64: String,

    /// SHA-256 of the sample being sent, for server-side validation
    pub sha256: String,
}
