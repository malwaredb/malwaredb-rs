use chrono::serde::ts_seconds_option;
use chrono::{DateTime, Utc};
use duration_string::DurationString;
use serde::{Deserialize, Serialize};
use std::fmt::{Display, Formatter};

/// MDB version
pub const MDB_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Login API endpoint, POST
pub const USER_LOGIN_URL: &str = "/v1/users/getkey";

/// User logs in with username and password
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAPIKeyRequest {
    pub user: String,
    pub password: String,
}

/// Logout API endpoint, POST
pub const USER_LOGOUT_URL: &str = "/v1/users/clearkey";

/// Response includes the key, if the credentials were correct,
/// and possibly show a message related to errors or warnings.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAPIKeyResponse {
    pub key: Option<String>,
    pub message: Option<String>,
}

/// User's get self information API endpoint, POST
/// User `EmptyAuthenticatingPost` to authenticate
pub const USER_INFO_URL: &str = "/v1/users/info";

/// User gets information about their account
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetUserInfoResponse {
    pub id: i32,
    pub username: String,
    pub groups: Vec<String>,
    pub sources: Vec<String>,
    pub is_admin: bool,
}

/// Server information, request is empty, GET
pub const SERVER_INFO: &str = "/v1/server/info";

/// Information about the server
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct ServerInfo {
    pub os_name: String,
    pub os_version: String,
    pub memory_used: String,
    pub mdb_version: String,
    pub db_version: String,
    pub db_size: String,
    pub num_samples: u64,
    pub num_users: u32,
    pub uptime: DurationString,
}

/// File types supported by MalwareDB, request is empty, GET
pub const SUPPORTED_FILE_TYPES: &str = "/v1/server/types";

/// One record of supported file types
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SupportedFileType {
    pub name: String,
    pub magic: Vec<String>,
    pub is_executable: bool,
    pub description: Option<String>,
}

/// All of the supported types, the response
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SupportedFileTypes {
    pub types: Vec<SupportedFileType>,
    pub message: Option<String>,
}

/// Endpoint for the sources, per-user, POST
pub const GET_SOURCES: &str = "/v1/sources/list";

/// Generic POST for authenticating with the API key
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct EmptyAuthenticatingPost {
    pub key: String,
}

/// Source record
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SourceInfo {
    pub id: u64,
    pub name: String,
    pub description: Option<String>,
    pub url: Option<String>,
    #[serde(with = "ts_seconds_option")]
    pub first_acquisition: Option<DateTime<Utc>>,
}

/// Sources response
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Sources {
    pub sources: Vec<SourceInfo>,
    pub message: Option<String>,
}

/// API endpoint for uploading a sample, POST
pub const UPLOAD_SAMPLE: &str = "/v1/samples/upload";

/// New file sample being sent to MalwareDB
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NewSample {
    /// The original file name, might not be known
    pub file_name: String,

    /// User's API key, must be validated before anything else
    pub key: String,

    /// ID of the source for this sample
    pub source_id: u32,

    /// Base64 encoding of the binary file
    pub file_contents_b64: String,

    /// SHA-256 of the sample being sent, for server-side validation
    pub sha256: String,
}

/// API endpoint for downloading a sample, POST
/// Response is raw bytes of the file, or HTTP 404 if not found
pub const DOWNLOAD_SAMPLE: &str = "/v1/samples/download";

/// The hash by which a sample is identified
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum HashType {
    Md5(String),
    SHA1(String),
    SHA256(String),
    SHA384(String),
    SHA512(String),
}

impl Display for HashType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            HashType::Md5(h) => write!(f, "MD5: {h}"),
            HashType::SHA1(h) => write!(f, "SHA-1: {h}"),
            HashType::SHA256(h) => write!(f, "SHA-256: {h}"),
            HashType::SHA384(h) => write!(f, "SHA-384: {h}"),
            HashType::SHA512(h) => write!(f, "SHA-512: {h}"),
        }
    }
}

impl HashType {
    /// Return the name of the hash type, used to decide
    /// on the database field to find the match
    pub fn name(&self) -> &'static str {
        match self {
            HashType::Md5(_) => "md5",
            HashType::SHA1(_) => "sha1",
            HashType::SHA256(_) => "sha256",
            HashType::SHA384(_) => "sha384",
            HashType::SHA512(_) => "sha512",
        }
    }

    /// Unwrap the hash from the enum's types
    pub fn the_hash(&self) -> &String {
        match self {
            HashType::Md5(h)
            | HashType::SHA1(h)
            | HashType::SHA256(h)
            | HashType::SHA384(h)
            | HashType::SHA512(h) => h,
        }
    }
}

impl TryFrom<String> for HashType {
    type Error = &'static str;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        Ok(match value.len() {
            32 => HashType::Md5(value),
            40 => HashType::SHA1(value),
            64 => HashType::SHA256(value),
            96 => HashType::SHA384(value),
            128 => HashType::SHA512(value),
            _ => return Err("unknown hash size"),
        })
    }
}

/// Requesting a sample from MalwareDB
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DownloadSampleRequest {
    /// User's API key, must be validated before anything else
    pub key: String,

    /// The hash of the requested sample
    pub hash: HashType,
}

/// API endpoint for finding samples which are similar to specific file, POST
pub const SIMILAR_SAMPLES: &str = "/v1/samples/similar";

/// The hash by which a sample is identified
#[derive(Clone, Copy, Debug, Eq, PartialEq, Deserialize, Serialize)]
#[non_exhaustive]
pub enum SimilarityHashType {
    SSDeep,
    SDHash,
    LZJD,
    TLSH,
    PEHash,
    ImportHash,
    FuzzyImportHash,
}

impl SimilarityHashType {
    /// For a similarity hash type, return:
    /// * The database table & field which stores the hash
    /// * If applicable, the similarity hash function (Postgres extension) which calculates the similarity
    pub fn get_table_field_simfunc(&self) -> (&'static str, Option<&'static str>) {
        match self {
            SimilarityHashType::SSDeep => ("file.ssdeep", Some("fuzzy_hash_compare")),
            SimilarityHashType::SDHash => ("file.sdhash", Some("sdhash_compare")),
            SimilarityHashType::LZJD => ("file.lzjd", Some("lzjd_compare")),
            SimilarityHashType::TLSH => ("file.tlsh", Some("tlsh_compare")),
            SimilarityHashType::PEHash => ("executable.pehash", None),
            SimilarityHashType::ImportHash => ("executable.importhash", None),
            SimilarityHashType::FuzzyImportHash => {
                ("executable.importhashfuzzy", Some("fuzzy_hash_compare"))
            }
        }
    }
}
/*
impl TryFrom<String> for SimilarityHashType {
    type Error = &'static str;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        let lower = value.to_ascii_lowercase();

        if lower == "lzjd" {
            return Ok(SimilarityHashType::LZJD);
        }
        if lower == "ssdeep" {
            return Ok(SimilarityHashType::SSDeep);
        }
        if lower == "sdhash" {
            return Ok(SimilarityHashType::SDHash);
        }
        if lower == "tlsh" {
            return Ok(SimilarityHashType::TLSH);
        }
        if lower == "pehash" {
            return Ok(SimilarityHashType::PEHash);
        }
        if lower == "importhash" {
            return Ok(SimilarityHashType::ImportHash);
        }
        if lower == "importhashfuzzy" {
            return Ok(SimilarityHashType::FuzzyImportHash);
        }

        Err("known similarity hash type")
    }
}*/

impl Display for SimilarityHashType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SimilarityHashType::SSDeep => write!(f, "SSDeep"),
            SimilarityHashType::SDHash => write!(f, "SDHash"),
            SimilarityHashType::LZJD => write!(f, "LZJD"),
            SimilarityHashType::TLSH => write!(f, "TLSH"),
            SimilarityHashType::PEHash => write!(f, "PeHash"),
            SimilarityHashType::ImportHash => write!(f, "Import Hash (IMPHASH)"),
            SimilarityHashType::FuzzyImportHash => write!(f, "Fuzzy Import hash"),
        }
    }
}

/// Requesting a sample from MalwareDB
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SimilarSamplesRequest {
    /// User's API key, must be validated before anything else
    pub key: String,

    /// The hash of the requested sample
    pub hash: Vec<(SimilarityHashType, String)>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SimilarSample {
    /// The SHA-256 hash of the found sample
    pub sha256: String,

    /// Matches from the requested sample to this sample by algorithm and score
    pub algorithms: Vec<(SimilarityHashType, f32)>,
}

/// Response indicating samples which are similar
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SimilarSamplesResponse {
    /// The responses
    pub results: Vec<SimilarSample>,

    /// Possible messages from the server, if any
    pub message: Option<String>,
}
