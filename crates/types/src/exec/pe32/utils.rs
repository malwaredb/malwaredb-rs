use crate::utils::{u16_from_offset, u32_from_offset, u64_from_offset};
use crate::Ordering;

/// Convenience function for optional [u16] from a byte sequence with [endian] ordering.
#[inline]
pub fn u16_or_none_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> Option<u16> {
    if offset > contents.len() || offset + 2 > contents.len() {
        return None;
    }
    Some(u16_from_offset(contents, offset, endian))
}

/// Convenience function for optional [u32] from a byte sequence with [endian] ordering.
#[inline]
pub fn u32_or_none_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> Option<u32> {
    if offset > contents.len() || offset + 4 > contents.len() {
        return None;
    }
    Some(u32_from_offset(contents, offset, endian))
}

/// Convenience function for optional [u64] from a byte sequence with [endian] ordering.
#[inline]
pub fn u64_or_none_from_offset(contents: &[u8], offset: usize, endian: Ordering) -> Option<u64> {
    if offset > contents.len() || offset + 8 > contents.len() {
        return None;
    }
    Some(u64_from_offset(contents, offset, endian))
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn u16_none() {
        const BYTES: [u8; 1] = [0x00];

        assert!(u16_or_none_from_offset(&BYTES, 0, Ordering::LittleEndian).is_none());
    }
}
