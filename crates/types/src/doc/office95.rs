use crate::TypeMagic;
use std::fmt::{Display, Formatter};

use anyhow::Result;

const DOCFILE_MAGIC: [u8; 8] = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];

// http://fileformats.archiveteam.org/wiki/Microsoft_Compound_File
/// UUID file type, of which only a subset is of interest
/// This is how we can filter out container formats, like .msi (installer) files.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ClsidType {
    Excel,
    PowerPoint,
    Word,
    Unknown,
}

impl ClsidType {
    pub fn from(bytes: &[u8; 16]) -> Self {
        if bytes.ends_with(&[0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46]) {
            if bytes.starts_with(&[0x00, 0x02, 0x08, 0x10])
                || bytes.starts_with(&[0x10, 0x08, 0x02, 0x00])
                || bytes.starts_with(&[0x00, 0x02, 0x08, 0x20])
                || bytes.starts_with(&[0x20, 0x08, 0x02, 0x00])
            {
                return Self::Excel;
            }

            if bytes.starts_with(&[0x00, 0x02, 0x09, 0x00])
                || bytes.starts_with(&[0x00, 0x09, 0x02, 0x00])
                || bytes.starts_with(&[0x00, 0x02, 0x09, 0x06])
                || bytes.starts_with(&[0x06, 0x09, 0x02, 0x00])
            {
                return Self::Word;
            }
        }

        Self::Unknown
    }
}

impl Display for ClsidType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            ClsidType::Excel => write!(f, "Excel"),
            ClsidType::PowerPoint => write!(f, "PowerPoint"),
            ClsidType::Word => write!(f, "Word"),
            ClsidType::Unknown => write!(f, "Unknown/other"),
        }
    }
}

/// A struct representing the older Microsoft Office format, Office95, aka Docfile.
///
/// This format is really a container format, and could be used to hold a non-Office files,
/// such as installers (.msi files), Windows update files, and others. Here we are only concerned
/// with MS Office types.
#[derive(Clone, Debug)]
pub struct Office95<'a> {
    /// Sub-type for the file
    pub clsid: ClsidType,

    /// The array containing the raw bytes used to parse this document
    pub contents: &'a [u8],
}

impl<'a> Office95<'a> {
    pub fn from(contents: &'a [u8]) -> Result<Self> {
        let offset: [u8; 4] = contents[48..52].try_into().unwrap();
        let offset_int = u32::from_le_bytes(offset);
        let offset_int = (512 * (1 + offset_int) + 80) as usize;
        let clsid: [u8; 16] = contents[offset_int..offset_int + 16].try_into().unwrap();

        Ok(Self {
            clsid: ClsidType::from(&clsid),
            contents,
        })
    }
}

impl<'a> TypeMagic for Office95<'a> {
    const MAGIC: &'static [&'static [u8]] = &[&DOCFILE_MAGIC];
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn word() {
        const BYTES: &[u8] = include_bytes!("../../testdata/office95/word.doc");
        let office = Office95::from(BYTES).unwrap();
        assert_eq!(office.clsid, ClsidType::Word);
    }
}
