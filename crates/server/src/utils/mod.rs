use sha2::digest::Output;
use sha2::Sha256VarCore;
use std::path::PathBuf;

/// Create a relative path from a hash with a given depth, such that for the given depth,
/// those beginning values of the hash are sub-directories.
trait HashPath {
    /// Get the path object from the hash with the requested sub-directory depth
    fn hashed_path(&self, depth: usize) -> PathBuf;
}

// `Sha256VarCore` needs to be replaced with a generic to work with any hash type
impl HashPath for Output<Sha256VarCore> {
    fn hashed_path(&self, depth: usize) -> PathBuf {
        let mut path = PathBuf::new();
        for (index, value) in self.iter().enumerate() {
            path.push(format!("{value:02x}"));
            if index >= depth - 1 {
                break;
            }
        }
        path.push(hex::encode(self));
        path
    }
}

#[cfg(test)]
mod test {
    use super::HashPath;
    use sha2::{Digest, Sha256};

    #[test]
    fn test_sha256_path() {
        let mut hasher = Sha256::new();
        hasher.update(b"hello world pretend this is a file!");

        let result = hasher.finalize();
        assert_eq!(
            "12/77/1277be37873848472bcd3b58f76e70d4b01bf792b3e1bb8022f410d40804ab7e",
            result.hashed_path(2).to_str().unwrap()
        );
        assert_eq!(
            "12/77/be/1277be37873848472bcd3b58f76e70d4b01bf792b3e1bb8022f410d40804ab7e",
            result.hashed_path(3).to_str().unwrap()
        );
    }
}
