use crate::db::types::FileMetadata;
use crate::State;
use malwaredb_types::KnownType;

use std::sync::Arc;

use anyhow::{bail, Result};
use tracing::{error, trace};

pub async fn incoming_sample(
    state: Arc<State>,
    data: Vec<u8>,
    uid: i32,
    sid: i32,
    file_name: String,
) -> Result<()> {
    let known_type = match KnownType::new(&data) {
        Ok(t) => t,
        Err(e) => {
            error!("Error determining type: {e}");
            return Err(e);
        }
    };

    let meta_data = FileMetadata::new(&data, &file_name);

    let db_file_types = match state.db_type.get_known_data_types().await {
        Ok(t) => t,
        Err(e) => {
            error!("Error getting known types: {e}");
            return Err(e);
        }
    };

    let db_file_type = {
        let mut id = None;
        for db_file_type in db_file_types {
            for magic in db_file_type.magic {
                if data.starts_with(&magic) {
                    id = Some(db_file_type.id);
                }
            }
        }
        id
    };

    if db_file_type.is_none() {
        error!("db_file_type is None");
        bail!("file type unknown");
    }

    let db_file_type = db_file_type.unwrap();

    match state
        .db_type
        .add_file(&meta_data, known_type, uid, sid, db_file_type)
        .await
    {
        Ok(_) => {
            trace!("Storing sample!");
            if let Err(e) = state.store_bytes(&data) {
                error!("Error storing sample: {e}");
                Err(e)
            } else {
                Ok(())
            }
        }
        Err(e) => {
            error!("Error storing bytes: {e}");
            Err(e)
        }
    }
}
