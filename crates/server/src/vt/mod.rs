use crate::State;
use std::fmt::{Display, Formatter};

use std::process::ExitCode;
use std::time::Duration;

use anyhow::{Context, Result};
use malwaredb_virustotal::{filereport::FileReportData, VirusTotalClient};
use tracing::{debug, info};

/// Logic for getting records from the database and querying VirusTotal for AV hits
#[allow(dead_code)]
pub struct VtUpdater {
    inner: VirusTotalClient,

    /// Database handle and configuration for MalwareDB
    state: State,

    /// If we're allowed to upload samples to VirusTotal
    pub send_samples: bool,
}

impl VtUpdater {
    /// Fetch updates for all samples
    pub async fn updater(&self) -> Result<ExitCode> {
        // TODO: Figure out how to paginate over results
        // Don't paginate now since we don't have a mechanism to know when a file isn't in
        // VT, so we'll have an infinite loop.
        let hashes = self
            .state
            .db_type
            .files_without_vt_records(1000)
            .await
            .context("Failed to retrieve hashes for querying VT")?;

        for hash in hashes {
            match self.inner.get_report(&hash).await {
                Ok(result) => {
                    self.state
                        .db_type
                        .store_vt_record(&result.attributes)
                        .await
                        .context("Failed to store VT data")?;
                }
                Err(error) => {
                    if self.send_samples
                        && self.state.directory.is_some()
                        && error == *malwaredb_virustotal::errors::NOT_FOUND_ERROR
                    {
                        if let Ok(bytes) = self.state.retrieve_bytes(&hash).await {
                            match self.inner.submit(bytes, None).await {
                                Ok(_) => {
                                    info!("Sample {hash} uploaded to VT successfully.");
                                }
                                Err(e) => debug!("Error uploading unknown sample to VT: {e}"),
                            }
                        }
                    } else {
                        debug!("Error getting report for {hash}: {error}")
                    }
                }
            }

            tokio::time::sleep(Duration::from_secs(2)).await; // Don't overload VT
        }

        Ok(ExitCode::SUCCESS)
    }

    /// Add a serialized VT report to the database
    pub async fn loader(&self, report: &FileReportData) -> Result<()> {
        self.state
            .db_type
            .store_vt_record(&report.attributes)
            .await
            .context("Failed to store VT data")
    }
}

#[derive(Debug, Copy, Clone, Default)]
pub struct VtKeyMissingError;

impl Display for VtKeyMissingError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "No VT API Key")
    }
}

impl std::error::Error for VtKeyMissingError {}

/// Get a VtUpdater object if we have the VT API key
impl TryFrom<State> for VtUpdater {
    type Error = VtKeyMissingError;

    fn try_from(state: State) -> std::result::Result<Self, Self::Error> {
        let send_samples = state.db_config.send_samples_to_vt;
        if let Some(key) = &state.vt_api_key {
            Ok(VtUpdater {
                inner: VirusTotalClient::new(key),
                state,
                send_samples,
            })
        } else {
            Err(VtKeyMissingError)
        }
    }
}
