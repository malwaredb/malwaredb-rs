use crate::utils::EntropyCalc;

use lzjd::{LZDict, Murmur3HashState};
use md5::Md5;
use sha1::Sha1;
use sha2::{Digest, Sha256, Sha512};

pub struct FileMetadata {
    pub size: u32,
    pub entropy: f32,
    pub sha1: String,
    pub sha256: String,
    pub sha512: String,
    pub md5: String,
    pub lzjd: Option<String>,
    pub ssdeep: Option<String>,
    pub sdhash: Option<String>,
    pub tlsh: Option<String>,
}

impl FileMetadata {
    pub fn new(contents: &Vec<u8>) -> Self {
        let mut sha1 = Sha1::new();
        sha1.update(contents);
        let sha1 = sha1.finalize();

        let mut sha256 = Sha256::new();
        sha256.update(contents);
        let sha256 = sha256.finalize();

        let mut sha512 = Sha512::new();
        sha512.update(contents);
        let sha512 = sha512.finalize();

        let mut md5 = Md5::new();
        md5.update(contents);
        let md5 = md5.finalize();

        let build_hasher = Murmur3HashState::new();
        let lzjd_str =
            LZDict::from_bytes_stream(contents.iter().copied(), &build_hasher).to_string();

        Self {
            size: contents.len() as u32,
            entropy: contents.entropy(),
            sha1: hex::encode(sha1),
            sha256: hex::encode(sha256),
            sha512: hex::encode(sha512),
            md5: hex::encode(md5),
            lzjd: Some(lzjd_str),
            ssdeep: ssdeep::hash(contents),
            sdhash: None,
            tlsh: None,
        }
    }
}
