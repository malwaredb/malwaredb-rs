use super::{hash_password, random_bytes_api_key, DatabaseConnection};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use postgres::{Client, NoTls};

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

pub struct Postgres {
    client: Client,
    connection_string: String,
}

impl Postgres {
    pub fn new(connection_string: &str) -> Result<Self> {
        let mut client = Client::connect(connection_string, NoTls)?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )?
            .get(0)
        {
            let exists: bool = row.get(0);
            if !exists {
                println!("Tables don't seem to exists, creating.");
                client
                    .batch_execute(PG_SQL)
                    .context("failed to create postgres tables")?;
                println!("Tables created.");
            } else {
                println!("Tables already present.");
            }
        } else {
            bail!("Failed to query postgres for file table existence");
        }

        Ok(Self {
            client,
            connection_string: connection_string.to_string(),
        })
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl DatabaseConnection for Postgres {
    fn authenticate(&mut self, uname: &str, password: &str) -> Result<String> {
        let result = self
            .client
            .query("select password from person where uname = $1", &[&uname])?;

        if result.is_empty() {
            bail!("Unauthorized");
        } else if result.len() > 1 {
            eprintln!("Failure: more than one result for API key for username {uname}.");
            bail!("System error");
        }

        for row in result {
            let db_password: Option<String> = row.get(0);
            if let Some(db_password) = db_password {
                let password_hashed = PasswordHash::new(&db_password)?;
                Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            } else {
                bail!("Password not set");
            }
        }

        let result = self
            .client
            .query("select apikey from person where uname = $1", &[&uname])?;

        for row in result {
            let apikey: Option<String> = row.get(0);
            if let Some(apikey) = apikey {
                return Ok(apikey);
            }
        }

        let apikey = random_bytes_api_key();
        self.client.execute(
            "update person set apikey = $1 where uname = $2",
            &[&apikey, &uname],
        )?;

        Ok(apikey)
    }

    fn create_user(
        &mut self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let result = self
            .client
            .query_one("select count(1) from person where uname = $1", &[&uname])?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("username already taken");
        }

        let result = self
            .client
            .query_one("select count(1) from person where email = $1", &[&email])?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("email address already taken");
        }

        match password {
            Some(password) => {
                let password = hash_password(&password)?;
                self.client.execute("insert into person(email, uname, firstname, lastname, organisation, password) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation, &password])?;
            }
            None => {
                self.client.execute("insert into person(email, uname, firstname, lastname, organisation) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation])?;
            }
        }

        let result = self
            .client
            .query("select id::bigint from person where uname = $1", &[&uname])?;

        for row in result {
            let uid: i64 = row.get(0);
            return Ok(uid as u64);
        }

        bail!("User not created")
    }

    fn reset_api_keys(&mut self) -> Result<u64> {
        let reset = self
            .client
            .execute("update person set apikey = NULL", &[])?;
        Ok(reset)
    }

    fn change_password(&mut self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(&password)?;
        self.client.execute(
            "update person set password = $1 where uname = $2",
            &[&uname, &password],
        )?;
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::*;
    const CONNECTION_STRING: &str =
        "user=malwaredbtesting password=malwaredbtesting dbname=malwaredbtesting host=localhost";

    fn delete() {
        let mut client = Client::connect(CONNECTION_STRING, NoTls).unwrap();
        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).unwrap();
                client.execute("drop table vtclean", &[]).unwrap();
                client.execute("drop table vthits", &[]).unwrap();
                client.execute("drop table filetype", &[]).unwrap();
                client.execute("drop table executable", &[]).unwrap();
                client.execute("drop table pdf", &[]).unwrap();
                client.execute("drop table filesource", &[]).unwrap();
                client.execute("drop table filelabel", &[]).unwrap();
                client.execute("drop table sourcelabel", &[]).unwrap();
                client.execute("drop table file", &[]).unwrap();
                client.execute("drop table label", &[]).unwrap();
                client.execute("drop table mdbconfig", &[]).unwrap();
                client.execute("drop table source", &[]).unwrap();
                client.execute("drop table usergroup", &[]).unwrap();
                client.execute("drop table person", &[]).unwrap();
                client.execute("drop table grp", &[]).unwrap();
            }
        }
        client.close().unwrap();
    }

    #[test]
    #[ignore]
    fn everything() {
        delete();

        let mut psql = Postgres::new(CONNECTION_STRING).unwrap();

        let admin_password = "super_secure_password_dont_tell_anyone!";
        let admin_password_hashed = hash_password(admin_password)
            .context("failed to hash password")
            .unwrap();

        psql.client
            .execute(
                "update person set password = $1 where id = 0",
                &[(&admin_password_hashed)],
            )
            .context("failed to set admin password")
            .unwrap();

        let admin_api_key = psql
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {admin_api_key}");

        let admin_api_key_again = psql
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = psql.authenticate("admin", &bad_password);
        assert!(bad_api_key_request.is_err());

        assert_eq!(
            admin_api_key, admin_api_key_again,
            "API keys didn't match the second time."
        );

        let new_user_uname = "testuser";
        let new_user_email = "test@example.com";
        let new_user_password = "some_awesome_password_++";
        let new_id = psql
            .create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .unwrap();

        assert!(
            new_id > 0,
            "Weird UID created for user {}: {}",
            new_user_uname,
            new_id
        );

        assert!(
            psql.create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .is_err(),
            "Creating a new user with the same user name should fail"
        );

        let new_user_password_change = "some_new_awesomer_password!_++";
        psql.change_password(new_user_uname, new_user_password_change)
            .context("failed to change the password for testuser")
            .unwrap();

        let new_user_api_key = psql
            .authenticate(new_user_uname, &new_user_password)
            .context("unable to get api key for testuser")
            .unwrap();
        eprintln!("{new_user_uname} got API key {new_user_api_key}");

        assert_eq!(admin_api_key.len(), new_user_api_key.len());

        let reset = psql
            .reset_api_keys()
            .context("failed to reset all API keys")
            .unwrap();
        eprintln!("Cleared {reset} api keys.");

        delete();
    }
}
