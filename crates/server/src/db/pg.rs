#[cfg(any(test, feature = "admin"))]
use super::{admin, hash_password};
use super::{random_bytes_api_key, DatabaseInformation, MDBConfig};
use crate::crypto::{EncryptionOption, FileEncryption};
use crate::db::types::{FileMetadata, FileType};
use malwaredb_api::{
    digest::HashType, GetUserInfoResponse, Label, Labels, SimilarSample, SimilarityHashType,
};
use malwaredb_types::KnownType;

use std::collections::HashMap;
use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
#[cfg(any(test, feature = "admin"))]
use chrono::Local;
use deadpool_postgres::tokio_postgres::{Config, NoTls};
use deadpool_postgres::{GenericClient, Manager, ManagerConfig, Pool, RecyclingMethod};
use humansize::{make_format, DECIMAL};
#[cfg(feature = "vt")]
use malwaredb_virustotal::filereport::ScanResultAttributes;
use tracing::error;

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

struct WhichHashesInstalled {
    pub lzjd: bool,
    pub tlsh: bool,
    pub sdhash: bool,
    pub ssdeep: bool,
}

impl WhichHashesInstalled {
    pub fn all_installed(&self) -> bool {
        self.lzjd && self.sdhash && self.ssdeep && self.tlsh
    }
}

impl Display for WhichHashesInstalled {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if self.all_installed() {
            write!(f, "all similarity hashing extensions are installed")
        } else if !self.lzjd && !self.sdhash && !self.ssdeep && !self.tlsh {
            write!(f, "no similarity hashing extensions are installed")
        } else {
            if self.lzjd {
                write!(f, "lzjd ")?;
            }

            if self.sdhash {
                write!(f, "sdhash ")?;
            }

            if self.ssdeep {
                write!(f, "ssdeep ")?;
            }

            if self.tlsh {
                write!(f, "tlsh ")?;
            }

            write!(f, "installed")
        }
    }
}

/// Handle to a Postgres database server
pub struct Postgres {
    /// Connection handle to the Postgres server
    pool: Pool,

    /// Whether or not the similarity hash extensions are installed
    has_hash_extensions: bool,

    /// First run of MalwareDB (did we just create the database?)
    first_run: bool,
}

impl Postgres {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let mgr_config = ManagerConfig {
            recycling_method: RecyclingMethod::Fast,
        };

        let pg_config = connection_string.parse::<Config>()?;
        let mgr = Manager::from_config(pg_config, NoTls, mgr_config);
        let pool = Pool::builder(mgr).max_size(16).build()?;

        let client = pool.get().await?;

        let first_run = if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await?
            .first()
        {
            let exists: bool = row.get(0);
            if !exists {
                client
                    .batch_execute(PG_SQL)
                    .await
                    .context("failed to create postgres tables")?;
                client
                    .execute("update mdbconfig set version = $1", &[&crate::MDB_VERSION])
                    .await?;
            }
            !exists
        } else {
            bail!("Failed to query postgres for file table existence");
        };

        let pgclient = Self {
            pool,
            has_hash_extensions: false,
            first_run,
        };
        let has_hash_extensions = pgclient.check_similarity_functions().await?.all_installed();

        Ok(Self {
            pool: pgclient.pool,
            has_hash_extensions,
            first_run,
        })
    }

    #[cfg(test)]
    pub(crate) async fn delete_init(&self) -> Result<()> {
        let client = self.pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await
            .unwrap()
            .first()
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).await.unwrap();
                client.execute("drop table vtclean", &[]).await.unwrap();
                client.execute("drop table vthits", &[]).await.unwrap();
                client.execute("drop table filetype", &[]).await.unwrap();
                client.execute("drop table executable", &[]).await.unwrap();
                client.execute("drop table pdf", &[]).await.unwrap();
                client.execute("drop table filesource", &[]).await.unwrap();
                client.execute("drop table filelabel", &[]).await.unwrap();
                client.execute("drop table sourcelabel", &[]).await.unwrap();
                client.execute("drop table file", &[]).await.unwrap();
                client.execute("drop table label", &[]).await.unwrap();
                client.execute("drop table mdbconfig", &[]).await.unwrap();
                client
                    .execute("drop table encryptionkey", &[])
                    .await
                    .unwrap();
                client.execute("drop table groupsource", &[]).await.unwrap();
                client.execute("drop table source", &[]).await.unwrap();
                client.execute("drop table usergroup", &[]).await.unwrap();
                client.execute("drop table person", &[]).await.unwrap();
                client.execute("drop table grp", &[]).await.unwrap();
            }
        }

        client
            .batch_execute(PG_SQL)
            .await
            .context("failed to create postgres tables")?;

        Ok(())
    }

    pub fn first_run(&self) -> bool {
        self.first_run
    }

    pub async fn enable_compression(&self) -> Result<()> {
        if self.first_run {
            let client = self.pool.get().await?;
            client
                .execute("update mdbconfig set compress = true", &[])
                .await?;
        } else {
            bail!("refusing to set compression when not on the first run");
        }
        Ok(())
    }

    #[cfg(feature = "vt")]
    pub async fn enable_vt_upload(&self) -> Result<()> {
        if self.first_run {
            let client = self.pool.get().await?;
            client
                .execute("update mdbconfig set send_samples_to_vt = true", &[])
                .await?;
        } else {
            bail!("refusing to set allow of sample uploading to VT when not on the first run");
        }
        Ok(())
    }

    #[cfg(feature = "vt")]
    pub async fn files_without_vt_records(&self, limit: i32) -> Result<Vec<String>> {
        let client = self.pool.get().await?;
        let limit = limit as i64; // Postgres is picky about integers

        let results = client
            .query("select file.sha256 from file where file.id not in (select fileid from vthits) and file.id not in (select fileid from vtclean) limit $1", &[&limit])
            .await?;

        Ok(results
            .iter()
            .map(|r| {
                let h: String = r.get(0);
                h
            })
            .collect())
    }

    #[cfg(feature = "vt")]
    pub async fn store_vt_record(&self, results: &ScanResultAttributes) -> Result<()> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select id from file where sha256 = $1", &[&results.sha256])
            .await?;
        let id: i64 = result.get(0);

        if results.last_analysis_results.is_empty() {
            client
                .execute(
                    "insert into vtclean(fileid, tstamp) values($1, $2)",
                    &[&id, &results.last_analysis_date],
                )
                .await
                .unwrap();
        } else {
            // TODO: There has to be a better way than two conversions
            let report = serde_json::to_string(&results.last_analysis_results)?;
            let report = serde_json::Value::from(report);
            let hits = results.last_analysis_stats.malicious as i32;
            let total = results.last_analysis_stats.av_count() as i32;
            client
                .execute(
                    "insert into vthits(fileid, tstamp, hits, total, vtdetail) values($1, $2, $3, $4, $5)",
                    &[&id, &results.last_analysis_date, &hits, &total, &report],
                )
                .await
                .unwrap();
        }

        Ok(())
    }

    #[cfg(feature = "vt")]
    pub async fn get_vt_stats(&self) -> Result<super::VtStats> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select count(1) from vtclean", &[])
            .await?;
        let clean_records: i64 = result.get(0);

        let result = client.query_one("select count(1) from vthits", &[]).await?;
        let hits_records: i64 = result.get(0);

        let result = client.query_one("select count(1) from file where file.id not in (select fileid from vthits) and file.id not in (select fileid from vtclean)", &[]).await?;
        let files_without_records: i64 = result.get(0);

        Ok(super::VtStats {
            clean_records: clean_records as u32,
            hits_records: hits_records as u32,
            files_without_records: files_without_records as u32,
        })
    }

    pub async fn get_config(&self) -> Result<MDBConfig> {
        let client = self.pool.get().await?;
        let result = client
            .query_one(
                "select name, compress, send_samples_to_vt, defaultKey from mdbconfig",
                &[],
            )
            .await?;

        let default_key: Option<i32> = result.get(3);

        Ok(MDBConfig {
            name: result.get(0),
            compression: result.get(1),
            send_samples_to_vt: result.get(2),
            default_key: default_key.map(|id| id as u32),
        })
    }

    pub async fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select password from person where uname = $1", &[&uname])
            .await?;

        let db_password: Option<String> = result.get(0);
        if let Some(db_password) = db_password {
            let password_hashed = PasswordHash::new(&db_password)?;
            Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
        } else {
            bail!("Password not set");
        }

        let row = client
            .query_one("select apikey from person where uname = $1", &[&uname])
            .await?;

        let apikey: Option<String> = row.get(0);
        if let Some(apikey) = apikey {
            return Ok(apikey);
        }

        let apikey = random_bytes_api_key();
        client
            .execute(
                "update person set apikey = $1 where uname = $2",
                &[&apikey, &uname],
            )
            .await?;

        Ok(apikey)
    }

    pub async fn get_uid(&self, apikey: &str) -> Result<i32> {
        let client = self.pool.get().await?;
        let result = client
            .query_one("SELECT id from person where apikey = $1", &[&apikey])
            .await?;
        let uid: i32 = result.get(0);
        Ok(uid)
    }

    pub async fn db_info(&self) -> Result<DatabaseInformation> {
        let client = self.pool.get().await?;

        let result = client
            .query_one(
                "SELECT pg_size_pretty(pg_database_size(current_database()))",
                &[],
            )
            .await?;
        let size: String = result.get(0);

        let result = client.query_one("SELECT version();", &[]).await?;
        let version: String = result.get(0);
        let extensions = self.check_similarity_functions().await?;

        let result = client.query_one("SELECT count(1) from person", &[]).await?;
        let num_users: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from file", &[]).await?;
        let num_files: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from grp", &[]).await?;
        let num_groups: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from source", &[]).await?;
        let num_sources: i64 = result.get(0);

        Ok(DatabaseInformation {
            version: format!("{version}, {extensions}"),
            size,
            num_files: num_files as u64,
            num_users: num_users as u32,
            num_groups: num_groups as u32,
            num_sources: num_sources as u32,
        })
    }

    pub async fn get_user_info(&self, uid: i32) -> Result<GetUserInfoResponse> {
        let client = self.pool.get().await?;

        let results = client
            .query_one("select uname from person where id = $1", &[&uid])
            .await?;

        let username = results.get(0);

        let results = client.query("select grp.name, grp.id, grp.parent from grp, usergroup where grp.id = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut groups = vec![];
        let mut is_admin = false;
        for result in results {
            groups.push(result.get(0));
            let gid: i32 = result.get(1);
            let g_pid: Option<i32> = result.get(2);
            if gid == 0 {
                is_admin = true;
            }
            if let Some(parent_id) = g_pid {
                if parent_id == 0 {
                    is_admin = true;
                }
            }
        }

        let results = client.query("select source.name from source, usergroup, groupsource where source.id = groupsource.sourceid and groupsource.gid = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut sources = vec![];
        for result in results {
            sources.push(result.get(0));
        }

        Ok(GetUserInfoResponse {
            id: uid,
            username,
            groups,
            sources,
            is_admin,
        })
    }

    pub async fn reset_own_api_key(&self, uid: i32) -> Result<()> {
        let client = self.pool.get().await?;
        client
            .execute("update person set apikey = NULL where id = $1", &[&uid])
            .await?;
        Ok(())
    }

    pub async fn get_known_data_types(&self) -> Result<Vec<FileType>> {
        let client = self.pool.get().await?;

        let results = client
            .query(
                "select id, name, description, magic, executable from filetype",
                &[],
            )
            .await?;
        let mut file_types = vec![];

        for result in results {
            file_types.push(FileType {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                magic: result.get(3),
                executable: result.get(4),
            });
        }

        Ok(file_types)
    }

    pub async fn get_labels(&self) -> Result<Labels> {
        let client = self.pool.get().await?;

        let results = client.query("select label.id, label.name, parent.name from label left outer join label parent on (parent.id = label.parent)", &[]).await?;

        let mut labels = Vec::new();
        for result in results {
            let id: i64 = result.get(0);
            labels.push(Label {
                id: id as u64,
                name: result.get(1),
                parent: result.get(2),
            });
        }

        Ok(Labels(labels))
    }

    pub async fn get_type_id_for_bytes(&self, data: &[u8]) -> Result<i32> {
        let db_file_types = match self.get_known_data_types().await {
            Ok(t) => t,
            Err(e) => {
                return Err(e);
            }
        };

        for db_file_type in db_file_types {
            for magic in db_file_type.magic {
                if data.starts_with(&magic) {
                    return Ok(db_file_type.id);
                }
            }
        }

        bail!("File type not found")
    }

    pub async fn allowed_user_source(&self, uid: i32, sid: i32) -> Result<bool> {
        let client = self.pool.get().await?;
        let results = client
            .query(
                "select usergroup.gid from usergroup, groupsource where usergroup.gid = groupsource.gid and usergroup.pid = $1 and groupsource.sourceid = $2",
                &[&uid, &sid],
            )
            .await?;

        Ok(!results.is_empty())
    }

    pub async fn user_is_admin(&self, uid: i32) -> Result<bool> {
        let client = self.pool.get().await?;
        let results = client
            .query(
                "select usergroup.gid from usergroup join grp on (usergroup.gid = grp.id) where usergroup.pid = $1 and (usergroup.gid = 0 or grp.parent = 0)",
                &[&uid],
            )
            .await?;

        Ok(!results.is_empty())
    }

    pub async fn add_file(
        &self,
        meta: &FileMetadata,
        known_type: KnownType<'_>,
        uid: i32,
        sid: i32,
        ftype: i32,
        parent: Option<i64>,
    ) -> Result<bool> {
        if !self.allowed_user_source(uid, sid).await? {
            bail!("uid {uid} not allowed to upload to sid {sid}");
        }

        let mut client = self.pool.get().await?;
        let mut transaction = client.transaction().await?;
        let known_type_clone = known_type.clone();

        let (fid, new_file) = match self
            .add_file_transaction(meta, known_type, uid, sid, ftype, parent, &mut transaction)
            .await
        {
            Ok(result) => result,
            Err(e) => {
                error!("Postgres: Insertion for parent file failed {e}, aborting transaction");
                transaction.rollback().await?;
                return Err(e);
            }
        };

        if new_file {
            if let Some(children) = known_type_clone.children() {
                for child in children {
                    let child_meta = FileMetadata::new(child.contents(), None);
                    if let Ok(type_id) = self.get_type_id_for_bytes(child.contents()).await {
                        if let Err(e) = self
                            .add_file_transaction(
                                &child_meta,
                                child,
                                uid,
                                sid,
                                type_id,
                                Some(fid),
                                &mut transaction,
                            )
                            .await
                        {
                            error!("Postgres: failed to insert record for child file: {e}");
                            transaction.rollback().await?;
                            return Err(e);
                        }
                    }
                }
            }
        }

        transaction.commit().await?;

        Ok(new_file)
    }

    #[allow(clippy::too_many_arguments)]
    async fn add_file_transaction(
        &self,
        meta: &FileMetadata,
        known_type: KnownType<'_>,
        uid: i32,
        sid: i32,
        ftype: i32,
        parent: Option<i64>,
        transaction: &mut deadpool_postgres::Transaction<'_>,
    ) -> Result<(i64, bool)> {
        let result = transaction
            .query("select id from file where sha512 = $1", &[&meta.sha512])
            .await?;

        let (fid, new_file) = if !result.is_empty() {
            if result.len() != 1 {
                eprintln!(
                    "Postgres: data integrity failure, {} entries for {}",
                    result.len(),
                    meta.sha512
                );
                bail!(
                    "Postgres: data integrity failure, {} entries for {}",
                    result.len(),
                    meta.sha512
                );
            }

            // We know now that one record was returned by the database.
            let fid: i64 = result.first().unwrap().get(0);
            (fid, false)
        } else {
            let size = meta.size as i32;
            let creation_date = known_type.created();

            transaction.execute("insert into file(sha1, sha256, sha384, sha512, md5, lzjd, ssdeep, sdhash, tlsh, humanhash, filecommand, createddate, filetypeid, size, entropy)\
            values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)", &[&meta.sha1, &meta.sha256, &meta.sha384, &meta.sha512, &meta.md5, &meta.lzjd, &meta.ssdeep, &meta.sdhash, &meta.tlsh, &meta.humanhash, &meta.file_command, &creation_date, &ftype, &size, &meta.entropy]).await?;

            let result = transaction
                .query_one("select id from file where sha512 = $1", &[&meta.sha512])
                .await?;

            let fid: i64 = result.get(0);

            // Only set the parent if this is a new file
            if let Some(parent_id) = parent {
                transaction
                    .execute(
                        "update file set parent = $1 where id = $2",
                        &[&parent_id, &fid],
                    )
                    .await?;
            }

            // Only populate type-specific entries if this is a new file
            if known_type.is_doc() {
                if let Some(doc) = known_type.doc() {
                    let pages = doc.pages() as i32; // The Postgres API has a problem with unsigned integers
                    transaction.execute("insert into pdf(fileid, title, author, pages, javascript, forms) values($1, $2, $3, $4, $5, $6)",
                                        &[&fid, &doc.title(), &doc.author(), &pages, &doc.has_javascript(), &doc.has_form()]).await?;
                }
            } else if known_type.is_exec() {
                if let Some(exec) = known_type.exec() {
                    let sections = exec.num_sections() as i32;
                    transaction
                        .execute(
                            "insert into executable(fileid, sections) values($1, $2)",
                            &[&fid, &sections],
                        )
                        .await?;
                }
            }

            (fid, true)
        };

        let result = transaction
            .query_one(
                "select count(*) from filesource where fileid = $1 and sourceid = $2",
                &[&fid, &sid],
            )
            .await?;

        let count: i64 = result.get(0);

        if count == 0 {
            // This is a new source for this file, log it.
            transaction
                .execute(
                    "insert into filesource(fileid, sourceid, userid) values($1, $2, $3)",
                    &[&fid, &sid, &uid],
                )
                .await?;
        }

        let result = transaction
            .query_one(
                "select filename from filesource where fileid = $1 and sourceid = $2",
                &[&fid, &sid],
            )
            .await?;

        let file_names: Option<Vec<String>> = result.get(0);
        let mut file_names = file_names.unwrap_or_default();

        if let Some(fname) = &meta.name {
            if !file_names.contains(fname) {
                file_names.push(fname.clone());

                transaction
                    .execute(
                        "update filesource set filename = $1 where fileid = $2 and sourceid = $3",
                        &[&file_names, &fid, &sid],
                    )
                    .await?;
            }
        }

        Ok((fid, new_file))
    }

    pub async fn retrieve_sample(&self, uid: i32, hash: &HashType) -> Result<String> {
        let client = self.pool.get().await?;

        // The user may have provided the SHA-256 hash, but this ensures that the user is
        // allowed to retrieve it.
        let result = client
            .query(&format!("select distinct sha256 from file \
                                        join filesource on (file.id = filesource.fileid) \
                                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                                        join usergroup on (groupsource.gid = usergroup.gid)\
                                        where file.{} = $1 and usergroup.pid = $2", hash.name()),
                       &[&hash.the_hash(), &uid],
            )
            .await?;

        if result.is_empty() {
            bail!("Doesn't exist or not allowed");
        }

        if result.len() != 1 {
            // What if the user is asking for a file with a SHA-1 hash, but we get different
            // SHA-256 results? Different because of `distinct` in the query.
            eprintln!(
                "Postgres: data integrity failure, {} entries for {hash}",
                result.len()
            );
            bail!(
                "Postgres: data integrity failure, {} entries for {hash}",
                result.len()
            );
        }

        // We know now that one record was returned by the database.
        let sha256: String = result.first().unwrap().get(0);
        Ok(sha256)
    }

    pub async fn get_sample_report(
        &self,
        uid: i32,
        hash: &HashType,
    ) -> Result<malwaredb_api::Report> {
        let client = self.pool.get().await?;

        let result = client
            .query_one(&format!("select md5, sha1, sha256, sha384, sha512, lzjd, tlsh, ssdeep, sdhash, humanhash, filecommand, size, entropy from file \
                                        join filesource on (file.id = filesource.fileid) \
                                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                                        join usergroup on (groupsource.gid = usergroup.gid)\
                                        where file.{} = $1 and usergroup.pid = $2", hash.name()),
                       &[&hash.the_hash(), &uid],
            )
            .await?;
        let bytes: i32 = result.get(11);
        let formatter = make_format(DECIMAL);

        let vt_summary = if cfg!(feature = "vt") {
            let vt_result = client.query(&format!("select vthits.hits, vthits.total from vthits join file on (file.id = vthits.fileid) \
                                                        where file.{} = $1 order by vthits.tstamp desc limit 1", hash.name()), &[&hash.the_hash()]).await?;
            Some(
                vt_result
                    .first()
                    .map(|row| {
                        let hits: i32 = row.get(0);
                        let total: i32 = row.get(1);
                        malwaredb_api::VirusTotalSummary {
                            hits: hits as u32,
                            total: total as u32,
                        }
                    })
                    .unwrap_or_default(),
            )
        } else {
            None
        };

        Ok(malwaredb_api::Report {
            md5: result.get(0),
            sha1: result.get(1),
            sha256: result.get(2),
            sha384: result.get(3),
            sha512: result.get(4),
            lzjd: result.get(5),
            tlsh: result.get(6),
            ssdeep: result.get(7),
            sdhash: result.get(8),
            humanhash: result.get(9),
            filecommand: result.get(10),
            bytes: bytes as u32,
            size: formatter(bytes as u32),
            entropy: result.get(12),
            vt: vt_summary,
        })
    }

    /// Check the database to see which similarity hash comparison functions are installed.
    /// These functions allow the similarity comparison to be done on the server, which saves
    /// time and memory, because MalwareDB doesn't have to receive all the hashes and check
    /// the comparisons here.
    async fn check_similarity_functions(&self) -> Result<WhichHashesInstalled> {
        let client = self.pool.get().await?;

        let result = client
            .query(
                "select CAST(p.oid::regprocedure AS text)
              from pg_proc p join pg_namespace n on p.pronamespace = n.oid 
             where n.nspname not in ('pg_catalog', 'information_schema');",
                &[],
            )
            .await?;

        Ok(if !result.is_empty() {
            let mut tlsh = false;
            let mut lzjd = false;
            let mut sdhash = false;
            let mut ssdeep = false;

            for row in result {
                let name: String = row.get(0);
                if name == "lzjd_compare(text,text)" {
                    lzjd = true;
                }
                if name == "fuzzy_hash_compare(text,text)" {
                    ssdeep = true;
                }
                if name == "tlsh_compare(text,text)" {
                    tlsh = true;
                }
                if name == "sdhash_compare(text,text)" {
                    sdhash = true;
                }
            }

            WhichHashesInstalled {
                lzjd,
                tlsh,
                sdhash,
                ssdeep,
            }
        } else {
            WhichHashesInstalled {
                lzjd: false,
                tlsh: false,
                sdhash: false,
                ssdeep: false,
            }
        })
    }

    pub async fn find_similar_samples(
        &self,
        uid: i32,
        sim: &[(SimilarityHashType, String)],
    ) -> Result<Vec<SimilarSample>> {
        if !self.has_hash_extensions {
            bail!("similarity search without similarity extensions not yet supported");
        }

        let client = self.pool.get().await?;

        let mut results = HashMap::<String, Vec<(SimilarityHashType, f32)>>::new();
        for (algo, (table_field, hash_func), hash_value) in sim
            .iter()
            .map(|(sim, val)| (*sim, sim.get_table_field_simfunc(), val))
        {
            let rows = if let Some(hash_func) = hash_func {
                if algo == SimilarityHashType::TLSH {
                    client
                        .query(
                            &format!(
                                "select file.sha256, {hash_func}({table_field}, $1)::float \
                        from file join executable on (file.id = executable.fileid) \
                        join filesource on (file.id = filesource.fileid) \
                        join groupsource on (groupsource.sourceid = filesource.sourceid) \
                        join usergroup on (groupsource.gid = usergroup.gid)\
                        where {hash_func}({table_field}, $1) < 500 and usergroup.pid = $2",
                            ),
                            &[hash_value, &uid],
                        )
                        .await?
                } else {
                    client
                        .query(
                            &format!(
                                "select file.sha256, {hash_func}({table_field}, $1)::float \
                        from file join executable on (file.id = executable.fileid) \
                        join filesource on (file.id = filesource.fileid) \
                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                        join usergroup on (groupsource.gid = usergroup.gid)\
                        where {hash_func}({table_field}, $1) > 0 and usergroup.pid = $2",
                            ),
                            &[hash_value, &uid],
                        )
                        .await?
                }
            } else {
                client
                    .query(
                        &format!(
                            "select file.sha256, 100.0 as algo\
                            from file join executable on (file.id = executable.fileid)\
                        join filesource on (file.id = filesource.fileid) \
                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                        join usergroup on (groupsource.gid = usergroup.gid)\
                            where {table_field} = $1 and usergroup.pid = $2"
                        ),
                        &[hash_value, &uid],
                    )
                    .await?
            };
            for row in rows {
                let sha256: String = row.get(0);
                let similarity: f64 = row.get(1);
                if let Some(already) = results.get_mut(&sha256) {
                    already.push((algo, similarity as f32));
                } else {
                    results.insert(sha256, vec![(algo, similarity as f32)]);
                }
            }
        }

        Ok(results
            .into_iter()
            .map(|(sha256, algorithms)| SimilarSample { sha256, algorithms })
            .collect())
    }

    // Private functions

    pub(crate) async fn get_encryption_keys(&self) -> Result<HashMap<u32, FileEncryption>> {
        let client = self.pool.get().await?;

        let mut keys = HashMap::new();
        let results = client
            .query("select id, name, bytes from encryptionkey", &[])
            .await?;

        for result in results {
            let id: i32 = result.get(0);
            let name: String = result.get(1);
            let bytes: Vec<u8> = result.get(2);
            let key = FileEncryption::new(EncryptionOption::try_from(name.as_str())?, bytes)?;
            keys.insert(id as u32, key);
        }

        Ok(keys)
    }

    pub(crate) async fn get_file_encryption_key_id(
        &self,
        hash: &str,
    ) -> Result<(Option<u32>, Option<Vec<u8>>)> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select key, nonce from file where sha256 = $1", &[&hash])
            .await?;

        let key_id: Option<i32> = result.get(0);
        let nonce: Option<Vec<u8>> = result.get(1);
        Ok((key_id.map(|id| id as u32), nonce))
    }

    pub(crate) async fn set_file_nonce(&self, hash: &str, nonce: &Option<Vec<u8>>) -> Result<()> {
        let client = self.pool.get().await?;
        client
            .execute(
                "update file set nonce = $2 where sha256 = $1",
                &[&hash, &nonce],
            )
            .await?;

        Ok(())
    }

    // Administrative functions

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_file_encryption_key(&self, key: &FileEncryption) -> Result<u32> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into encryptionkey(name, bytes) values($1, $2)",
                &[&key.name(), &key.key()],
            )
            .await?;

        let results = client
            .query_one(
                "select id from encryptionkey where bytes = $1",
                &[&key.key()],
            )
            .await?;

        let key_id: i32 = results.get(0);

        client
            .execute("update mdbconfig set defaultKey = $1", &[&key_id])
            .await?;

        Ok(key_id as u32)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn get_encryption_key_names_ids(&self) -> Result<Vec<(u32, String)>> {
        let client = self.pool.get().await?;

        let mut keys = vec![];
        let results = client
            .query("select id, name from encryptionkey", &[])
            .await?;

        for result in results {
            let id: i32 = result.get(0);
            let name: String = result.get(1);
            keys.push((id as u32, name));
        }

        Ok(keys)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select count(1) from person where uname = $1", &[&uname])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("username already taken");
        }

        let result = client
            .query_one("select count(1) from person where email = $1", &[&email])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("email address already taken");
        }

        match password {
            Some(password) => {
                let password = hash_password(&password)?;
                client.execute("insert into person(email, uname, firstname, lastname, organisation, password) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation, &password]).await?;
            }
            None => {
                client.execute("insert into person(email, uname, firstname, lastname, organisation) values ($1, $2, $3, $4, $5);", &[&email, &uname, &fname, &lname, &organisation]).await?;
            }
        }

        let result = client
            .query_one("select id::bigint from person where uname = $1", &[&uname])
            .await?;

        let uid: i64 = result.get(0);
        Ok(uid as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn reset_api_keys(&self) -> Result<u64> {
        let client = self.pool.get().await?;
        let reset = client
            .execute("update person set apikey = NULL", &[])
            .await?;
        Ok(reset)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn set_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        let client = self.pool.get().await?;

        client
            .execute(
                "update person set password = $1 where uname = $2",
                &[&password, &uname],
            )
            .await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query("select id,email,uname,firstname,lastname,password is not null and length(password)>0,apikey is not null and length(apikey)>0,organisation,phone from person", &[])
            .await?;

        for result in results {
            users.push(admin::User {
                id: result.get(0),
                email: result.get(1),
                uname: result.get(2),
                fname: result.get(3),
                lname: result.get(4),
                has_password: result.get(5),
                has_api_key: result.get(6),
                org: result.get(7),
                phone: result.get(8),
            })
        }

        Ok(users)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn group_id_from_name(&self, name: &str) -> Result<i32> {
        let client = self.pool.get().await?;
        let results = client
            .query_one("select id from grp where name = $1", &[&name])
            .await?;
        let id: i32 = results.get(0);
        Ok(id)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn edit_group(
        &self,
        gid: i32,
        name: &str,
        desc: &str,
        parent: Option<i32>,
    ) -> Result<()> {
        let client = self.pool.get().await?;
        client
            .execute(
                "update grp set name = $1, description = $2, parent = $3 where id = $4",
                &[&name, &desc, &parent, &gid],
            )
            .await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_groups(&self) -> Result<Vec<admin::Group>> {
        let mut groups = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query("select grp.id, grp.name, grp.description, parent.name from grp left outer join grp parent on (grp.parent = parent.id)", &[])
            .await?;

        for result in results {
            let id: i32 = result.get(0);
            let members = {
                let members_results = client
                    .query("select person.id, person.uname, person.email, person.firstname, person.lastname, person.organisation, person.phone, person.password is not null and length(person.password)>0,person.apikey is not null and length(person.apikey)>0 from person, usergroup where person.id = usergroup.pid and usergroup.gid = $1", &[&id])
                    .await?;

                members_results
                    .into_iter()
                    .map(|x| admin::User {
                        id: x.get(0),
                        uname: x.get(1),
                        email: x.get(2),
                        fname: x.get(3),
                        lname: x.get(4),
                        org: x.get(5),
                        phone: x.get(6),
                        has_password: x.get(7),
                        has_api_key: x.get(8),
                    })
                    .collect()
            };

            let sources = {
                let id: i32 = result.get(0);
                let sources_results = client
                    .query("select source.id, source.name, source.description, source.url, source.firstacquisition, parent_source.name, count(filesource.fileid), count(gs2.gid)\
                    from source join groupsource as gs1 on (source.id = gs1.sourceid) left join filesource on (filesource.sourceid = source.id) \
                    left join groupsource as gs2 on (gs2.sourceid = source.id) \
                    left join source as parent_source on (source.parent = parent_source.id)\
                    where gs1.gid = $1 group by source.id, parent_source.name", &[&id])
                    .await.context(format!("failed to list sources for group {id}"))?;

                sources_results
                    .into_iter()
                    .map(|x| {
                        let files_count: i32 = x.get(6);
                        let groups_count: i32 = x.get(7);
                        admin::Source {
                            id: x.get(0),
                            name: x.get(1),
                            description: x.get(2),
                            url: x.get(3),
                            date: x.get(4),
                            files: files_count as u32,
                            groups: groups_count as u32,
                            parent: x.get(5),
                        }
                    })
                    .collect()
            };

            let files_row = client
                .query_one(
                    "select count(filesource.fileid) \
            from filesource join groupsource on (groupsource.gid = filesource.sourceid) \
            where groupsource.gid = $1",
                    &[&id],
                )
                .await
                .context(format!("failed to count files for group id {id}"))?;
            let files_count: i64 = files_row.get(0);

            groups.push(admin::Group {
                id,
                name: result.get(1),
                description: result.get(2),
                parent: result.get(3),
                members,
                sources,
                files: files_count as u32,
            });
        }

        Ok(groups)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_user_to_group(&self, uid: i32, gid: i32) -> Result<()> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into usergroup(pid, gid) values($1, $2)",
                &[&uid, &gid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_group_to_source(&self, gid: i32, sid: i32) -> Result<()> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into groupsource(gid, sourceid) values($1, $2)",
                &[&gid, &sid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_group(
        &self,
        name: &str,
        description: &str,
        parent: Option<i32>,
    ) -> Result<i32> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into grp(name, description, parent) values ($1, $2, $3);",
                &[&name, &description, &parent],
            )
            .await?;

        let result = client
            .query_one("select id from grp where name = $1", &[&name])
            .await?;
        let gid: i32 = result.get(0);

        Ok(gid)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_sources(&self) -> Result<Vec<admin::Source>> {
        let mut sources = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query(
                "select source.id, source.name, source.description, source.url, source.firstacquisition, parent_source.name, count(filesource.fileid), count(groupsource.gid) \
                from source join filesource on (source.id = filesource.sourceid) join groupsource on (groupsource.sourceid = source.id) left join source as parent_source on (source.parent = parent_source.id) \
                group by 1, 6",
                &[],
            )
            .await.context("failed to list sources")?;

        for result in results {
            let files_count: i64 = result.get(6);
            let groups_count: i64 = result.get(7);
            sources.push(admin::Source {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                url: result.get(3),
                date: result.get(4),
                files: files_count as u32,
                groups: groups_count as u32,
                parent: result.get(5),
            });
        }

        Ok(sources)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_source(
        &self,
        name: &str,
        description: Option<&str>,
        url: Option<&str>,
        date: chrono::DateTime<Local>,
        releasable: bool,
    ) -> Result<i32> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into source(name, description, url, firstacquisition, releasable) values ($1, $2, $3, $4, $5);",
                &[&name, &description, &url, &date, &releasable],
            )
            .await?;

        let result = client
            .query_one("select id from source where name = $1", &[&name])
            .await?;
        let sid: i32 = result.get(0);

        Ok(sid)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn edit_user(
        &self,
        uid: i32,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
    ) -> Result<()> {
        let client = self.pool.get().await?;
        client.execute("update person set uname = $1, email = $2, firstname = $3, lastname = $4 where id = $5;", &[&uname, &email, &fname, &lname, &uid]).await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn deactivate_user(&self, uid: i32) -> Result<()> {
        let client = self.pool.get().await?;
        client
            .execute(
                "update person set password = null, apikey = null where id = $1;",
                &[&uid],
            )
            .await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn file_types_counts(&self) -> Result<HashMap<String, u32>> {
        let client = self.pool.get().await?;
        let mut types_counts = HashMap::default();

        let results = client.query("SELECT filetype.name, count(file.id) from file join filetype on (file.filetypeid = filetype.id) group by 1", &[]).await?;

        for row in results {
            let name = row.get(0);
            let count: i64 = row.get(1);
            types_counts.insert(name, count as u32);
        }

        Ok(types_counts)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_label(&self, name: &str, parent: Option<i64>) -> Result<u64> {
        let client = self.pool.get().await?;
        client
            .execute(
                "insert into label(name, parent) values ($1, $2);",
                &[&name, &parent],
            )
            .await?;

        let result = client
            .query_one("select id from label where name = $1", &[&name])
            .await?;
        let lid: i64 = result.get(0);

        Ok(lid as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn edit_label(&self, id: u64, name: &str, parent: Option<u64>) -> Result<()> {
        let client = self.pool.get().await?;
        let id = id as i64;
        let parent = parent.map(|p| p as i64);
        client
            .execute(
                "update label set name = $1, parent = $2 where id = $3",
                &[&name, &parent, &id],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn label_id_from_name(&self, name: &str) -> Result<u64> {
        let client = self.pool.get().await?;
        let result = client
            .query_one("SELECT id from label where name = $1", &[&name])
            .await?;
        let label_id: i64 = result.get(0);

        Ok(label_id as u64)
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}
