use super::{hash_password, random_bytes_api_key, DatabaseInformation};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use deadpool_postgres::tokio_postgres::Config;
use deadpool_postgres::{tokio_postgres, Manager, ManagerConfig, Pool, RecyclingMethod};
use postgres::{Client, NoTls};

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

pub struct Postgres {
    connection_string: String,
    pool: Pool,
}

impl Postgres {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let mgr_config = ManagerConfig {
            recycling_method: RecyclingMethod::Fast,
        };

        let pg_config = connection_string.parse::<Config>()?;
        let mgr = Manager::from_config(pg_config, NoTls, mgr_config);
        let pool = Pool::builder(mgr).max_size(16).build()?;

        let client = pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await?
            .get(0)
        {
            let exists: bool = row.get(0);
            if !exists {
                client
                    .batch_execute(PG_SQL)
                    .await
                    .context("failed to create postgres tables")?;
            }
        } else {
            bail!("Failed to query postgres for file table existence");
        }

        Ok(Self {
            connection_string: connection_string.to_string(),
            pool,
        })
    }

    #[cfg(test)]
    pub(crate) async fn delete_init(&self) -> Result<()> {
        let mut client = self.pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).await.unwrap();
                client.execute("drop table vtclean", &[]).await.unwrap();
                client.execute("drop table vthits", &[]).await.unwrap();
                client.execute("drop table filetype", &[]).await.unwrap();
                client.execute("drop table executable", &[]).await.unwrap();
                client.execute("drop table pdf", &[]).await.unwrap();
                client.execute("drop table filesource", &[]).await.unwrap();
                client.execute("drop table filelabel", &[]).await.unwrap();
                client.execute("drop table sourcelabel", &[]).await.unwrap();
                client.execute("drop table file", &[]).await.unwrap();
                client.execute("drop table label", &[]).await.unwrap();
                client.execute("drop table mdbconfig", &[]).await.unwrap();
                client.execute("drop table source", &[]).await.unwrap();
                client.execute("drop table usergroup", &[]).await.unwrap();
                client.execute("drop table person", &[]).await.unwrap();
                client.execute("drop table grp", &[]).await.unwrap();
            }
        }

        client
            .batch_execute(PG_SQL)
            .await
            .context("failed to create postgres tables")?;

        Ok(())
    }

    pub async fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let mut client = self.pool.get().await?;

        let result = client
            .query("select password from person where uname = $1", &[&uname])
            .await?;

        if result.is_empty() {
            bail!("Unauthorized");
        } else if result.len() > 1 {
            eprintln!("Failure: more than one result for API key for username {uname}.");
            bail!("System error");
        }

        for row in result {
            let db_password: Option<String> = row.get(0);
            if let Some(db_password) = db_password {
                let password_hashed = PasswordHash::new(&db_password)?;
                Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            } else {
                bail!("Password not set");
            }
        }

        let result = client
            .query("select apikey from person where uname = $1", &[&uname])
            .await?;

        for row in result {
            let apikey: Option<String> = row.get(0);
            if let Some(apikey) = apikey {
                return Ok(apikey);
            }
        }

        let apikey = random_bytes_api_key();
        client
            .execute(
                "update person set apikey = $1 where uname = $2",
                &[&apikey, &uname],
            )
            .await?;

        Ok(apikey)
    }

    pub async fn db_info(&self) -> Result<DatabaseInformation> {
        let mut client = self.pool.get().await?;

        let result = client.query_one("SELECT current_database()", &[]).await?;
        let dbname: String = result.get(0);

        let result = client
            .query_one("SELECT pg_size_pretty(pg_database_size($1))", &[&dbname])
            .await?;
        let size: String = result.get(0);

        let result = client.query_one("SELECT version();", &[]).await?;
        let version: String = result.get(0);

        let result = client.query_one("SELECT count(1) from person", &[]).await?;
        let num_users: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from file", &[]).await?;
        let num_files: i64 = result.get(0);

        Ok(DatabaseInformation {
            version,
            size,
            num_files: num_files as u64,
            num_users: num_users as u64,
        })
    }

    pub async fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let mut client = self.pool.get().await?;

        let result = client
            .query_one("select count(1) from person where uname = $1", &[&uname])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("username already taken");
        }

        let result = client
            .query_one("select count(1) from person where email = $1", &[&email])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("email address already taken");
        }

        match password {
            Some(password) => {
                let password = hash_password(&password)?;
                client.execute("insert into person(email, uname, firstname, lastname, organisation, password) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation, &password]).await?;
            }
            None => {
                client.execute("insert into person(email, uname, firstname, lastname, organisation) values ($1, $2, $3, $4, $5);", &[&email, &uname, &fname, &lname, &organisation]).await?;
            }
        }

        let result = client
            .query_one("select id::bigint from person where uname = $1", &[&uname])
            .await?;

        let uid: i64 = result.get(0);
        Ok(uid as u64)
    }

    pub async fn reset_api_keys(&self) -> Result<u64> {
        let mut client = self.pool.get().await?;
        let reset = client
            .execute("update person set apikey = NULL", &[])
            .await?;
        Ok(reset)
    }

    pub async fn change_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        let mut client = self.pool.get().await?;

        client
            .execute(
                "update person set password = $1 where uname = $2",
                &[&uname, &password],
            )
            .await?;
        Ok(())
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

#[cfg(test)]
mod test {
    use super::*;

    const CONNECTION_STRING: &str =
        "user=malwaredbtesting password=malwaredbtesting dbname=malwaredbtesting host=localhost";

    async fn delete(psql: &Postgres) {
        let mut client = psql.pool.get().await.unwrap();

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).await.unwrap();
                client.execute("drop table vtclean", &[]).await.unwrap();
                client.execute("drop table vthits", &[]).await.unwrap();
                client.execute("drop table filetype", &[]).await.unwrap();
                client.execute("drop table executable", &[]).await.unwrap();
                client.execute("drop table pdf", &[]).await.unwrap();
                client.execute("drop table filesource", &[]).await.unwrap();
                client.execute("drop table filelabel", &[]).await.unwrap();
                client.execute("drop table sourcelabel", &[]).await.unwrap();
                client.execute("drop table file", &[]).await.unwrap();
                client.execute("drop table label", &[]).await.unwrap();
                client.execute("drop table mdbconfig", &[]).await.unwrap();
                client.execute("drop table source", &[]).await.unwrap();
                client.execute("drop table usergroup", &[]).await.unwrap();
                client.execute("drop table person", &[]).await.unwrap();
                client.execute("drop table grp", &[]).await.unwrap();
            }
        }
    }

    #[tokio::test]
    #[ignore]
    async fn everything() {
        let psql = Postgres::new(CONNECTION_STRING).await.unwrap();
        psql.delete_init().await.unwrap();
        let mut client = psql.pool.get().await.unwrap();

        let admin_password = "super_secure_password_dont_tell_anyone!";
        let admin_password_hashed = hash_password(admin_password)
            .context("failed to hash password")
            .unwrap();

        client
            .execute(
                "update person set password = $1 where id = 0",
                &[(&admin_password_hashed)],
            )
            .await
            .context("failed to set admin password")
            .unwrap();

        let admin_api_key = psql
            .authenticate("admin", &admin_password)
            .await
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {admin_api_key}");

        let admin_api_key_again = psql
            .authenticate("admin", &admin_password)
            .await
            .context("unable to get api key for admin")
            .unwrap();

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = psql.authenticate("admin", &bad_password).await;
        assert!(bad_api_key_request.is_err());

        assert_eq!(
            admin_api_key, admin_api_key_again,
            "API keys didn't match the second time."
        );

        let new_user_uname = "testuser";
        let new_user_email = "test@example.com";
        let new_user_password = "some_awesome_password_++";
        let new_id = psql
            .create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .await
            .unwrap();

        assert!(
            new_id > 0,
            "Weird UID created for user {}: {}",
            new_user_uname,
            new_id
        );

        assert!(
            psql.create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .await
            .is_err(),
            "Creating a new user with the same user name should fail"
        );

        let new_user_password_change = "some_new_awesomer_password!_++";
        psql.change_password(new_user_uname, new_user_password_change)
            .await
            .context("failed to change the password for testuser")
            .unwrap();

        let new_user_api_key = psql
            .authenticate(new_user_uname, &new_user_password)
            .await
            .context("unable to get api key for testuser")
            .unwrap();
        eprintln!("{new_user_uname} got API key {new_user_api_key}");

        assert_eq!(admin_api_key.len(), new_user_api_key.len());

        let reset = psql
            .reset_api_keys()
            .await
            .context("failed to reset all API keys")
            .unwrap();
        eprintln!("Cleared {reset} api keys.");

        let db_info = psql.db_info().await.unwrap();
        eprintln!("DB Info: {db_info:?}");

        delete(&psql).await;
    }
}
