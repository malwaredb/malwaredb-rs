use super::super::types::DataType;
#[cfg(any(test, feature = "admin"))]
use super::admin;
use super::{hash_password, random_bytes_api_key, DatabaseInformation};
use api::GetUserInfoResponse;

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use chrono::Local;
use deadpool_postgres::tokio_postgres::Config;
use deadpool_postgres::{
    tokio_postgres, GenericClient, Manager, ManagerConfig, Pool, RecyclingMethod,
};
use postgres::{Client, NoTls};
use zeroize::Zeroizing;

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

pub struct Postgres {
    connection_string: Zeroizing<String>,
    pool: Pool,
}

impl Postgres {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let mgr_config = ManagerConfig {
            recycling_method: RecyclingMethod::Fast,
        };

        let pg_config = connection_string.parse::<Config>()?;
        let mgr = Manager::from_config(pg_config, NoTls, mgr_config);
        let pool = Pool::builder(mgr).max_size(16).build()?;

        let client = pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await?
            .get(0)
        {
            let exists: bool = row.get(0);
            if !exists {
                client
                    .batch_execute(PG_SQL)
                    .await
                    .context("failed to create postgres tables")?;
            }
        } else {
            bail!("Failed to query postgres for file table existence");
        }

        Ok(Self {
            connection_string: Zeroizing::new(connection_string.to_string()),
            pool,
        })
    }

    #[cfg(test)]
    pub(crate) async fn delete_init(&self) -> Result<()> {
        let mut client = self.pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).await.unwrap();
                client.execute("drop table vtclean", &[]).await.unwrap();
                client.execute("drop table vthits", &[]).await.unwrap();
                client.execute("drop table filetype", &[]).await.unwrap();
                client.execute("drop table executable", &[]).await.unwrap();
                client.execute("drop table pdf", &[]).await.unwrap();
                client.execute("drop table filesource", &[]).await.unwrap();
                client.execute("drop table filelabel", &[]).await.unwrap();
                client.execute("drop table sourcelabel", &[]).await.unwrap();
                client.execute("drop table file", &[]).await.unwrap();
                client.execute("drop table label", &[]).await.unwrap();
                client.execute("drop table mdbconfig", &[]).await.unwrap();
                client.execute("drop table groupsource", &[]).await.unwrap();
                client.execute("drop table source", &[]).await.unwrap();
                client.execute("drop table usergroup", &[]).await.unwrap();
                client.execute("drop table person", &[]).await.unwrap();
                client.execute("drop table grp", &[]).await.unwrap();
            }
        }

        client
            .batch_execute(PG_SQL)
            .await
            .context("failed to create postgres tables")?;

        Ok(())
    }

    pub async fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let mut client = self.pool.get().await?;

        let result = client
            .query("select password from person where uname = $1", &[&uname])
            .await?;

        if result.is_empty() {
            bail!("Unauthorized");
        } else if result.len() > 1 {
            eprintln!("Failure: more than one result for API key for username {uname}.");
            bail!("System error");
        }

        for row in result {
            let db_password: Option<String> = row.get(0);
            if let Some(db_password) = db_password {
                let password_hashed = PasswordHash::new(&db_password)?;
                Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            } else {
                bail!("Password not set");
            }
        }

        let result = client
            .query("select apikey from person where uname = $1", &[&uname])
            .await?;

        for row in result {
            let apikey: Option<String> = row.get(0);
            if let Some(apikey) = apikey {
                return Ok(apikey);
            }
        }

        let apikey = random_bytes_api_key();
        client
            .execute(
                "update person set apikey = $1 where uname = $2",
                &[&apikey, &uname],
            )
            .await?;

        Ok(apikey)
    }

    pub async fn get_uid(&self, apikey: &str) -> Result<i32> {
        let mut client = self.pool.get().await?;
        let result = client
            .query_one("SELECT id from person where apikey = $1", &[&apikey])
            .await?;
        let uid: i32 = result.get(0);
        Ok(uid)
    }

    pub async fn db_info(&self) -> Result<DatabaseInformation> {
        let mut client = self.pool.get().await?;

        let result = client.query_one("SELECT current_database()", &[]).await?;
        let dbname: String = result.get(0);

        let result = client
            .query_one("SELECT pg_size_pretty(pg_database_size($1))", &[&dbname])
            .await?;
        let size: String = result.get(0);

        let result = client.query_one("SELECT version();", &[]).await?;
        let version: String = result.get(0);

        let result = client.query_one("SELECT count(1) from person", &[]).await?;
        let num_users: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from file", &[]).await?;
        let num_files: i64 = result.get(0);

        Ok(DatabaseInformation {
            version,
            size,
            num_files: num_files as u64,
            num_users: num_users as u64,
        })
    }

    pub async fn get_user_info(&self, uid: i32) -> Result<GetUserInfoResponse> {
        let mut client = self.pool.get().await?;

        let results = client
            .query_one("select uname from person where id = $1", &[&uid])
            .await?;

        let username = results.get(0);

        let results = client.query("select grp.name from grp, usergroup where grp.id = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut groups = vec![];
        for result in results {
            groups.push(result.get(0));
        }

        let results = client.query("select source.name from source, usergroup, groupsource where source.id = groupsource.sourceid and groupsource.gid = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut sources = vec![];
        for result in results {
            sources.push(result.get(0));
        }

        Ok(GetUserInfoResponse {
            id: uid,
            username,
            groups,
            sources,
        })
    }

    pub async fn get_known_data_types(&self) -> Result<Vec<DataType>> {
        let mut client = self.pool.get().await?;

        let results = client
            .query(
                "select id, name, description, magic, executable from filetype",
                &[],
            )
            .await?;
        let mut data_types = vec![];

        for result in results {
            data_types.push(DataType {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                magic: result.get(3),
                executable: result.get(4),
            });
        }

        Ok(data_types)
    }

    // Administrative functions

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let mut client = self.pool.get().await?;

        let result = client
            .query_one("select count(1) from person where uname = $1", &[&uname])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("username already taken");
        }

        let result = client
            .query_one("select count(1) from person where email = $1", &[&email])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("email address already taken");
        }

        match password {
            Some(password) => {
                let password = hash_password(&password)?;
                client.execute("insert into person(email, uname, firstname, lastname, organisation, password) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation, &password]).await?;
            }
            None => {
                client.execute("insert into person(email, uname, firstname, lastname, organisation) values ($1, $2, $3, $4, $5);", &[&email, &uname, &fname, &lname, &organisation]).await?;
            }
        }

        let result = client
            .query_one("select id::bigint from person where uname = $1", &[&uname])
            .await?;

        let uid: i64 = result.get(0);
        Ok(uid as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn reset_api_keys(&self) -> Result<u64> {
        let mut client = self.pool.get().await?;
        let reset = client
            .execute("update person set apikey = NULL", &[])
            .await?;
        Ok(reset)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn set_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        let mut client = self.pool.get().await?;

        client
            .execute(
                "update person set password = $1 where uname = $2",
                &[&uname, &password],
            )
            .await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let mut client = self.pool.get().await?;
        let results = client
            .query("select id,email,uname,password is not null and length(password)>0,apikey is not null and length(apikey)>0 from person", &[])
            .await?;

        for result in results {
            users.push(admin::User {
                id: result.get(0),
                email: result.get(1),
                uname: result.get(2),
                has_password: result.get(3),
                has_api_key: result.get(4),
            })
        }

        Ok(users)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_groups(&self, list_members: bool) -> Result<Vec<admin::Group>> {
        let mut groups = Vec::new();

        let mut client = self.pool.get().await?;
        let results = client
            .query("select grp.id, grp.name, grp.description, parent.name from grp left outer join grp parent on (grp.parent = parent.id)", &[])
            .await?;

        for result in results {
            let id: i32 = result.get(0);
            let members = if list_members {
                let members_results = client
                    .query("select person.uname from person, usergroup where person.id = usergroup.pid and usergroup.gid = $1", &[&id])
                    .await?;
                Some(
                    members_results
                        .into_iter()
                        .map(|x| {
                            let uname: String = x.get(0);
                            uname
                        })
                        .collect(),
                )
            } else {
                None
            };

            groups.push(admin::Group {
                id,
                name: result.get(1),
                description: result.get(2),
                parent: result.get(3),
                members,
            });
        }

        Ok(groups)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_user_to_group(&self, uid: i32, gid: i32) -> Result<()> {
        let mut client = self.pool.get().await?;

        client
            .execute(
                "insert into usergroup(pid, gid) values($1, $2)",
                &[&uid, &gid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_group_to_source(&self, gid: i32, sid: i32) -> Result<()> {
        let mut client = self.pool.get().await?;

        client
            .execute(
                "insert into groupsource(gid, sourceid) values($1, $2)",
                &[&gid, &sid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_group(
        &self,
        name: &str,
        description: &str,
        parent: Option<i32>,
    ) -> Result<i32> {
        let mut client = self.pool.get().await?;

        client
            .execute(
                "insert into grp(name, description, parent) values ($1, $2, $3);",
                &[&name, &description, &parent],
            )
            .await?;

        let result = client
            .query_one("select id from grp where name = $1", &[&name])
            .await?;
        let gid: i32 = result.get(0);

        Ok(gid)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_sources(&self) -> Result<Vec<admin::Source>> {
        let mut sources = Vec::new();

        let mut client = self.pool.get().await?;
        let results = client
            .query(
                "select id, name, description, url, firstacquisition from source",
                &[],
            )
            .await?;

        for result in results {
            sources.push(admin::Source {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                url: result.get(3),
                date: result.get(4),
            });
        }

        Ok(sources)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_source(
        &self,
        name: &str,
        description: Option<&str>,
        url: Option<&str>,
        date: chrono::DateTime<Local>,
        releasable: bool,
    ) -> Result<i32> {
        let mut client = self.pool.get().await?;

        client
            .execute(
                "insert into source(name, description, url, firstacquisition, releasable) values ($1, $2, $3, $4, $5);",
                &[&name, &description, &url, &date, &releasable],
            )
            .await?;

        let result = client
            .query_one("select id from source where name = $1", &[&name])
            .await?;
        let sid: i32 = result.get(0);

        Ok(sid)
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

#[cfg(test)]
mod test {
    use super::*;

    const CONNECTION_STRING: &str =
        "user=malwaredbtesting password=malwaredbtesting dbname=malwaredbtesting host=localhost";

    #[tokio::test]
    #[ignore]
    async fn everything() {
        let psql = Postgres::new(CONNECTION_STRING).await.unwrap();
        psql.delete_init().await.unwrap();
        let mut client = psql.pool.get().await.unwrap();

        let admin_password = "super_secure_password_dont_tell_anyone!";
        let admin_password_hashed = hash_password(admin_password)
            .context("failed to hash password")
            .unwrap();

        client
            .execute(
                "update person set password = $1 where id = 0",
                &[(&admin_password_hashed)],
            )
            .await
            .context("failed to set admin password")
            .unwrap();

        let admin_api_key = psql
            .authenticate("admin", &admin_password)
            .await
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {admin_api_key}");

        assert_eq!(
            psql.get_uid(&admin_api_key).await.unwrap(),
            0,
            "Unable to get UID given the API key"
        );

        let admin_api_key_again = psql
            .authenticate("admin", &admin_password)
            .await
            .context("unable to get api key for admin")
            .unwrap();

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = psql.authenticate("admin", &bad_password).await;
        assert!(bad_api_key_request.is_err());

        assert_eq!(
            admin_api_key, admin_api_key_again,
            "API keys didn't match the second time."
        );

        let new_user_uname = "testuser";
        let new_user_email = "test@example.com";
        let new_user_password = "some_awesome_password_++";
        let new_id = psql
            .create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .await
            .unwrap();

        psql.create_user(
            "passwordless_user",
            "passwordless_user",
            "passwordless_user",
            "passwordless_user@example.com",
            None,
            None,
        )
        .await
        .unwrap();

        assert!(
            new_id > 0,
            "Weird UID created for user {}: {}",
            new_user_uname,
            new_id
        );

        assert!(
            psql.create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .await
            .is_err(),
            "Creating a new user with the same user name should fail"
        );

        let new_user_password_change = "some_new_awesomer_password!_++";
        psql.set_password(new_user_uname, new_user_password_change)
            .await
            .context("failed to change the password for testuser")
            .unwrap();

        let new_user_api_key = psql
            .authenticate(new_user_uname, &new_user_password)
            .await
            .context("unable to get api key for testuser")
            .unwrap();
        eprintln!("{new_user_uname} got API key {new_user_api_key}");

        assert_eq!(admin_api_key.len(), new_user_api_key.len());

        let users = psql
            .list_users()
            .await
            .context("failed to list users")
            .unwrap();
        eprintln!("DB has {} users:", users.len());
        let mut passwordless_user_found = false;
        for user in users {
            println!("{user}");
            if user.uname == "passwordless_user" {
                assert!(!user.has_api_key);
                assert!(!user.has_password);
                passwordless_user_found = true;
            } else {
                assert!(user.has_api_key);
                assert!(user.has_password);
            }
        }
        assert!(passwordless_user_found);

        let new_group_name = "some_new_group";
        let new_group_desc = "some_new_group_description";
        let new_group_id = 1;
        assert_eq!(
            psql.create_group(new_group_name, new_group_desc, None)
                .await
                .context("failed to create group")
                .unwrap(),
            new_group_id
        );

        // Creating a duplicate group doesn't fail, but changes the expected group id for the following group.
        assert!(
            psql.create_group(new_group_name, new_group_desc, None)
                .await
                .is_err(),
            "Duplicate group name should have failed"
        );

        psql.add_user_to_group(1, 1)
            .await
            .context("Unable to add uid 1 to gid 1")
            .unwrap();

        let new_admin_group_name = "admin_subgroup";
        let new_admin_group_desc = "admin_subgroup_description";
        assert!(
            psql.create_group(new_admin_group_name, new_admin_group_desc, Some(0))
                .await
                .context("failed to create admin sub-group")
                .unwrap()
                > 1
        );

        let groups = psql
            .list_groups(true)
            .await
            .context("failed to list groups")
            .unwrap();
        eprintln!("DB has {} groups:", groups.len());
        for group in groups {
            println!("{group}");
            if group.name == new_admin_group_name {
                assert_eq!(group.parent, Some("admin".to_string()));
            }
            if group.name == new_group_name {
                let test_user_str = String::from(new_user_uname);
                assert!(group.members.unwrap().contains(&test_user_str));
            }
        }

        let default_source_name = "default_source".to_string();
        psql.create_source(
            &default_source_name,
            Some("default_source"),
            None,
            chrono::Local::now(),
            true,
        )
        .await
        .context("failed to create group")
        .unwrap();

        psql.add_group_to_source(1, 1)
            .await
            .context("failed to add group 1 to source 1")
            .unwrap();

        let sources = psql
            .list_sources()
            .await
            .context("failed to list sources")
            .unwrap();
        eprintln!("DB has {} sources:", sources.len());
        for source in sources {
            println!("{source}");
        }

        let uid = psql
            .get_uid(&new_user_api_key)
            .await
            .context("failed to user uid from apikey")
            .unwrap();
        let user_info = psql
            .get_user_info(uid)
            .await
            .context("failed to get user's available groups and sources")
            .unwrap();
        assert!(user_info.sources.contains(&default_source_name));
        println!("UserInfoResponse: {user_info:?}");

        let reset = psql
            .reset_api_keys()
            .await
            .context("failed to reset all API keys")
            .unwrap();
        eprintln!("Cleared {reset} api keys.");

        let db_info = psql
            .db_info()
            .await
            .context("failed to get database info")
            .unwrap();
        eprintln!("DB Info: {db_info:?}");

        let data_types = psql
            .get_known_data_types()
            .await
            .context("failed to get data types")
            .unwrap();
        for data_type in data_types {
            println!("{data_type:?}");
        }

        psql.delete_init().await.unwrap();
    }
}
