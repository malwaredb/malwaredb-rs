use super::{hash_password, random_bytes_api_key, DatabaseConnection};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use postgres::{Client, NoTls};

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

pub struct Postgres {
    client: Client,
    connection_string: String,
}

impl Postgres {
    pub fn new(connection_string: &str) -> Result<Self> {
        let mut client = Client::connect(connection_string, NoTls)?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )?
            .get(0)
        {
            let exists: bool = row.get(0);
            if !exists {
                println!("Tables don't seem to exists, creating.");
                client
                    .batch_execute(PG_SQL)
                    .context("failed to create postgres tables")?;
                println!("Tables created.");
            } else {
                println!("Tables already present.");
            }
        } else {
            bail!("Failed to query postgres for file table existence");
        }

        Ok(Self {
            client,
            connection_string: connection_string.to_string(),
        })
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl DatabaseConnection for Postgres {
    fn authenticate(&mut self, uname: &str, password: &str) -> Result<String> {
        let result = self
            .client
            .query("select password from person where uname = $1", &[&uname])?;

        if result.is_empty() {
            bail!("Unauthorized");
        } else if result.len() > 1 {
            eprintln!("Failure: more than one result for API key for username {uname}.");
            bail!("System error");
        }

        for row in result {
            let db_password: Option<String> = row.get(0);
            if let Some(db_password) = db_password {
                let password_hashed = PasswordHash::new(&db_password)?;
                Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            } else {
                bail!("Password not set");
            }
        }

        let result = self
            .client
            .query("select apikey from person where uname = $1", &[&uname])?;

        for row in result {
            let apikey: Option<String> = row.get(0);
            if let Some(apikey) = apikey {
                return Ok(apikey);
            }
        }

        let apikey = random_bytes_api_key();
        self.client.execute(
            "update person set apikey = $1 where uname = $2",
            &[&apikey, &uname],
        )?;

        Ok(apikey)
    }

    fn create_user(
        &mut self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u32> {
        todo!()
    }
}

#[cfg(test)]
mod test {
    use super::*;
    const CONNECTION_STRING: &str =
        "user=malwaredbtesting password=malwaredbtesting dbname=malwaredbtesting host=localhost";

    fn delete() {
        let mut client = Client::connect(CONNECTION_STRING, NoTls).unwrap();
        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).unwrap();
                client.execute("drop table vtclean", &[]).unwrap();
                client.execute("drop table vthits", &[]).unwrap();
                client.execute("drop table filetype", &[]).unwrap();
                client.execute("drop table executable", &[]).unwrap();
                client.execute("drop table pdf", &[]).unwrap();
                client.execute("drop table filesource", &[]).unwrap();
                client.execute("drop table filelabel", &[]).unwrap();
                client.execute("drop table sourcelabel", &[]).unwrap();
                client.execute("drop table file", &[]).unwrap();
                client.execute("drop table label", &[]).unwrap();
                client.execute("drop table mdbconfig", &[]).unwrap();
                client.execute("drop table source", &[]).unwrap();
                client.execute("drop table usergroup", &[]).unwrap();
                client.execute("drop table person", &[]).unwrap();
                client.execute("drop table grp", &[]).unwrap();
            }
        }
        client.close().unwrap();
    }

    #[test]
    #[ignore]
    fn everything() {
        delete();

        let mut psql = Postgres::new(CONNECTION_STRING).unwrap();

        let password = "super_secure_password_dont_tell_anyone!";
        let password_hashed = hash_password(password)
            .context("failed to hash password")
            .unwrap();

        psql.client
            .execute(
                "update person set password = $1 where id = 0",
                &[(&password_hashed)],
            )
            .context("failed to set admin password")
            .unwrap();

        let api_key = psql
            .authenticate("admin", &password)
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {api_key}");

        let api_key_again = psql
            .authenticate("admin", &password)
            .context("unable to get api key for admin")
            .unwrap();

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = psql.authenticate("admin", &bad_password);
        assert!(bad_api_key_request.is_err());

        assert_eq!(
            api_key, api_key_again,
            "API keys didn't match the second time."
        );

        delete();
    }
}
