#[cfg(any(test, feature = "admin"))]
use super::admin;
#[cfg(any(test, feature = "admin"))]
use super::hash_password;
use super::{random_bytes_api_key, DatabaseInformation};
use crate::db::types::{FileMetadata, FileType};
use api::{GetUserInfoResponse, HashType};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
#[cfg(any(test, feature = "admin"))]
use chrono::Local;
use deadpool_postgres::tokio_postgres::Config;
use deadpool_postgres::{GenericClient, Manager, ManagerConfig, Pool, RecyclingMethod};
use postgres::NoTls;
use types::KnownType;
use zeroize::Zeroizing;

const PG_SQL: &str = include_str!("malwaredb_pg.sql");

#[allow(unused)]
struct WhichHashesInstalled {
    pub lzjd: bool,
    pub tlsh: bool,
    pub sdhash: bool,
    pub ssdeep: bool,
}

pub struct Postgres {
    #[allow(unused)]
    connection_string: Zeroizing<String>,
    pool: Pool,
}

impl Postgres {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let mgr_config = ManagerConfig {
            recycling_method: RecyclingMethod::Fast,
        };

        let pg_config = connection_string.parse::<Config>()?;
        let mgr = Manager::from_config(pg_config, NoTls, mgr_config);
        let pool = Pool::builder(mgr).max_size(16).build()?;

        let client = pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await?
            .get(0)
        {
            let exists: bool = row.get(0);
            if !exists {
                client
                    .batch_execute(PG_SQL)
                    .await
                    .context("failed to create postgres tables")?;
            }
        } else {
            bail!("Failed to query postgres for file table existence");
        }

        Ok(Self {
            connection_string: Zeroizing::new(connection_string.to_string()),
            pool,
        })
    }

    #[cfg(test)]
    pub(crate) async fn delete_init(&self) -> Result<()> {
        let client = self.pool.get().await?;

        if let Some(row) = client
            .query(
                "\
                SELECT EXISTS (
            SELECT FROM 
                information_schema.tables 
            WHERE 
                table_schema LIKE 'public' AND 
                table_type LIKE 'BASE TABLE' AND
                table_name = 'file'
            );\
        ",
                &[],
            )
            .await
            .unwrap()
            .get(0)
        {
            let exists: bool = row.get(0);
            if exists {
                client.execute("drop table polyglot", &[]).await.unwrap();
                client.execute("drop table vtclean", &[]).await.unwrap();
                client.execute("drop table vthits", &[]).await.unwrap();
                client.execute("drop table filetype", &[]).await.unwrap();
                client.execute("drop table executable", &[]).await.unwrap();
                client.execute("drop table pdf", &[]).await.unwrap();
                client.execute("drop table filesource", &[]).await.unwrap();
                client.execute("drop table filelabel", &[]).await.unwrap();
                client.execute("drop table sourcelabel", &[]).await.unwrap();
                client.execute("drop table file", &[]).await.unwrap();
                client.execute("drop table label", &[]).await.unwrap();
                client.execute("drop table mdbconfig", &[]).await.unwrap();
                client.execute("drop table groupsource", &[]).await.unwrap();
                client.execute("drop table source", &[]).await.unwrap();
                client.execute("drop table usergroup", &[]).await.unwrap();
                client.execute("drop table person", &[]).await.unwrap();
                client.execute("drop table grp", &[]).await.unwrap();
            }
        }

        client
            .batch_execute(PG_SQL)
            .await
            .context("failed to create postgres tables")?;

        Ok(())
    }

    pub async fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let client = self.pool.get().await?;

        let result = client
            .query_opt("select password from person where uname = $1", &[&uname])
            .await?;

        let result = if let Some(r) = result {
            r
        } else {
            bail!("Password not set");
        };

        let db_password: Option<String> = result.get(0);
        if let Some(db_password) = db_password {
            let password_hashed = PasswordHash::new(&db_password)?;
            Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
        } else {
            bail!("Password not set");
        }

        let result = client
            .query("select apikey from person where uname = $1", &[&uname])
            .await?;

        for row in result {
            let apikey: Option<String> = row.get(0);
            if let Some(apikey) = apikey {
                return Ok(apikey);
            }
        }

        let apikey = random_bytes_api_key();
        client
            .execute(
                "update person set apikey = $1 where uname = $2",
                &[&apikey, &uname],
            )
            .await?;

        Ok(apikey)
    }

    pub async fn get_uid(&self, apikey: &str) -> Result<i32> {
        let client = self.pool.get().await?;
        let result = client
            .query_one("SELECT id from person where apikey = $1", &[&apikey])
            .await?;
        let uid: i32 = result.get(0);
        Ok(uid)
    }

    pub async fn db_info(&self) -> Result<DatabaseInformation> {
        let client = self.pool.get().await?;

        let result = client.query_one("SELECT current_database()", &[]).await?;
        let dbname: String = result.get(0);

        let result = client
            .query_one("SELECT pg_size_pretty(pg_database_size($1))", &[&dbname])
            .await?;
        let size: String = result.get(0);

        let result = client.query_one("SELECT version();", &[]).await?;
        let version: String = result.get(0);

        let result = client.query_one("SELECT count(1) from person", &[]).await?;
        let num_users: i64 = result.get(0);

        let result = client.query_one("SELECT count(1) from file", &[]).await?;
        let num_files: i64 = result.get(0);

        Ok(DatabaseInformation {
            version,
            size,
            num_files: num_files as u64,
            num_users: num_users as u64,
        })
    }

    pub async fn get_user_info(&self, uid: i32) -> Result<GetUserInfoResponse> {
        let client = self.pool.get().await?;

        let results = client
            .query_one("select uname from person where id = $1", &[&uid])
            .await?;

        let username = results.get(0);

        let results = client.query("select grp.name from grp, usergroup where grp.id = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut groups = vec![];
        for result in results {
            groups.push(result.get(0));
        }

        let results = client.query("select source.name from source, usergroup, groupsource where source.id = groupsource.sourceid and groupsource.gid = usergroup.gid and usergroup.pid = $1", &[&uid]).await?;

        let mut sources = vec![];
        for result in results {
            sources.push(result.get(0));
        }

        Ok(GetUserInfoResponse {
            id: uid,
            username,
            groups,
            sources,
        })
    }

    pub async fn get_known_data_types(&self) -> Result<Vec<FileType>> {
        let client = self.pool.get().await?;

        let results = client
            .query(
                "select id, name, description, magic, executable from filetype",
                &[],
            )
            .await?;
        let mut file_types = vec![];

        for result in results {
            file_types.push(FileType {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                magic: result.get(3),
                executable: result.get(4),
            });
        }

        Ok(file_types)
    }

    pub async fn allowed_user_source(&self, uid: i32, sid: i32) -> Result<bool> {
        let client = self.pool.get().await?;
        let results = client
            .query(
                "select usergroup.gid from usergroup, groupsource where usergroup.gid = groupsource.gid and usergroup.pid = $1 and groupsource.sourceid = $2",
                &[&uid, &sid],
            )
            .await?;

        Ok(!results.is_empty())
    }

    pub async fn add_file(
        &self,
        meta: &FileMetadata,
        known_type: KnownType<'_>,
        uid: i32,
        sid: i32,
        ftype: i32,
    ) -> Result<bool> {
        if !self.allowed_user_source(uid, sid).await? {
            bail!("uid {uid} not allowed to upload to sid {sid}");
        }

        let creation_date = known_type.created();

        let client = self.pool.get().await?;

        let result = client
            .query_one(
                "select count(*)::int from file where sha512 = $1",
                &[&meta.sha512],
            )
            .await?;

        let exists: i32 = result.get(0);
        if exists > 0 {
            return Ok(false);
        }

        let size = meta.size as i32;

        client.execute("insert into file(sha1, sha256, sha384, sha512, md5, lzjd, ssdeep, sdhash, tlsh, createddate, filetypeid, size, entropy)\
            values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)", &[&meta.sha1, &meta.sha256, &meta.sha384, &meta.sha512, &meta.md5, &meta.lzjd, &meta.ssdeep, &meta.sdhash, &meta.tlsh, &creation_date, &ftype, &size, &meta.entropy]).await?;

        let result = client
            .query_one("select id from file where sha512 = $1", &[&meta.sha512])
            .await?;

        let fid: i64 = result.get(0);

        let result = client.query_one(
            "select count(*) from filesource where fileid = $1 and sourceid = $2 and userid = $3",
            &[&fid, &sid, &uid],
        ).await?;

        let count: i64 = result.get(0);

        if count == 0 {
            client
                .execute(
                    "insert into filesource(fileid, sourceid, userid) values($1, $2, $3)",
                    &[&fid, &sid, &uid],
                )
                .await?;
        }

        let result = client.query_one(
            "select filename from filesource where fileid = $1 and sourceid = $2 and userid = $3",
            &[&fid, &sid, &uid],
        ).await?;

        let file_names: Option<Vec<String>> = result.get(0);
        let mut file_names = if let Some(fnames) = file_names {
            fnames
        } else {
            vec![]
        };

        if !file_names.contains(&meta.name) {
            file_names.push(meta.name.clone());

            client.execute("update filesource set filename = $1 where fileid = $2 and sourceid = $3 and userid = $4", &[&file_names, &fid, &sid, &uid]).await?;
        }

        if known_type.is_doc() {
            if let Some(pdf) = known_type.doc() {
                client.execute("insert into pdf(fileid, title, author, pages, javascript, forms) values($1, $2, $3, $4, $5, $6)",
                               &[&fid, &pdf.title, &pdf.author, &pdf.pages, &pdf.has_javascript, &pdf.has_form]).await?;
            }
        } else if known_type.is_exec() {
            if let Some(exec) = known_type.exec() {
                let sections = exec.num_sections() as i32;
                client
                    .execute(
                        "insert into executable(fileid, sections) values($1, $2)",
                        &[&fid, &sections],
                    )
                    .await?;
            }
        }

        Ok(true)
    }

    pub async fn retrieve_sample(&self, uid: i32, hash: HashType) -> Result<String> {
        let client = self.pool.get().await?;

        // The user may have provided the SHA-256 hash, but this ensures that the user is
        // allowed to retrieve it.
        let result = client
            .query_one(&format!("select sha256 from file \
                                        join filesource on (file.id = filesource.fileid) \
                                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                                        join usergroup on (groupsource.gid = usergroup.gid)\
                                        where file.{} = $1 and usergroup.pid = $2", hash.name()),
                &[&hash.the_hash(), &uid],
            )
            .await?;

        let sha256: String = result.get(0);
        Ok(sha256)
    }

    /// Check the database to see which similarity hash comparison functions are installed.
    /// These functions allow the similarity comparison to be done on the server, which saves
    /// time and memory, because MalwareDB doesn't have to receive all the hashes and check
    /// the comparisons here.
    #[allow(unused)]
    async fn check_similarity_functions(&self) -> Result<WhichHashesInstalled> {
        let client = self.pool.get().await?;

        let result = client
            .query(
                "select p.oid::regprocedure
              from pg_proc p join pg_namespace n on p.pronamespace = n.oid 
             where n.nspname not in ('pg_catalog', 'information_schema');",
                &[],
            )
            .await?;

        Ok(if !result.is_empty() {
            let mut tlsh = false;
            let mut lzjd = false;
            let mut sdhash = false;
            let mut ssdeep = false;

            for row in result {
                let name: String = row.get(0);
                if name == "lzjd_compare(text,text)" {
                    lzjd = true;
                }
                if name == "fuzzy_compare(text,text)" {
                    ssdeep = true;
                }
                if name == "tlsh_compare(text,text)" {
                    tlsh = true;
                }
                if name == "sdhash_compare(text,text)" {
                    sdhash = true;
                }
            }

            WhichHashesInstalled {
                lzjd,
                tlsh,
                sdhash,
                ssdeep,
            }
        } else {
            WhichHashesInstalled {
                lzjd: false,
                tlsh: false,
                sdhash: false,
                ssdeep: false,
            }
        })
    }

    // Administrative functions

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let client = self.pool.get().await?;

        let result = client
            .query_one("select count(1) from person where uname = $1", &[&uname])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("username already taken");
        }

        let result = client
            .query_one("select count(1) from person where email = $1", &[&email])
            .await?;

        let count: i64 = result.get(0);
        if count != 0 {
            bail!("email address already taken");
        }

        match password {
            Some(password) => {
                let password = hash_password(&password)?;
                client.execute("insert into person(email, uname, firstname, lastname, organisation, password) values ($1, $2, $3, $4, $5, $6);", &[&email, &uname, &fname, &lname, &organisation, &password]).await?;
            }
            None => {
                client.execute("insert into person(email, uname, firstname, lastname, organisation) values ($1, $2, $3, $4, $5);", &[&email, &uname, &fname, &lname, &organisation]).await?;
            }
        }

        let result = client
            .query_one("select id::bigint from person where uname = $1", &[&uname])
            .await?;

        let uid: i64 = result.get(0);
        Ok(uid as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn reset_api_keys(&self) -> Result<u64> {
        let client = self.pool.get().await?;
        let reset = client
            .execute("update person set apikey = NULL", &[])
            .await?;
        Ok(reset)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn set_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        let client = self.pool.get().await?;

        client
            .execute(
                "update person set password = $1 where uname = $2",
                &[&password, &uname],
            )
            .await?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query("select id,email,uname,password is not null and length(password)>0,apikey is not null and length(apikey)>0,organisation,phone from person", &[])
            .await?;

        for result in results {
            users.push(admin::User {
                id: result.get(0),
                email: result.get(1),
                uname: result.get(2),
                has_password: result.get(3),
                has_api_key: result.get(4),
                org: result.get(5),
                phone: result.get(6),
            })
        }

        Ok(users)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_groups(
        &self,
        list_members: bool,
        list_sources: bool,
    ) -> Result<Vec<admin::Group>> {
        let mut groups = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query("select grp.id, grp.name, grp.description, parent.name from grp left outer join grp parent on (grp.parent = parent.id)", &[])
            .await?;

        for result in results {
            let id: i32 = result.get(0);
            let members = if list_members {
                let members_results = client
                    .query("select person.id, person.uname, person.email, person.organisation, person.phone, person.password is not null and length(person.password)>0,person.apikey is not null and length(person.apikey)>0 from person, usergroup where person.id = usergroup.pid and usergroup.gid = $1", &[&id])
                    .await?;
                Some(
                    members_results
                        .into_iter()
                        .map(|x| admin::User {
                            id: x.get(0),
                            uname: x.get(1),
                            email: x.get(2),
                            org: x.get(3),
                            phone: x.get(4),
                            has_password: x.get(5),
                            has_api_key: x.get(6),
                        })
                        .collect(),
                )
            } else {
                None
            };

            let sources = if list_sources {
                let id: i32 = result.get(0);
                let sources_results = client
                    .query("select source.id, source.name, source.description, source.url, source.firstacquisition from source, groupsource where source.id = groupsource.sourceid and groupsource.gid = $1", &[&id])
                    .await?;
                Some(
                    sources_results
                        .into_iter()
                        .map(|x| admin::Source {
                            id: x.get(0),
                            name: x.get(1),
                            description: x.get(2),
                            url: x.get(3),
                            date: x.get(4),
                        })
                        .collect(),
                )
            } else {
                None
            };

            groups.push(admin::Group {
                id,
                name: result.get(1),
                description: result.get(2),
                parent: result.get(3),
                members,
                sources,
            });
        }

        Ok(groups)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_user_to_group(&self, uid: i32, gid: i32) -> Result<()> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into usergroup(pid, gid) values($1, $2)",
                &[&uid, &gid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn add_group_to_source(&self, gid: i32, sid: i32) -> Result<()> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into groupsource(gid, sourceid) values($1, $2)",
                &[&gid, &sid],
            )
            .await?;

        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_group(
        &self,
        name: &str,
        description: &str,
        parent: Option<i32>,
    ) -> Result<i32> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into grp(name, description, parent) values ($1, $2, $3);",
                &[&name, &description, &parent],
            )
            .await?;

        let result = client
            .query_one("select id from grp where name = $1", &[&name])
            .await?;
        let gid: i32 = result.get(0);

        Ok(gid)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn list_sources(&self) -> Result<Vec<admin::Source>> {
        let mut sources = Vec::new();

        let client = self.pool.get().await?;
        let results = client
            .query(
                "select id, name, description, url, firstacquisition from source",
                &[],
            )
            .await?;

        for result in results {
            sources.push(admin::Source {
                id: result.get(0),
                name: result.get(1),
                description: result.get(2),
                url: result.get(3),
                date: result.get(4),
            });
        }

        Ok(sources)
    }

    #[cfg(any(test, feature = "admin"))]
    pub async fn create_source(
        &self,
        name: &str,
        description: Option<&str>,
        url: Option<&str>,
        date: chrono::DateTime<Local>,
        releasable: bool,
    ) -> Result<i32> {
        let client = self.pool.get().await?;

        client
            .execute(
                "insert into source(name, description, url, firstacquisition, releasable) values ($1, $2, $3, $4, $5);",
                &[&name, &description, &url, &date, &releasable],
            )
            .await?;

        let result = client
            .query_one("select id from source where name = $1", &[&name])
            .await?;
        let sid: i32 = result.get(0);

        Ok(sid)
    }
}

impl Display for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}

impl Debug for Postgres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Postgres client")
    }
}
