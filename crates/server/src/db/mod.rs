//!
//! Postgres is the database used by MalwareDB.
//! However, SQLite will be used for unit testing. This option can be allowed by using the `sqlite`
//! feature flag. When using SQLite, any similarity functions must be calculated by MalwareDB.

#![allow(unused)]

mod pg;

#[cfg(any(test, feature = "sqlite"))]
mod sqlite;

use crate::db::pg::Postgres;

#[cfg(any(test, feature = "sqlite"))]
use crate::db::sqlite::Sqlite;

use anyhow::{bail, Result};
use argon2::password_hash::{rand_core::OsRng, SaltString};
use argon2::{Argon2, PasswordHasher};

#[derive(Debug)]
pub enum DatabaseType {
    Postgres(Postgres),
    #[cfg(any(test, feature = "sqlite"))]
    SQLite(Sqlite),
}

impl DatabaseType {
    pub fn from_string(arg: &str) -> Result<Self> {
        #[cfg(any(test, feature = "sqlite"))]
        if arg.starts_with("file:") {
            let new_conn_str = arg.trim_start_matches("file:");
            return Ok(DatabaseType::SQLite(Sqlite::new(new_conn_str)?));
        }

        if arg.starts_with("postgres") {
            let new_conn_str = arg.trim_start_matches("postgres");
            return Ok(DatabaseType::Postgres(Postgres::new(new_conn_str)?));
        }

        bail!("unknown database type {arg}")
    }
}

pub trait DatabaseConnection {
    /// Check user credentials, return API key. Generate if it doesn't exist.
    fn authenticate(&mut self, uname: &str, password: &str) -> Result<String>;

    // Administrative functions

    /// Create a user account, return the user ID.
    fn create_user(
        &mut self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u32>;
}

impl DatabaseConnection for DatabaseType {
    fn authenticate(&mut self, uname: &str, password: &str) -> Result<String> {
        match self {
            DatabaseType::Postgres(pg) => pg.authenticate(uname, password),
            #[cfg(any(test, feature = "sqlite"))]
            DatabaseType::SQLite(sl) => sl.authenticate(uname, password),
        }
    }

    fn create_user(
        &mut self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u32> {
        match self {
            DatabaseType::Postgres(pg) => {
                pg.create_user(uname, fname, lname, email, password, organisation)
            }
            #[cfg(any(test, feature = "sqlite"))]
            DatabaseType::SQLite(sl) => {
                sl.create_user(uname, fname, lname, email, password, organisation)
            }
        }
    }
}

pub fn hash_password(password: &str) -> Result<String> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    Ok(argon2
        .hash_password(password.as_bytes(), &salt)?
        .to_string())
}

pub fn random_bytes_api_key() -> String {
    let key = uuid::Uuid::new_v4();
    key.to_string()
}
