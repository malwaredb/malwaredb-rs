use super::{hash_password, random_bytes_api_key, DatabaseConnection};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use rusqlite::{Batch, Connection};

/// SQLite doesn't support arrays, so we'll use the Pipe
const ARRAY_DELIMITER: &str = "|";

// Remember:
// * Boolean fields are integers
// * Timestamp fields are text as ISO8601 strings "YYYY-MM-DD HH:MM:SS.SSS"
// * Bytea fields are hex values, possibly using the array delimiter above
const SQLITE_SQL: &str = include_str!("malwaredb_sqlite.sql");

pub struct Sqlite {
    conn: Connection,
    file_name: String,
}

impl Sqlite {
    pub fn new(file_name: &str) -> Result<Self> {
        let new_db = !std::path::Path::new(file_name).exists();

        if new_db {
            let conn = Connection::open(file_name)?;
            let mut batch = Batch::new(&conn, SQLITE_SQL);
            while let Some(mut stmt) = batch.next()? {
                stmt.execute([])?;
            }
        }
        // To-Do: check that the database is what we think it is.

        Ok(Self {
            conn: Connection::open(file_name)?,
            file_name: file_name.into(),
        })
    }
}

impl Display for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl Debug for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl DatabaseConnection for Sqlite {
    fn authenticate(&mut self, uname: &str, password: &str) -> Result<String> {
        let mut statement = self
            .conn
            .prepare("select password from person where uname = ?1")?;
        let results = statement.query_map(&[uname], |row| {
            let db_password: String = row.get(0)?;
            Ok(db_password)
        })?;

        let mut found = false;
        for result in results {
            // We need to know if we have results without taking ownership of the Result object.
            if let Ok(db_password) = result {
                let password_hashed = PasswordHash::new(&db_password)?;
                Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
                found = true;
            }
        }

        if !found {
            //bail!("Unauthorized");
        }

        let mut statement = self
            .conn
            .prepare("select apikey from person where uname = ?1")?;
        let results = statement.query_map(&[uname], |row| {
            // Bit of a hack since rusqlite seems to not support null-able fields.
            let apikey: rusqlite::Result<String> = row.get(0);
            if apikey.is_err() {
                return Ok(None);
            }
            let key: String = apikey.unwrap();
            Ok(Some(key))
        })?;

        for result in results {
            // We need to know if we have results without taking ownership of the Result object.
            if let Ok(key) = result {
                if let Some(got_key) = key {
                    return Ok(got_key);
                }
            }
        }

        let apikey = random_bytes_api_key();
        self.conn.execute(
            "update person set apikey = ?1 where uname = ?2",
            (&apikey, &uname),
        )?;
        return Ok(apikey);
    }

    fn create_user(
        &mut self,
        uname: &str,
        fname: &str,
        lname: &str,
        password: &str,
        email: &str,
    ) -> Result<u32> {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Context;
    use std::fs;

    const DB_FILE: &str = "testing_sqlite.db";

    #[test]
    fn everything() {
        if std::path::Path::new(DB_FILE).exists() {
            fs::remove_file(DB_FILE)
                .context(format!("failed to delete old SQLite file {DB_FILE}"))
                .unwrap();
        }

        let mut sqlite = Sqlite::new(DB_FILE)
            .context(format!("failed to create SQLite instance for {DB_FILE}"))
            .unwrap();

        let password = "super_secure_password_dont_tell_anyone!";
        let password_hashed = hash_password(password)
            .context("failed to hash password")
            .unwrap();

        sqlite
            .conn
            .execute(
                "update person set password = ?1 where id = 0",
                &[(&password_hashed)],
            )
            .context("failed to set admin password")
            .unwrap();

        let api_key = sqlite
            .authenticate("admin", &password)
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {api_key}");

        let api_key_again = sqlite
            .authenticate("admin", &password)
            .context("unable to get api key for admin")
            .unwrap();

        assert_eq!(
            api_key, api_key_again,
            "API keys didn't match the second time."
        );

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = sqlite.authenticate("admin", &bad_password);
        assert!(bad_api_key_request.is_err());

        fs::remove_file(DB_FILE)
            .context(format!("failed to delete SQLite file {DB_FILE}"))
            .unwrap();
    }
}
