#[cfg(any(test, feature = "admin"))]
use super::admin;
use super::{hash_password, random_bytes_api_key, DatabaseInformation};

use std::fmt::{Debug, Display, Formatter};
use std::time::SystemTime;

use anyhow::{bail, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use chrono::{DateTime, Utc};
use rusqlite::types::Null;
use rusqlite::{Batch, Connection};

/// SQLite doesn't support arrays, so we'll use the Pipe
const ARRAY_DELIMITER: &str = "|";

// Remember:
// * Boolean fields are integers
// * Timestamp fields are text as ISO8601 strings "YYYY-MM-DD HH:MM:SS.SSS"
// * Bytea fields are hex values, possibly using the array delimiter above
const SQLITE_SQL: &str = include_str!("malwaredb_sqlite.sql");

pub struct Sqlite {
    conn: Connection,
    file_name: String,
}

impl Sqlite {
    pub fn new(file_name: &str) -> Result<Self> {
        let new_db = !std::path::Path::new(file_name).exists();

        if new_db {
            let conn = Connection::open(file_name)?;
            let mut batch = Batch::new(&conn, SQLITE_SQL);
            while let Some(mut stmt) = batch.next()? {
                stmt.execute([])?;
            }
        }
        // To-Do: check that the database is what we think it is.

        Ok(Self {
            conn: Connection::open(file_name)?,
            file_name: file_name.into(),
        })
    }

    pub fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let mut statement = self
            .conn
            .prepare("select password from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let db_password: String = row.get(0)?;
            Ok(db_password)
        })?;

        let mut found = false;
        for result in results.flatten() {
            let password_hashed = PasswordHash::new(&result)?;
            Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            found = true;
        }

        if !found {
            bail!("Unauthorized");
        }

        let mut statement = self
            .conn
            .prepare("select apikey from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            // Bit of a hack since rusqlite seems to not support null-able fields.
            let apikey: rusqlite::Result<String> = row.get(0);
            if apikey.is_err() {
                return Ok(None);
            }
            let key: String = apikey.unwrap();
            Ok(Some(key))
        })?;

        if let Some(apikey) = results.flatten().flatten().next() {
            return Ok(apikey);
        }

        let apikey = random_bytes_api_key();
        self.conn.execute(
            "update person set apikey = ?1 where uname = ?2",
            (&apikey, &uname),
        )?;

        Ok(apikey)
    }

    pub fn db_info(&self) -> Result<DatabaseInformation> {
        let size = std::path::Path::new(&self.file_name).metadata()?.len();
        let size = humansize::SizeFormatter::new(size, humansize::BINARY).to_string();

        let mut statement = self.conn.prepare("SELECT sqlite_version();")?;
        let results = statement.query_map([], |row| {
            let ver: String = row.get(0)?;
            Ok(ver)
        })?;

        let version = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from person")?;
        let results = statement.query_map([], |row| {
            let users: u64 = row.get(0)?;
            Ok(users)
        })?;

        let num_users = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from file")?;
        let results = statement.query_map([], |row| {
            let files: u64 = row.get(0)?;
            Ok(files)
        })?;

        let num_files = results.flatten().next().unwrap();

        Ok(DatabaseInformation {
            version: format!("SQLite {version}"),
            size,
            num_files,
            num_users,
        })
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let mut statement = self
            .conn
            .prepare("select count() from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let count: u32 = row.get(0)?;
            Ok(count)
        })?;

        if let Some(count) = results.flatten().next() {
            if count != 0 {
                bail!("User already exists");
            }
        }

        let now: DateTime<Utc> = Utc::now();

        match password {
            None => {
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, created) values (?1, ?2, ?3, ?4, ?5, ?6);", (&email, &uname, &fname, &lname, &organisation, &now.to_rfc3339()))?;
            }
            Some(pass) => {
                let password = hash_password(&pass)?;
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, password, created) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);", (&email, &uname, &fname, &lname, &organisation, &password, &now.to_rfc3339()))?;
            }
        };

        let mut statement = self
            .conn
            .prepare("select id from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let uid: u64 = row.get(0)?;
            Ok(uid)
        })?;

        if let Some(uid) = results.flatten().next() {
            return Ok(uid);
        }
        bail!("User not created")
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn reset_api_keys(&self) -> Result<u64> {
        let reset = self.conn.execute("update person set apikey = NULL", ())?;
        Ok(reset as u64)
    }

    pub fn change_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        self.conn.execute(
            "update person set password = ?1 where uname = ?2",
            (&uname, &password),
        )?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let mut statement = self.conn.prepare("select id,email,uname,password is not null and length(password)>0,apikey is not null and length(apikey)>0 from person")?;

        for result in statement.query_map([], |row| {
            Ok(admin::User {
                id: row.get(0)?,
                email: row.get(1)?,
                uname: row.get(2)?,
                has_password: row.get(3)?,
                has_api_key: row.get(4)?,
            })
        })? {
            if let Ok(user) = result {
                users.push(user);
            } else {
                bail!("Failed to fetch user data");
            }
        }

        Ok(users)
    }
}

unsafe impl Send for Sqlite {}
unsafe impl Sync for Sqlite {}

impl Display for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl Debug for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Context;
    use std::fs;

    const DB_FILE: &str = "testing_sqlite.db";

    #[test]
    fn everything() {
        if std::path::Path::new(DB_FILE).exists() {
            fs::remove_file(DB_FILE)
                .context(format!("failed to delete old SQLite file {DB_FILE}"))
                .unwrap();
        }

        let mut sqlite = Sqlite::new(DB_FILE)
            .context(format!("failed to create SQLite instance for {DB_FILE}"))
            .unwrap();

        let admin_password = "super_secure_password_dont_tell_anyone!";
        let admin_password_hashed = hash_password(admin_password)
            .context("failed to hash password")
            .unwrap();

        sqlite
            .conn
            .execute(
                "update person set password = ?1 where id = 0",
                &[(&admin_password_hashed)],
            )
            .context("failed to set admin password")
            .unwrap();

        let admin_api_key = sqlite
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {admin_api_key}");

        let admin_api_key_again = sqlite
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();

        assert_eq!(
            admin_api_key, admin_api_key_again,
            "API keys didn't match the second time."
        );

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = sqlite.authenticate("admin", &bad_password);
        assert!(bad_api_key_request.is_err());

        let new_user_uname = "testuser";
        let new_user_email = "test@example.com";
        let new_user_password = "some_awesome_password_++";
        let new_id = sqlite
            .create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .unwrap();

        sqlite
            .create_user(
                "passwordless_user",
                "passwordless_user",
                "passwordless_user",
                "passwordless_user@example.com",
                None,
                None,
            )
            .unwrap();

        assert!(
            new_id > 0,
            "Weird UID created for user {}: {}",
            new_user_uname,
            new_id
        );

        assert!(
            sqlite
                .create_user(
                    new_user_uname,
                    new_user_uname,
                    new_user_uname,
                    new_user_email,
                    Some(new_user_password.into()),
                    None,
                )
                .is_err(),
            "Creating a new user with the same user name should fail"
        );

        let new_user_password_change = "some_new_awesomer_password!_++";
        sqlite
            .change_password(new_user_uname, new_user_password_change)
            .context("failed to change the password for testuser")
            .unwrap();

        let new_user_api_key = sqlite
            .authenticate(new_user_uname, &new_user_password)
            .context("unable to get api key for testuser")
            .unwrap();
        eprintln!("{new_user_uname} got API key {new_user_api_key}");

        assert_eq!(admin_api_key.len(), new_user_api_key.len());

        let users = sqlite.list_users().context("failed to list users").unwrap();
        eprintln!("DB has {} users:", users.len());
        let mut passwordless_user_found = false;
        for user in users {
            println!("{user}");
            if user.uname == "passwordless_user" {
                assert!(!user.has_api_key);
                assert!(!user.has_password);
                passwordless_user_found = true;
            } else {
                assert!(user.has_api_key);
                assert!(user.has_password);
            }
        }
        assert!(passwordless_user_found);

        let reset = sqlite
            .reset_api_keys()
            .context("failed to reset all API keys")
            .unwrap();
        eprintln!("Cleared {reset} api keys.");

        let db_info = sqlite.db_info().unwrap();
        eprintln!("DB Info: {db_info:?}");

        fs::remove_file(DB_FILE)
            .context(format!("failed to delete SQLite file {DB_FILE}"))
            .unwrap();
    }
}
