#[cfg(any(test, feature = "admin"))]
use super::admin;
#[cfg(any(test, feature = "admin"))]
use super::hash_password;
use super::{random_bytes_api_key, DatabaseInformation};
use crate::db::types::{FileMetadata, FileType};
use api::{GetUserInfoResponse, HashType};

use std::fmt::{Debug, Display, Formatter};

use anyhow::{anyhow, bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
#[cfg(any(test, feature = "admin"))]
use chrono::{DateTime, Local, Utc};
use rusqlite::params;
use rusqlite::{Batch, Connection};
use types::KnownType;

/// SQLite doesn't support arrays, so we'll use the Pipe
const ARRAY_DELIMITER: &str = "|";

// Remember:
// * Boolean fields are integers
// * Timestamp fields are text as ISO8601 strings "YYYY-MM-DD HH:MM:SS.SSS"
// * Bytea fields are hex values, possibly using the array delimiter above
const SQLITE_SQL: &str = include_str!("malwaredb_sqlite.sql");

pub struct Sqlite {
    conn: Connection,
    file_name: String,
}

impl Sqlite {
    pub fn new(file_name: &str) -> Result<Self> {
        let new_db = !std::path::Path::new(file_name).exists();

        if new_db {
            let conn = Connection::open(file_name)?;
            let mut batch = Batch::new(&conn, SQLITE_SQL);
            while let Some(mut stmt) = batch.next()? {
                stmt.execute([])?;
            }
        }
        // To-Do: check that the database is what we think it is.

        Ok(Self {
            conn: Connection::open(file_name)?,
            file_name: file_name.into(),
        })
    }

    pub fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let mut statement = self
            .conn
            .prepare("select password from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let db_password: String = row.get(0)?;
            Ok(db_password)
        })?;

        let mut found = false;
        for result in results.flatten() {
            let password_hashed = PasswordHash::new(&result)?;
            Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            found = true;
        }

        if !found {
            bail!("Unauthorized");
        }

        let mut statement = self
            .conn
            .prepare("select apikey from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            // Bit of a hack since rusqlite seems to not support null-able fields.
            let apikey: rusqlite::Result<String> = row.get(0);
            if apikey.is_err() {
                return Ok(None);
            }
            let key: String = apikey.unwrap();
            Ok(Some(key))
        })?;

        if let Some(apikey) = results.flatten().flatten().next() {
            return Ok(apikey);
        }

        let apikey = random_bytes_api_key();
        self.conn.execute(
            "update person set apikey = ?1 where uname = ?2",
            (&apikey, &uname),
        )?;

        Ok(apikey)
    }

    pub fn get_uid(&self, apikey: &str) -> Result<i32> {
        let mut statement = self
            .conn
            .prepare("select id from person where apikey = ?1")?;

        let results = statement.query_map([apikey], |row| {
            let uid: i32 = row.get(0)?;
            Ok(uid)
        })?;

        let uid = results.flatten().next();
        uid.ok_or(anyhow!("unable to get user ID"))
    }

    pub fn db_info(&self) -> Result<DatabaseInformation> {
        let size = std::path::Path::new(&self.file_name).metadata()?.len();
        let size = humansize::SizeFormatter::new(size, humansize::BINARY).to_string();

        let mut statement = self.conn.prepare("SELECT sqlite_version();")?;
        let results = statement.query_map([], |row| {
            let ver: String = row.get(0)?;
            Ok(ver)
        })?;

        let version = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from person")?;
        let results = statement.query_map([], |row| {
            let users: u64 = row.get(0)?;
            Ok(users)
        })?;

        let num_users = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from file")?;
        let results = statement.query_map([], |row| {
            let files: u64 = row.get(0)?;
            Ok(files)
        })?;

        let num_files = results.flatten().next().unwrap();

        Ok(DatabaseInformation {
            version: format!("SQLite {version}"),
            size,
            num_files,
            num_users,
        })
    }

    pub fn get_user_info(&self, uid: i32) -> Result<GetUserInfoResponse> {
        let mut statement = self
            .conn
            .prepare("select uname from person where id = ?1")?;
        let results = statement.query_map([uid], |row| {
            let uname: String = row.get(0)?;
            Ok(uname)
        })?;

        let username = results
            .flatten()
            .next()
            .ok_or(anyhow!("unable to get username"))?;

        let mut statement = self.conn.prepare("select grp.name from grp, usergroup where grp.id = usergroup.gid and usergroup.pid = ?1")?;
        let rows = statement.query_map([uid], |row| {
            let name: String = row.get(0)?;
            Ok(name)
        })?;

        let mut groups = vec![];
        for row in rows {
            groups.push(row?);
        }

        let mut statement = self.conn.prepare("select source.name from source, usergroup, groupsource where source.id = groupsource.sourceid and groupsource.gid = usergroup.gid and usergroup.pid = ?1")?;
        let rows = statement.query_map([uid], |row| {
            let name: String = row.get(0)?;
            Ok(name)
        })?;

        let mut sources = vec![];
        for row in rows {
            sources.push(row?);
        }

        Ok(GetUserInfoResponse {
            id: uid,
            username,
            groups,
            sources,
        })
    }

    pub fn get_known_data_types(&self) -> Result<Vec<FileType>> {
        let mut statement = self
            .conn
            .prepare("select id, name, description, magic, executable from filetype")?;
        let rows = statement.query_map([], |row| {
            let name: String = row.get(1)?;
            let magic = {
                let magic: String = row.get(3)?;
                let mut magic_numbers = vec![];
                if magic.contains(ARRAY_DELIMITER) {
                    for magic_hex in magic.split(ARRAY_DELIMITER) {
                        magic_numbers.push(
                            hex::decode(magic_hex)
                                .context(format!("could not decode hex from datatype {name}"))
                                .unwrap(),
                        );
                    }
                } else {
                    magic_numbers.push(
                        hex::decode(magic)
                            .context(format!("could not decode hex from datatype {name}"))
                            .unwrap(),
                    );
                }
                magic_numbers
            };

            let exec: i32 = row.get(4)?;
            Ok(FileType {
                id: row.get(0)?,
                name,
                description: row.get(2)?,
                magic,
                executable: exec > 0,
            })
        })?;

        let mut file_types = vec![];
        for row in rows {
            file_types.push(row?);
        }

        Ok(file_types)
    }

    pub fn allowed_user_source(&self, uid: i32, sid: i32) -> Result<bool> {
        let mut statement = self.conn.prepare(
                "select usergroup.gid from usergroup, groupsource where usergroup.gid = groupsource.gid and usergroup.pid = ?1 and groupsource.sourceid = ?2")?;

        let results = statement.query_map([uid, sid], |row| {
            let gid: u32 = row.get(0)?;
            Ok(gid)
        })?;

        let allowed = results.flatten().next().is_some();

        Ok(allowed)
    }

    pub fn add_file(
        &self,
        meta: &FileMetadata,
        known_type: KnownType<'_>,
        uid: i32,
        sid: i32,
        ftype: i32,
    ) -> Result<bool> {
        if !self.allowed_user_source(uid, sid)? {
            bail!("uid {uid} not allowed to upload to sid {sid}");
        }

        let creation_date = known_type.created().map(|d| d.to_rfc3339());

        let mut statement = self
            .conn
            .prepare("select count(1) from file where sha512 = ?1")?;

        let result = statement.query_map([&meta.sha512], |row| {
            let counts: i32 = row.get(0)?;
            Ok(counts)
        })?;

        let exists = result.flatten().next().unwrap();
        if exists > 0 {
            return Ok(false);
        }

        self.conn.execute("insert into file(sha1, sha256, sha384, sha512, md5, lzjd, ssdeep, sdhash, tlsh, createddate, filetypeid, size, entropy)\
            values(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13)", (&meta.sha1, &meta.sha256, &meta.sha384, &meta.sha512, &meta.md5, &meta.lzjd, &meta.ssdeep, &meta.sdhash, &meta.tlsh, &creation_date, &ftype, &meta.size, &meta.entropy))?;

        let mut statement = self.conn.prepare("select id from file where sha512 = ?1")?;
        let result = statement.query_map([&meta.sha512], |row| {
            let fid: i32 = row.get(0)?;
            Ok(fid)
        })?;

        let fid = if let Some(id) = result.flatten().next() {
            id
        } else {
            bail!("file record insertion failed");
        };

        self.conn.execute(
            "insert into filesource(fileid, sourceid, userid) values(?1, ?2, ?3)",
            (&fid, &sid, &uid),
        )?;

        if known_type.is_doc() {
            if let Some(pdf) = known_type.doc() {
                self.conn.execute("insert into pdf(fileid, title, author, pages, javascript, forms) values(?1, ?2, ?3, ?4, ?5, ?6)",
                                  (&fid, &pdf.title, &pdf.author, &pdf.pages, &pdf.has_javascript, &pdf.has_form))?;
            }
        } else if known_type.is_exec() {
            if let Some(exec) = known_type.exec() {
                self.conn.execute(
                    "insert into executable(fileid, sections) values(?1, ?2)",
                    (&fid, &exec.num_sections()),
                )?;
            }
        }

        Ok(true)
    }

    pub fn retrieve_sample(&self, uid: i32, hash: HashType) -> Result<String> {
        // The user may have provided the SHA-256 hash, but this ensures that the user is
        // allowed to retrieve it.
        let mut statement = self.conn.prepare(&format!("select sha256 from file \
                                        join filesource on (file.id = filesource.fileid) \
                                        join groupsource on (groupsource.sourceid = filesource.sourceid)\
                                        join usergroup on (groupsource.gid = usergroup.gid)\
                                        where file.{} = ?1 and usergroup.pid = ?2", hash.name()))?;

        statement
            .query_row(params![hash.the_hash(), uid], |row| {
                let sha256: String = row.get(0)?;
                Ok(sha256)
            })
            .map_err(|e| anyhow!(e.to_string()))
    }

    // Administrative functions

    #[cfg(any(test, feature = "admin"))]
    pub fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let mut statement = self
            .conn
            .prepare("select count() from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let count: u32 = row.get(0)?;
            Ok(count)
        })?;

        if let Some(count) = results.flatten().next() {
            if count != 0 {
                bail!("User already exists");
            }
        }

        let now: DateTime<Utc> = Utc::now();

        match password {
            None => {
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, created) values (?1, ?2, ?3, ?4, ?5, ?6);", (&email, &uname, &fname, &lname, &organisation, &now.to_rfc3339()))?;
            }
            Some(pass) => {
                let password = hash_password(&pass)?;
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, password, created) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);", (&email, &uname, &fname, &lname, &organisation, &password, &now.to_rfc3339()))?;
            }
        };

        let mut statement = self
            .conn
            .prepare("select id from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let uid: u64 = row.get(0)?;
            Ok(uid)
        })?;

        if let Some(uid) = results.flatten().next() {
            return Ok(uid);
        }
        bail!("User not created")
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn reset_api_keys(&self) -> Result<u64> {
        let reset = self.conn.execute("update person set apikey = NULL", ())?;
        Ok(reset as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn set_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        self.conn.execute(
            "update person set password = ?1 where uname = ?2",
            (&password, &uname),
        )?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let mut statement = self.conn.prepare("select id,email,uname,password is not null and length(password)>0,apikey is not null and length(apikey)>0,organisation,phone from person")?;

        for result in statement.query_map([], |row| {
            Ok(admin::User {
                id: row.get(0)?,
                email: row.get(1)?,
                uname: row.get(2)?,
                has_password: row.get(3)?,
                has_api_key: row.get(4)?,
                org: row.get(5)?,
                phone: row.get(6)?,
            })
        })? {
            if let Ok(user) = result {
                users.push(user);
            } else {
                bail!("Failed to fetch user data");
            }
        }

        Ok(users)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_groups(&self, list_members: bool, list_sources: bool) -> Result<Vec<admin::Group>> {
        let mut groups = Vec::new();

        let mut statement = self.conn.prepare("select grp.id, grp.name, grp.description, parent.name from grp left join grp parent on grp.parent = parent.id")?;

        for result in statement.query_map([], |row| {
            let id: i32 = row.get(0)?;

            let members = if list_members {
                let mut statement_members = self.conn.prepare("select person.id, person.uname, person.email, person.organisation, person.phone, person.password is not null and length(person.password)>0,person.apikey is not null and length(person.apikey)>0 from person, usergroup where person.id = usergroup.pid and usergroup.gid = ?1").expect("failed to get user names for group membership");
                let mut members_list = vec![];

                for member in statement_members.query_map([id], |member_row| {
                    Ok(admin::User{
                        id: member_row.get(0).expect("failed to get id"),
                        uname: member_row.get(1).expect("failed to get uname"),
                        email: member_row.get(2).expect("failed to get email"),
                        org: member_row.get(3).expect("failed to get org"),
                        phone: member_row.get(4).expect("failed to get phone"),
                        has_password: member_row.get(5).expect("failed to get password info"),
                        has_api_key: member_row.get(6).expect("failed to get apik key info"),
                    })
                })? {
                    members_list.push(member.expect("failed to get string form of uname"));
                }

                Some(members_list)
            } else {
                None
            };

            let sources = if list_sources {
                let mut sources_list = vec![];
                let mut statement_sources = self.conn.prepare("select source.id, source.name, source.description, source.url, source.firstacquisition from source, groupsource where source.id = groupsource.sourceid and groupsource.gid = ?1")?;
                for source in statement_sources.query_map([id], |source_row| {
                    let date: String = source_row.get(4).expect("failed to get date");
                    let date = chrono::DateTime::parse_from_rfc3339(&date).expect("failed to get source date in in Sqlite::list_groups");
                    let date = date.with_timezone(&Local);
                    Ok(admin::Source {
                        id: source_row.get(0).expect("failed to get id"),
                        name: source_row.get(1).expect("failed to get name"),
                        description: source_row.get(2).expect("failed to get description"),
                        url: source_row.get(3).expect("failed to get url"),
                        date,
                    })
                })? {
                    sources_list.push(source.expect("unable to get source linked to a group"));
                }
                Some(sources_list)
            } else {
                None
            };

            Ok(admin::Group {
                id,
                name: row.get(1)?,
                description: row.get(2)?,
                parent: row.get(3)?,
                members,
                sources,
            })
        })? {
            if let Ok(group) = result {
                groups.push(group);
            } else {
                bail!("Failed to fetch group data");
            }
        }

        Ok(groups)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn add_user_to_group(&self, uid: i32, gid: i32) -> Result<()> {
        self.conn
            .execute("insert into usergroup(pid, gid) values(?1, ?2)", (uid, gid))?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn add_group_to_source(&self, gid: i32, sid: i32) -> Result<()> {
        self.conn.execute(
            "insert into groupsource(gid, sourceid) values(?1, ?2)",
            (gid, sid),
        )?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn create_group(&self, name: &str, description: &str, parent: Option<i32>) -> Result<i32> {
        let result = if let Some(pid) = parent {
            self.conn.execute(
                "insert into grp(name, description, parent) values (?1, ?2, ?3);",
                params![&name, &description, &pid],
            )
        } else {
            self.conn.execute(
                "insert into grp(name, description) values (?1, ?2);",
                [&name, &description],
            )
        }?;

        if result != 1 {
            bail!("failed to create group {name}");
        }

        let mut statement = self.conn.prepare("select id from grp where name = ?1")?;
        let gid = statement
            .query_map([name], |row| {
                let gid: i32 = row.get(0)?;
                Ok(gid)
            })?
            .flatten()
            .next();
        gid.ok_or(anyhow!("unable to get group ID"))
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_sources(&self) -> Result<Vec<admin::Source>> {
        let mut sources = Vec::new();

        let mut statement = self
            .conn
            .prepare("select id, name, description, url, firstacquisition from source")?;

        for result in statement.query_map([], |row| {
            let date: String = row.get(4)?;
            // ToDo: Figure out proper chrono error to rusqlite error
            let date = chrono::DateTime::parse_from_rfc3339(&date)
                .expect("failed to get source date in Sqlite::list_sources");
            let date = date.with_timezone(&Local);

            Ok(admin::Source {
                id: row.get(0)?,
                name: row.get(1)?,
                description: row.get(2)?,
                url: row.get(3)?,
                date,
            })
        })? {
            if let Ok(source) = result {
                sources.push(source);
            } else {
                bail!("Failed to fetch source data");
            }
        }

        Ok(sources)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn create_source(
        &self,
        name: &str,
        description: Option<&str>,
        url: Option<&str>,
        date: chrono::DateTime<Local>,
        releasable: bool,
    ) -> Result<i32> {
        let result = self.conn.execute(
            "insert into source(name, description, url, firstacquisition, releasable) values (?1, ?2, ?3, ?4, ?5);",
            params![&name, &description, url, date.to_rfc3339(), releasable],
        )?;

        if result != 1 {
            bail!("failed to create source {name}");
        }

        let mut statement = self.conn.prepare("select id from source where name = ?1")?;
        let gid = statement
            .query_map([name], |row| {
                let sid: i32 = row.get(0)?;
                Ok(sid)
            })?
            .flatten()
            .next();
        gid.ok_or(anyhow!("unable to get source ID"))
    }
}

unsafe impl Send for Sqlite {}
unsafe impl Sync for Sqlite {}

impl Display for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl Debug for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}
