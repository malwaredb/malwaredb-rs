use std::fmt::{Debug, Display, Formatter};

use anyhow::{bail, Result};
use rusqlite::Connection;

/// SQLite doesn't support arrays, so we'll use the Pipe
const ARRAY_DELIMITER: &str = "|";

// Remember:
// * Boolean fields are integers
// * Timestamp fields are text as ISO8601 strings "YYYY-MM-DD HH:MM:SS.SSS"
// * Bytea fields are hex values, possibly using the array delimiter above
const SQLITE_SQL: &str = include_str!("malwaredb_sqlite.sql");

pub struct Sqlite {
    conn: Connection,
    file_name: String,
}

impl Sqlite {
    pub fn new(file_name: &str) -> Result<Self> {
        let conn = Connection::open(file_name)?;

        let mut statement =
            conn.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='file';")?;

        if let Ok(mut result) = statement.query(()) {
            if let Ok(rows) = result.next() {
                if let Some(row) = rows {
                    let name: String = row.get(0)?;
                    if !name.eq("file") {
                        bail!("Unexpected table name {name}");
                    }
                } else {
                    conn.execute(SQLITE_SQL, ())?;
                }
            } else {
                bail!("Failed to query SQLite for file table existence");
            }
        } else {
            bail!("Failed to query SQLite for file table existence");
        }

        Ok(Self {
            conn: Connection::open(file_name)?,
            file_name: file_name.into(),
        })
    }
}

impl Display for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl Debug for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Context;
    use std::fs;

    const DB_FILE: &str = "testing_sqlite.db";

    #[test]
    fn everything() {
        let _sqlite = Sqlite::new(DB_FILE)
            .context(format!("failed to create SQLite instance for {DB_FILE}"))
            .unwrap();

        fs::remove_file(DB_FILE)
            .context(format!("failed to delete SQLite file {DB_FILE}"))
            .unwrap();
    }
}
