#[cfg(any(test, feature = "admin"))]
use super::admin;
#[cfg(any(test, feature = "admin"))]
use super::hash_password;
use super::{random_bytes_api_key, DatabaseInformation};
use crate::db::types::{FileMetadata, FileType};
use api::GetUserInfoResponse;

use std::fmt::{Debug, Display, Formatter};

use anyhow::{anyhow, bail, Context, Result};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
#[cfg(any(test, feature = "admin"))]
use chrono::{DateTime, Local, Utc};
#[cfg(any(test, feature = "admin"))]
use rusqlite::params;
use rusqlite::{Batch, Connection};
use types::KnownType;

/// SQLite doesn't support arrays, so we'll use the Pipe
const ARRAY_DELIMITER: &str = "|";

// Remember:
// * Boolean fields are integers
// * Timestamp fields are text as ISO8601 strings "YYYY-MM-DD HH:MM:SS.SSS"
// * Bytea fields are hex values, possibly using the array delimiter above
const SQLITE_SQL: &str = include_str!("malwaredb_sqlite.sql");

pub struct Sqlite {
    conn: Connection,
    file_name: String,
}

impl Sqlite {
    pub fn new(file_name: &str) -> Result<Self> {
        let new_db = !std::path::Path::new(file_name).exists();

        if new_db {
            let conn = Connection::open(file_name)?;
            let mut batch = Batch::new(&conn, SQLITE_SQL);
            while let Some(mut stmt) = batch.next()? {
                stmt.execute([])?;
            }
        }
        // To-Do: check that the database is what we think it is.

        Ok(Self {
            conn: Connection::open(file_name)?,
            file_name: file_name.into(),
        })
    }

    pub fn authenticate(&self, uname: &str, password: &str) -> Result<String> {
        let mut statement = self
            .conn
            .prepare("select password from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let db_password: String = row.get(0)?;
            Ok(db_password)
        })?;

        let mut found = false;
        for result in results.flatten() {
            let password_hashed = PasswordHash::new(&result)?;
            Argon2::default().verify_password(password.as_ref(), &password_hashed)?;
            found = true;
        }

        if !found {
            bail!("Unauthorized");
        }

        let mut statement = self
            .conn
            .prepare("select apikey from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            // Bit of a hack since rusqlite seems to not support null-able fields.
            let apikey: rusqlite::Result<String> = row.get(0);
            if apikey.is_err() {
                return Ok(None);
            }
            let key: String = apikey.unwrap();
            Ok(Some(key))
        })?;

        if let Some(apikey) = results.flatten().flatten().next() {
            return Ok(apikey);
        }

        let apikey = random_bytes_api_key();
        self.conn.execute(
            "update person set apikey = ?1 where uname = ?2",
            (&apikey, &uname),
        )?;

        Ok(apikey)
    }

    pub fn get_uid(&self, apikey: &str) -> Result<i32> {
        let mut statement = self
            .conn
            .prepare("select id from person where apikey = ?1")?;

        let results = statement.query_map([apikey], |row| {
            let uid: i32 = row.get(0)?;
            Ok(uid)
        })?;

        let uid = results.flatten().next();
        uid.ok_or(anyhow!("unable to get user ID"))
    }

    pub fn db_info(&self) -> Result<DatabaseInformation> {
        let size = std::path::Path::new(&self.file_name).metadata()?.len();
        let size = humansize::SizeFormatter::new(size, humansize::BINARY).to_string();

        let mut statement = self.conn.prepare("SELECT sqlite_version();")?;
        let results = statement.query_map([], |row| {
            let ver: String = row.get(0)?;
            Ok(ver)
        })?;

        let version = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from person")?;
        let results = statement.query_map([], |row| {
            let users: u64 = row.get(0)?;
            Ok(users)
        })?;

        let num_users = results.flatten().next().unwrap();

        let mut statement = self.conn.prepare("SELECT count(1) from file")?;
        let results = statement.query_map([], |row| {
            let files: u64 = row.get(0)?;
            Ok(files)
        })?;

        let num_files = results.flatten().next().unwrap();

        Ok(DatabaseInformation {
            version: format!("SQLite {version}"),
            size,
            num_files,
            num_users,
        })
    }

    pub fn get_user_info(&self, uid: i32) -> Result<GetUserInfoResponse> {
        let mut statement = self
            .conn
            .prepare("select uname from person where id = ?1")?;
        let results = statement.query_map([uid], |row| {
            let uname: String = row.get(0)?;
            Ok(uname)
        })?;

        let username = results
            .flatten()
            .next()
            .ok_or(anyhow!("unable to get username"))?;

        let mut statement = self.conn.prepare("select grp.name from grp, usergroup where grp.id = usergroup.gid and usergroup.pid = ?1")?;
        let rows = statement.query_map([uid], |row| {
            let name: String = row.get(0)?;
            Ok(name)
        })?;

        let mut groups = vec![];
        for row in rows {
            groups.push(row?);
        }

        let mut statement = self.conn.prepare("select source.name from source, usergroup, groupsource where source.id = groupsource.sourceid and groupsource.gid = usergroup.gid and usergroup.pid = ?1")?;
        let rows = statement.query_map([uid], |row| {
            let name: String = row.get(0)?;
            Ok(name)
        })?;

        let mut sources = vec![];
        for row in rows {
            sources.push(row?);
        }

        Ok(GetUserInfoResponse {
            id: uid,
            username,
            groups,
            sources,
        })
    }

    pub fn get_known_data_types(&self) -> Result<Vec<FileType>> {
        let mut statement = self
            .conn
            .prepare("select id, name, description, magic, executable from filetype")?;
        let rows = statement.query_map([], |row| {
            let name: String = row.get(1)?;
            let magic = {
                let magic: String = row.get(3)?;
                let mut magic_numbers = vec![];
                if magic.contains(ARRAY_DELIMITER) {
                    for magic_hex in magic.split(ARRAY_DELIMITER) {
                        magic_numbers.push(
                            hex::decode(magic_hex)
                                .context(format!("could not decode hex from datatype {name}"))
                                .unwrap(),
                        );
                    }
                } else {
                    magic_numbers.push(
                        hex::decode(magic)
                            .context(format!("could not decode hex from datatype {name}"))
                            .unwrap(),
                    );
                }
                magic_numbers
            };

            let exec: i32 = row.get(4)?;
            Ok(FileType {
                id: row.get(0)?,
                name,
                description: row.get(2)?,
                magic,
                executable: exec > 0,
            })
        })?;

        let mut file_types = vec![];
        for row in rows {
            file_types.push(row?);
        }

        Ok(file_types)
    }

    pub fn allowed_user_source(&self, uid: i32, sid: i32) -> Result<bool> {
        let mut statement = self.conn.prepare(
                "select usergroup.gid from usergroup, groupsource where usergroup.gid = groupsource.gid and usergroup.pid = ?1 and groupsource.sourceid = ?2")?;

        let results = statement.query_map([uid, sid], |row| {
            let gid: u32 = row.get(0)?;
            Ok(gid)
        })?;

        let allowed = results.flatten().next().is_some();

        Ok(allowed)
    }

    pub fn add_file(
        &self,
        meta: &FileMetadata,
        known_type: KnownType<'_>,
        uid: i32,
        sid: i32,
        ftype: i32,
    ) -> Result<bool> {
        if !self.allowed_user_source(uid, sid)? {
            bail!("uid {uid} not allowed to upload to sid {sid}");
        }

        let creation_date = known_type.created().map(|d| d.to_rfc3339());

        let mut statement = self
            .conn
            .prepare("select count(1) from file where sha512 = ?1")?;

        let result = statement.query_map([&meta.sha512], |row| {
            let counts: i32 = row.get(0)?;
            Ok(counts)
        })?;

        let exists = result.flatten().next().unwrap();
        if exists > 0 {
            return Ok(false);
        }

        self.conn.execute("insert into file(sha1, sha256, sha512, md5, lzjd, ssdeep, sdhash, tlsh, createddate, filetypeid, size, entropy)\
            values(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12)", (&meta.sha1, &meta.sha256, &meta.sha512, &meta.md5, &meta.lzjd, &meta.ssdeep, &meta.sdhash, &meta.tlsh, &creation_date, &ftype, &meta.size, &meta.entropy))?;

        let mut statement = self.conn.prepare("select id from file where sha512 = ?1")?;
        let result = statement.query_map([&meta.sha512], |row| {
            let fid: i32 = row.get(0)?;
            Ok(fid)
        })?;

        let fid = if let Some(id) = result.flatten().next() {
            id
        } else {
            bail!("file record insertion failed");
        };

        self.conn.execute(
            "insert into filesource(fileid, sourceid, userid) values(?1, ?2, ?3)",
            (&fid, &sid, &uid),
        )?;

        if known_type.is_doc() {
            if let Some(pdf) = known_type.doc() {
                self.conn.execute("insert into pdf(fileid, title, author, pages, javascript, forms) values(?1, ?2, ?3, ?4, ?5, ?6)",
                                  (&fid, &pdf.title, &pdf.author, &pdf.pages, &pdf.has_javascript, &pdf.has_form))?;
            }
        } else if known_type.is_exec() {
            if let Some(exec) = known_type.exec() {
                self.conn.execute(
                    "insert into executable(fileid, sections) values(?1, ?2)",
                    (&fid, &exec.num_sections()),
                )?;
            }
        }

        Ok(true)
    }

    // Administrative functions

    #[cfg(any(test, feature = "admin"))]
    pub fn create_user(
        &self,
        uname: &str,
        fname: &str,
        lname: &str,
        email: &str,
        password: Option<String>,
        organisation: Option<String>,
    ) -> Result<u64> {
        let mut statement = self
            .conn
            .prepare("select count() from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let count: u32 = row.get(0)?;
            Ok(count)
        })?;

        if let Some(count) = results.flatten().next() {
            if count != 0 {
                bail!("User already exists");
            }
        }

        let now: DateTime<Utc> = Utc::now();

        match password {
            None => {
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, created) values (?1, ?2, ?3, ?4, ?5, ?6);", (&email, &uname, &fname, &lname, &organisation, &now.to_rfc3339()))?;
            }
            Some(pass) => {
                let password = hash_password(&pass)?;
                self.conn
                    .execute("insert into person(email, uname, firstname, lastname, organisation, password, created) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);", (&email, &uname, &fname, &lname, &organisation, &password, &now.to_rfc3339()))?;
            }
        };

        let mut statement = self
            .conn
            .prepare("select id from person where uname = ?1")?;
        let results = statement.query_map([uname], |row| {
            let uid: u64 = row.get(0)?;
            Ok(uid)
        })?;

        if let Some(uid) = results.flatten().next() {
            return Ok(uid);
        }
        bail!("User not created")
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn reset_api_keys(&self) -> Result<u64> {
        let reset = self.conn.execute("update person set apikey = NULL", ())?;
        Ok(reset as u64)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn set_password(&self, uname: &str, password: &str) -> Result<()> {
        let password = hash_password(password)?;
        self.conn.execute(
            "update person set password = ?1 where uname = ?2",
            (&uname, &password),
        )?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_users(&self) -> Result<Vec<admin::User>> {
        let mut users = Vec::new();

        let mut statement = self.conn.prepare("select id,email,uname,password is not null and length(password)>0,apikey is not null and length(apikey)>0 from person")?;

        for result in statement.query_map([], |row| {
            Ok(admin::User {
                id: row.get(0)?,
                email: row.get(1)?,
                uname: row.get(2)?,
                has_password: row.get(3)?,
                has_api_key: row.get(4)?,
            })
        })? {
            if let Ok(user) = result {
                users.push(user);
            } else {
                bail!("Failed to fetch user data");
            }
        }

        Ok(users)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_groups(&self, list_members: bool) -> Result<Vec<admin::Group>> {
        let mut groups = Vec::new();

        let mut statement = self.conn.prepare("select grp.id, grp.name, grp.description, parent.name from grp left join grp parent on grp.parent = parent.id")?;

        for result in statement.query_map([], |row| {
            let id: i32 = row.get(0)?;

            let members = if list_members {
                let mut statement_members = self.conn.prepare("select person.uname from person, usergroup where person.id = usergroup.pid and usergroup.gid = ?1").expect("failed to get user names for group membership");
                let mut members_list = vec![];

                for member in statement_members.query_map([id], |member_row| {
                    let uname: String = member_row.get(0).expect("failed to get uname");
                    Ok(uname)
                }).unwrap() {
                    members_list.push(member.expect("failed to get string form of uname"));
                }

                Some(members_list)
            } else {
                None
            };

            Ok(admin::Group {
                id,
                name: row.get(1)?,
                description: row.get(2)?,
                parent: row.get(3)?,
                members,
            })
        })? {
            if let Ok(group) = result {
                groups.push(group);
            } else {
                bail!("Failed to fetch group data");
            }
        }

        Ok(groups)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn add_user_to_group(&self, uid: i32, gid: i32) -> Result<()> {
        self.conn
            .execute("insert into usergroup(pid, gid) values(?1, ?2)", (uid, gid))?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn add_group_to_source(&self, gid: i32, sid: i32) -> Result<()> {
        self.conn.execute(
            "insert into groupsource(gid, sourceid) values(?1, ?2)",
            (gid, sid),
        )?;
        Ok(())
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn create_group(&self, name: &str, description: &str, parent: Option<i32>) -> Result<i32> {
        let result = if let Some(pid) = parent {
            self.conn.execute(
                "insert into grp(name, description, parent) values (?1, ?2, ?3);",
                params![&name, &description, &pid],
            )
        } else {
            self.conn.execute(
                "insert into grp(name, description) values (?1, ?2);",
                [&name, &description],
            )
        }?;

        if result != 1 {
            bail!("failed to create group {name}");
        }

        let mut statement = self.conn.prepare("select id from grp where name = ?1")?;
        let gid = statement
            .query_map([name], |row| {
                let gid: i32 = row.get(0)?;
                Ok(gid)
            })?
            .flatten()
            .next();
        gid.ok_or(anyhow!("unable to get group ID"))
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn list_sources(&self) -> Result<Vec<admin::Source>> {
        let mut sources = Vec::new();

        let mut statement = self
            .conn
            .prepare("select id, name, description, url, firstacquisition from source")?;

        for result in statement.query_map([], |row| {
            let date: Option<String> = row.get(4)?;
            let date = if let Some(date) = date {
                // ToDo: Figure out proper chrono error to rusqlite error
                let datetime = chrono::DateTime::parse_from_rfc3339(&date).unwrap();
                Some(datetime.with_timezone(&Local))
            } else {
                None
            };

            Ok(admin::Source {
                id: row.get(0)?,
                name: row.get(1)?,
                description: row.get(2)?,
                url: row.get(3)?,
                date,
            })
        })? {
            if let Ok(source) = result {
                sources.push(source);
            } else {
                bail!("Failed to fetch source data");
            }
        }

        Ok(sources)
    }

    #[cfg(any(test, feature = "admin"))]
    pub fn create_source(
        &self,
        name: &str,
        description: Option<&str>,
        url: Option<&str>,
        date: chrono::DateTime<Local>,
        releasable: bool,
    ) -> Result<i32> {
        let result = self.conn.execute(
            "insert into source(name, description, url, firstacquisition, releasable) values (?1, ?2, ?3, ?4, ?5);",
            params![&name, &description, url, date.to_rfc3339(), releasable],
        )?;

        if result != 1 {
            bail!("failed to create source {name}");
        }

        let mut statement = self.conn.prepare("select id from source where name = ?1")?;
        let gid = statement
            .query_map([name], |row| {
                let sid: i32 = row.get(0)?;
                Ok(sid)
            })?
            .flatten()
            .next();
        gid.ok_or(anyhow!("unable to get source ID"))
    }
}

unsafe impl Send for Sqlite {}
unsafe impl Sync for Sqlite {}

impl Display for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

impl Debug for Sqlite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SQLite client")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Context;
    use std::fs;

    const DB_FILE: &str = "testing_sqlite.db";

    #[test]
    fn everything() {
        if std::path::Path::new(DB_FILE).exists() {
            fs::remove_file(DB_FILE)
                .context(format!("failed to delete old SQLite file {DB_FILE}"))
                .unwrap();
        }

        let sqlite = Sqlite::new(DB_FILE)
            .context(format!("failed to create SQLite instance for {DB_FILE}"))
            .unwrap();

        let admin_password = "super_secure_password_dont_tell_anyone!";
        let admin_password_hashed = hash_password(admin_password)
            .context("failed to hash password")
            .unwrap();

        sqlite
            .conn
            .execute(
                "update person set password = ?1 where id = 0",
                &[(&admin_password_hashed)],
            )
            .context("failed to set admin password")
            .unwrap();

        let admin_api_key = sqlite
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();
        println!("API key: {admin_api_key}");

        assert_eq!(
            sqlite.get_uid(&admin_api_key).unwrap(),
            0,
            "Unable to get UID given the API key"
        );

        let admin_api_key_again = sqlite
            .authenticate("admin", &admin_password)
            .context("unable to get api key for admin")
            .unwrap();

        assert_eq!(
            admin_api_key, admin_api_key_again,
            "API keys didn't match the second time."
        );

        let bad_password = "this_is_totally_not_my_password!!";
        eprintln!("Testing API login with incorrect password.");
        let bad_api_key_request = sqlite.authenticate("admin", &bad_password);
        assert!(bad_api_key_request.is_err());

        let new_user_uname = "testuser";
        let new_user_email = "test@example.com";
        let new_user_password = "some_awesome_password_++";
        let new_id = sqlite
            .create_user(
                new_user_uname,
                new_user_uname,
                new_user_uname,
                new_user_email,
                Some(new_user_password.into()),
                None,
            )
            .unwrap();

        sqlite
            .create_user(
                "passwordless_user",
                "passwordless_user",
                "passwordless_user",
                "passwordless_user@example.com",
                None,
                None,
            )
            .unwrap();

        assert!(
            new_id > 0,
            "Weird UID created for user {}: {}",
            new_user_uname,
            new_id
        );

        assert!(
            sqlite
                .create_user(
                    new_user_uname,
                    new_user_uname,
                    new_user_uname,
                    new_user_email,
                    Some(new_user_password.into()),
                    None,
                )
                .is_err(),
            "Creating a new user with the same user name should fail"
        );

        let new_user_password_change = "some_new_awesomer_password!_++";
        sqlite
            .set_password(new_user_uname, new_user_password_change)
            .context("failed to change the password for testuser")
            .unwrap();

        let new_user_api_key = sqlite
            .authenticate(new_user_uname, &new_user_password)
            .context("unable to get api key for testuser")
            .unwrap();
        eprintln!("{new_user_uname} got API key {new_user_api_key}");

        assert_eq!(admin_api_key.len(), new_user_api_key.len());

        let users = sqlite.list_users().context("failed to list users").unwrap();
        eprintln!("DB has {} users:", users.len());
        let mut passwordless_user_found = false;
        for user in users {
            println!("{user}");
            if user.uname == "passwordless_user" {
                assert!(!user.has_api_key);
                assert!(!user.has_password);
                passwordless_user_found = true;
            } else {
                assert!(user.has_api_key);
                assert!(user.has_password);
            }
        }
        assert!(passwordless_user_found);

        let new_group_name = "some_new_group";
        let new_group_desc = "some_new_group_description";
        let new_group_id = 1;
        assert_eq!(
            sqlite
                .create_group(new_group_name, new_group_desc, None)
                .context("failed to create group")
                .unwrap(),
            new_group_id
        );

        assert!(
            sqlite
                .create_group(new_group_name, new_group_desc, None)
                .is_err(),
            "Duplicate group name should have failed"
        );

        sqlite
            .add_user_to_group(1, 1)
            .context("Unable to add uid 1 to gid 1")
            .unwrap();

        let new_admin_group_name = "admin_subgroup";
        let new_admin_group_desc = "admin_subgroup_description";
        let new_admin_group_id = 2;
        assert_eq!(
            sqlite
                .create_group(new_admin_group_name, new_admin_group_desc, Some(0))
                .context("failed to create admin sub-group")
                .unwrap(),
            new_admin_group_id
        );

        let groups = sqlite
            .list_groups(true)
            .context("failed to list groups")
            .unwrap();
        eprintln!("DB has {} groups:", groups.len());
        for group in groups {
            println!("{group}");
            if group.id == new_admin_group_id {
                assert_eq!(group.parent, Some("admin".to_string()));
            }
            if group.id == 1 {
                let test_user_str = String::from(new_user_uname);
                assert!(group.members.unwrap().contains(&test_user_str));
            }
        }

        let default_source_name = "default_source".to_string();
        sqlite
            .create_source(
                &default_source_name,
                Some("default_source"),
                None,
                chrono::Local::now(),
                true,
            )
            .context("failed to create group")
            .unwrap();

        sqlite
            .add_group_to_source(1, 1)
            .context("failed to add group 1 to source 1")
            .unwrap();

        let sources = sqlite
            .list_sources()
            .context("failed to list sources")
            .unwrap();
        eprintln!("DB has {} sources:", sources.len());
        for source in sources {
            println!("{source}");
        }

        let uid = sqlite
            .get_uid(&new_user_api_key)
            .context("failed to user uid from apikey")
            .unwrap();
        let user_info = sqlite
            .get_user_info(uid)
            .context("failed to get user's available groups and sources")
            .unwrap();
        assert!(user_info.sources.contains(&default_source_name));
        println!("UserInfoResponse: {user_info:?}");

        assert!(
            sqlite
                .allowed_user_source(1, 1)
                .context("failed to check that user 1 has access to source 1")
                .unwrap(),
            "User 1 should should have had access to source 1"
        );

        assert!(
            !sqlite
                .allowed_user_source(1, 5)
                .context("failed to check that user 1 has access to source 5")
                .unwrap(),
            "User 1 should should not have had access to source 5"
        );

        let test_elf = include_bytes!("../../../types/testdata/elf/elf_linux_ppc64le").to_vec();
        let test_elf_meta = FileMetadata::new(&test_elf);

        let known_type = KnownType::new(&test_elf)
            .context("failed to parse elf from test crate's test data")
            .unwrap();

        assert!(sqlite
            .add_file(&test_elf_meta, known_type, 1, 1, 1)
            .context("failed to insert a test elf")
            .unwrap());

        let reset = sqlite
            .reset_api_keys()
            .context("failed to reset all API keys")
            .unwrap();
        eprintln!("Cleared {reset} api keys.");

        let db_info = sqlite
            .db_info()
            .context("failed to get database info")
            .unwrap();
        eprintln!("DB Info: {db_info:?}");

        let data_types = sqlite
            .get_known_data_types()
            .context("failed to get data types")
            .unwrap();
        for data_type in data_types {
            println!("{data_type:?}");
        }

        fs::remove_file(DB_FILE)
            .context(format!("failed to delete SQLite file {DB_FILE}"))
            .unwrap();
    }
}
