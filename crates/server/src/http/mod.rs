use super::processing;
use super::State;
use crate::types::DataTypes;
use api::{
    EmptyAuthenticatingPost, GetAPIKeyRequest, GetAPIKeyResponse, GetUserInfoResponse, NewSample,
    ServerInfo, SupportedFileTypes,
};

use std::sync::Arc;

use axum::http::StatusCode;
use axum::routing::{get, post};
use axum::{extract, Extension, Json, Router};
use base64::{engine::general_purpose, Engine as _};
use sha2::{Digest, Sha256};
use tracing::debug;

pub fn app(state: State) -> Router {
    Router::new()
        .route("/", get(health))
        .route(api::SERVER_INFO, get(get_mdb_info))
        .route(api::USER_LOGIN_URL, post(user_login))
        .route(api::USER_INFO_URL, post(get_user_groups_sources))
        .route(api::SUPPORTED_FILE_TYPES, get(get_supported_types))
        .route(api::UPLOAD_SAMPLE, post(get_new_sample))
        .layer(Extension(Arc::new(state)))
}

async fn health() -> StatusCode {
    StatusCode::OK
}

async fn get_mdb_info(
    Extension(state): Extension<Arc<State>>,
) -> Result<Json<ServerInfo>, StatusCode> {
    let server_info = state
        .get_info()
        .await
        .map_err(|e| {
            debug!("API: ServerInfo Error: {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })
        .unwrap();
    Ok(Json(server_info))
}

async fn user_login(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<GetAPIKeyRequest>,
) -> Result<Json<GetAPIKeyResponse>, StatusCode> {
    let api_key = state
        .db_type
        .authenticate(&payload.user, &payload.password)
        .await
        .map_err(|e| {
            debug!("API: Authentication Error: {e}");
            StatusCode::UNAUTHORIZED
        })?;

    Ok(Json(GetAPIKeyResponse {
        key: Some(api_key),
        message: None,
    }))
}

async fn get_user_groups_sources(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<EmptyAuthenticatingPost>,
) -> Result<Json<GetUserInfoResponse>, StatusCode> {
    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: {e}");
        StatusCode::UNAUTHORIZED
    })?;

    let groups_sources = state.db_type.get_user_info(uid).await.map_err(|e| {
        debug!("API Error: {e}");
        StatusCode::UNAUTHORIZED
    })?;

    Ok(Json(groups_sources))
}

async fn get_supported_types(
    Extension(state): Extension<Arc<State>>,
) -> Result<Json<SupportedFileTypes>, StatusCode> {
    let data_types = state.db_type.get_known_data_types().await.map_err(|e| {
        debug!("API Error: get_supported_types {e}");
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let data_types = DataTypes(data_types);

    Ok(Json(data_types.into()))
}

async fn get_new_sample(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<NewSample>,
) -> Result<StatusCode, StatusCode> {
    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: could not get uid for {} {e}", payload.key);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let allowed = state
        .db_type
        .allowed_user_source(uid, payload.source_id as i32)
        .await
        .map_err(|e| {
            debug!(
                "API Error: could not check access for uid {uid} to sid {}: {e}",
                payload.source_id
            );
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    if !allowed {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let received_hash = hex::decode(&payload.sha256).map_err(|e| {
        debug!(
            "API Error: Failed to convert SHA-256 hash {} to bytes: {e}",
            payload.sha256
        );
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let bytes = general_purpose::STANDARD
        .decode(&payload.file_contents_b64)
        .map_err(|e| {
            debug!("API Error: could not decode base64 for {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let mut hasher = Sha256::new();
    hasher.update(&bytes);
    let result = hasher.finalize();

    if result[..] != received_hash[..] {
        return Err(StatusCode::NOT_ACCEPTABLE);
    }

    tokio::task::spawn(processing::receive::incoming_sample(
        bytes,
        uid,
        payload.source_id as i32,
        payload.file_name,
    ));

    Ok(StatusCode::OK)
}
