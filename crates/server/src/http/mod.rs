use super::processing;
use super::State;
use crate::db::types::FileTypes;
use api::{
    DownloadSampleRequest, EmptyAuthenticatingPost, GetAPIKeyRequest, GetAPIKeyResponse,
    GetUserInfoResponse, NewSample, ServerInfo, SupportedFileTypes,
};

use std::sync::Arc;

use axum::body::Bytes;
use axum::http::{header, StatusCode};
use axum::response::IntoResponse;
use axum::routing::{get, post};
use axum::{extract, Extension, Json, Router};
use base64::{engine::general_purpose, Engine as _};
use sha2::{Digest, Sha256};
use tracing::debug;

pub fn app(state: State) -> Router {
    Router::new()
        .route("/", get(health))
        .route(api::SERVER_INFO, get(get_mdb_info))
        .route(api::USER_LOGIN_URL, post(user_login))
        .route(api::USER_INFO_URL, post(get_user_groups_sources))
        .route(api::SUPPORTED_FILE_TYPES, get(get_supported_types))
        .route(api::UPLOAD_SAMPLE, post(get_new_sample))
        .route(api::DOWNLOAD_SAMPLE, post(download_sample))
        .route(api::SIMILAR_SAMPLES, post(find_similar))
        .layer(Extension(Arc::new(state)))
}

async fn health() -> StatusCode {
    StatusCode::OK
}

async fn get_mdb_info(
    Extension(state): Extension<Arc<State>>,
) -> Result<Json<ServerInfo>, StatusCode> {
    let server_info = state
        .get_info()
        .await
        .map_err(|e| {
            debug!("API: ServerInfo Error: {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })
        .unwrap();
    Ok(Json(server_info))
}

async fn user_login(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<GetAPIKeyRequest>,
) -> Result<Json<GetAPIKeyResponse>, StatusCode> {
    let api_key = state
        .db_type
        .authenticate(&payload.user, &payload.password)
        .await
        .map_err(|e| {
            debug!("API: Authentication Error: {e}");
            StatusCode::UNAUTHORIZED
        })?;

    Ok(Json(GetAPIKeyResponse {
        key: Some(api_key),
        message: None,
    }))
}

async fn get_user_groups_sources(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<EmptyAuthenticatingPost>,
) -> Result<Json<GetUserInfoResponse>, StatusCode> {
    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: {e}");
        StatusCode::UNAUTHORIZED
    })?;

    let groups_sources = state.db_type.get_user_info(uid).await.map_err(|e| {
        debug!("API Error: {e}");
        StatusCode::UNAUTHORIZED
    })?;

    Ok(Json(groups_sources))
}

async fn get_supported_types(
    Extension(state): Extension<Arc<State>>,
) -> Result<Json<SupportedFileTypes>, StatusCode> {
    let data_types = state.db_type.get_known_data_types().await.map_err(|e| {
        debug!("API Error: get_supported_types {e}");
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let file_types = FileTypes(data_types);

    Ok(Json(file_types.into()))
}

async fn get_new_sample(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<NewSample>,
) -> Result<StatusCode, StatusCode> {
    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: could not get uid for {} {e}", payload.key);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let allowed = state
        .db_type
        .allowed_user_source(uid, payload.source_id as i32)
        .await
        .map_err(|e| {
            debug!(
                "API Error: could not check access for uid {uid} to sid {}: {e}",
                payload.source_id
            );
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    if !allowed {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let received_hash = hex::decode(&payload.sha256).map_err(|e| {
        debug!(
            "API Error: Failed to convert SHA-256 hash {} to bytes: {e}",
            payload.sha256
        );
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let bytes = general_purpose::STANDARD
        .decode(&payload.file_contents_b64)
        .map_err(|e| {
            debug!("API Error: could not decode base64 for {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let mut hasher = Sha256::new();
    hasher.update(&bytes);
    let result = hasher.finalize();

    if result[..] != received_hash[..] {
        return Err(StatusCode::NOT_ACCEPTABLE);
    }

    tokio::task::spawn(processing::receive::incoming_sample(
        bytes,
        uid,
        payload.source_id as i32,
        payload.file_name,
    ));

    Ok(StatusCode::OK)
}

async fn download_sample(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<DownloadSampleRequest>,
) -> Result<impl IntoResponse, StatusCode> {
    if state.directory.is_none() {
        return Err(StatusCode::NOT_ACCEPTABLE);
    }

    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: could not get UID from API key for {e}");
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let sha256 = state
        .db_type
        .retrieve_sample(uid, payload.hash)
        .await
        .map_err(|e| {
            debug!("API Error: could not get SHA-256 from the `HashType` {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let contents = state.retrieve_bytes(&sha256).map_err(|e| {
        debug!("API Error: could not read the file from disk {e}");
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let mut bytes = Bytes::from(contents).into_response();
    let name_header_value = format!("attachment; filename=\"{sha256}\"");
    bytes.headers_mut().insert(
        header::CONTENT_DISPOSITION,
        name_header_value.parse().unwrap(),
    );

    Ok(bytes)
}

async fn find_similar(
    Extension(state): Extension<Arc<State>>,
    extract::Json(payload): extract::Json<api::SimilarSamplesRequest>,
) -> Result<Json<api::SimilarSamplesResponse>, StatusCode> {
    let uid = state.db_type.get_uid(&payload.key).await.map_err(|e| {
        debug!("API Error: could not get uid for {} {e}", payload.key);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let results = state
        .db_type
        .find_similar_samples(uid, &payload.hash)
        .await
        .map_err(|e| {
            debug!("API Error: could not find similar files {e}");
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    Ok(Json(api::SimilarSamplesResponse {
        results,
        message: None,
    }))
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::db::sqlite::Sqlite;
    use crate::db::DatabaseType;
    use crate::State;

    use std::fs;
    use std::time::SystemTime;

    use anyhow::Context;
    use axum::body::Body;
    use axum::http::Request;
    use http::header::CONTENT_TYPE;
    use tower::ServiceExt; // for `app.oneshot()`

    #[tokio::test]
    async fn login() {
        const DB_FILE: &str = "testing_sqlite_http.db";
        const ADMIN_UNAME: &str = "admin";
        const ADMIN_PASSWORD: &str = "password12345";
        if std::path::Path::new(DB_FILE).exists() {
            fs::remove_file(DB_FILE)
                .context(format!("failed to delete old SQLite file {DB_FILE}"))
                .unwrap();
        }

        let state = State {
            port: 8080,
            directory: None,
            ip: "127.0.0.1".parse().unwrap(),
            database_connection: Default::default(),
            db_type: DatabaseType::SQLite(
                Sqlite::new(DB_FILE)
                    .context(format!("failed to create SQLite instance for {DB_FILE}"))
                    .unwrap(),
            ),
            started: SystemTime::now(),
        };

        state
            .db_type
            .set_password(ADMIN_UNAME, ADMIN_PASSWORD)
            .await
            .context("Failed to set admin password")
            .unwrap();

        let key_request = serde_json::to_string(&GetAPIKeyRequest {
            user: ADMIN_UNAME.into(),
            password: ADMIN_PASSWORD.into(),
        })
        .context("Failed to convert API key request to JSON")
        .unwrap();

        let request = Request::builder()
            .method("POST")
            .uri(api::USER_LOGIN_URL)
            .header(CONTENT_TYPE, "application/json")
            .body(Body::from(key_request))
            .unwrap();

        let response = app(state)
            .oneshot(request)
            .await
            .context("failed to send/receive login request")
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
        let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
        let json_response = String::from_utf8(body.to_ascii_lowercase())
            .context("failed to convert response to string")
            .unwrap();

        let response: GetAPIKeyResponse = serde_json::from_str(&json_response)
            .context("failed to convert json response to object")
            .unwrap();

        assert_eq!(response.key.unwrap().len(), 36);
    }
}
