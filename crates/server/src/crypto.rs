use std::fmt::{Display, Formatter};
use std::io::{Cursor, Write};

use aes_gcm::aead::{Aead, Nonce, OsRng};
use aes_gcm::aes::Aes128;
use aes_gcm::{AeadCore, Aes128Gcm, AesGcm, Key, KeyInit};
use anyhow::{bail, ensure, Result};
use clap::ValueEnum;
use deadpool_postgres::tokio_postgres::types::{FromSql, ToSql};
use md5::digest::consts::U12;
use rc4::{Rc4, StreamCipher};
use xor_utils::Xor;
use zeroize::{Zeroize, ZeroizeOnDrop};

/// Available options for specifying which algorithm to use
#[derive(Debug, Copy, Clone, Eq, PartialEq, ValueEnum, Hash, ToSql, FromSql)]
#[postgres(name = "encryptionkey_algorithm", rename_all = "lowercase")]
pub enum EncryptionOption {
    AES128,
    RC4,
    Xor,
}

impl TryFrom<&str> for EncryptionOption {
    type Error = anyhow::Error;
    fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
        match value {
            "xor" => Ok(EncryptionOption::Xor),
            "rc4" => Ok(EncryptionOption::RC4),
            "aes128" => Ok(EncryptionOption::AES128),
            _ => Err(anyhow::Error::msg(format!(
                "Invalid encryption algorithm {value}"
            ))),
        }
    }
}

impl From<EncryptionOption> for FileEncryption {
    fn from(option: EncryptionOption) -> Self {
        let random_bytes = uuid::Uuid::new_v4().into_bytes().to_vec();

        match option {
            EncryptionOption::AES128 => FileEncryption::AES128(random_bytes),
            EncryptionOption::RC4 => {
                let random_bytes = random_bytes.as_slice()[0..16].to_vec();
                FileEncryption::RC4(random_bytes)
            }
            EncryptionOption::Xor => FileEncryption::Xor(random_bytes),
        }
    }
}

impl Display for EncryptionOption {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            EncryptionOption::Xor => write!(f, "Xor"),
            EncryptionOption::RC4 => write!(f, "RC4"),
            EncryptionOption::AES128 => write!(f, "AES-128"),
        }
    }
}

/// Some of these algorithms are not secure, and that's fine, since the goal isn't necessarily
/// data secrecy. The purpose is to store malware on disk without upsetting anti-virus systems.
/// It would be annoying if security software deleted our carefully curated data!
#[derive(Zeroize, ZeroizeOnDrop, Eq, PartialEq, Hash)]
pub enum FileEncryption {
    /// AES-128, to protect from prying eyes.
    AES128(Vec<u8>),

    /// RC4 with a 16-byte key, to protect from anti-virus
    RC4(Vec<u8>),

    /// Exclusive OR, to protect from anti-virus
    Xor(Vec<u8>),
}

impl FileEncryption {
    /// Create a key object given the encryption algorithm and key bytes
    pub fn new(option: EncryptionOption, bytes: Vec<u8>) -> Result<Self> {
        match option {
            EncryptionOption::AES128 => Ok(FileEncryption::AES128(bytes)),
            EncryptionOption::RC4 => {
                ensure!(bytes.len() == 16);
                Ok(FileEncryption::RC4(bytes))
            }
            EncryptionOption::Xor => Ok(FileEncryption::Xor(bytes)),
        }
    }

    /// Return the name of the algorithm used
    pub fn name(&self) -> &'static str {
        match self {
            FileEncryption::AES128(_) => "aes128",
            FileEncryption::RC4(_) => "rc4",
            FileEncryption::Xor(_) => "xor",
        }
    }

    /// Return the related `EncryptionOption` type
    pub fn key_type(&self) -> EncryptionOption {
        match self {
            FileEncryption::AES128(_) => EncryptionOption::AES128,
            FileEncryption::RC4(_) => EncryptionOption::RC4,
            FileEncryption::Xor(_) => EncryptionOption::Xor,
        }
    }

    /// Return the bytes for the key
    pub fn key(&self) -> &[u8] {
        match self {
            FileEncryption::AES128(key) => key.as_ref(),
            FileEncryption::RC4(key) => key.as_ref(),
            FileEncryption::Xor(key) => key.as_ref(),
        }
    }

    /// Decrypt some data returning the clear bytes
    pub fn decrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let decrypted = cipher.decrypt(nonce, data)?;
                    Ok(decrypted)
                } else {
                    bail!("Nonce required for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }

    /// Encrypt some data returning the ciphertext bytes
    pub fn encrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let encrypted = cipher.encrypt(nonce, data)?;
                    Ok(encrypted)
                } else {
                    bail!("Nonce required for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }

    /// Generate a nonce bytes, if used by the algorithm
    pub fn nonce(&self) -> Option<Vec<u8>> {
        match self {
            FileEncryption::AES128(_) => {
                let nonce = Aes128Gcm::generate_nonce(&mut OsRng);
                Some(nonce.to_vec())
            }
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::{EncryptionOption, FileEncryption};
    use malwaredb_types::utils::EntropyCalc;

    use std::time::Instant;

    use rstest::rstest;

    #[rstest]
    #[case(EncryptionOption::RC4)]
    #[case(EncryptionOption::Xor)]
    #[case(EncryptionOption::AES128)]
    #[test]
    fn enc_dec(#[case] option: EncryptionOption) {
        const BYTES: &[u8] = include_bytes!("../../types/testdata/exe/pe32_dotnet.exe");
        let original_entropy = BYTES.entropy();

        let encryptor = FileEncryption::from(option);

        let start = Instant::now();
        let nonce = encryptor.nonce();
        let encrypted = encryptor.encrypt(BYTES, nonce.clone()).unwrap();
        assert_ne!(BYTES, encrypted);

        let encrypted_entropy = encrypted.entropy();
        assert!(encrypted_entropy > original_entropy, "{option}: Encrypted entropy {encrypted_entropy} should be higher than the original entropy {original_entropy}");
        if option != EncryptionOption::Xor {
            assert!(
                encrypted_entropy > 7.0,
                "{option}: Entropy was {encrypted_entropy}, expected >7"
            );
        }

        let decrypted = encryptor.decrypt(&encrypted, nonce).unwrap();
        let duration = start.elapsed();
        println!("{option} Time elapsed: {:?}", duration);
        assert_eq!(BYTES, decrypted);
    }
}
