use std::io::{Cursor, Write};

use aes_gcm::aead::{Aead, Nonce, OsRng};
use aes_gcm::aes::Aes128;
use aes_gcm::{AeadCore, Aes128Gcm, AesGcm, Key, KeyInit};
use anyhow::{bail, ensure, Result};
use md5::digest::consts::U12;
use rc4::{Rc4, StreamCipher};
use xor_utils::Xor;
use zeroize::Zeroize;

/// Some of these algorithms are not secure, and that's fine, since the goal isn't true data secrecy.
/// The purpose is to store malware on disk without upsetting anti-virus systems.
#[derive(Zeroize)]
pub enum FileEncryption {
    /// AES-128
    AES128(Vec<u8>),

    /// RC4 with a 16-byte key
    RC4(Vec<u8>),

    /// Exclusive OR
    Xor(Vec<u8>),
}

impl FileEncryption {
    pub fn new(name: &str, bytes: Vec<u8>) -> Result<Self> {
        match name {
            "aes128" => Ok(FileEncryption::AES128(bytes)),
            "rc4" => {
                ensure!(bytes.len() == 16);
                Ok(FileEncryption::RC4(bytes))
            }
            "xor" => Ok(FileEncryption::Xor(bytes)),
            _ => bail!("Unknown algorithm {}", name),
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            FileEncryption::AES128(_) => "aes128",
            FileEncryption::RC4(_) => "rc4",
            FileEncryption::Xor(_) => "xor",
        }
    }

    pub fn key(&self) -> &[u8] {
        match self {
            FileEncryption::AES128(key) => key.as_ref(),
            FileEncryption::RC4(key) => key.as_ref(),
            FileEncryption::Xor(key) => key.as_ref(),
        }
    }

    pub fn random(name: &str) -> Result<Self> {
        let random_bytes = uuid::Uuid::new_v4().into_bytes().to_vec();

        match name {
            "aes128" => Ok(FileEncryption::AES128(random_bytes)),
            "rc4" => {
                let random_bytes = random_bytes.as_slice()[0..16].to_vec();
                Ok(FileEncryption::RC4(random_bytes))
            }
            "xor" => Ok(FileEncryption::Xor(random_bytes)),
            _ => bail!("Unknown algorithm {}", name),
        }
    }

    pub fn decrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let decrypted = cipher.decrypt(nonce, data)?;
                    Ok(decrypted)
                } else {
                    bail!("Nonce requires for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }

    pub fn encrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let encrypted = cipher.encrypt(nonce, data)?;
                    Ok(encrypted)
                } else {
                    bail!("Nonce requires for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }

    pub fn nonce(&self) -> Option<Vec<u8>> {
        match self {
            FileEncryption::AES128(_) => {
                let nonce = Aes128Gcm::generate_nonce(&mut OsRng);
                Some(nonce.to_vec())
            }
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::FileEncryption;
    use malwaredb_types::utils::EntropyCalc;

    use std::time::Instant;

    use rstest::rstest;

    #[rstest]
    #[case("rc4")]
    #[case("xor")]
    #[case("aes128")]
    #[test]
    fn enc_dec(#[case] name: &str) {
        const BYTES: &[u8] = include_bytes!("../../types/testdata/exe/pe32_dotnet.exe");
        let original_entropy = BYTES.entropy();

        let encryptor = FileEncryption::random(name).unwrap();

        let start = Instant::now();
        let nonce = encryptor.nonce();
        let encrypted = encryptor.encrypt(BYTES, nonce.clone()).unwrap();
        assert_ne!(BYTES, encrypted);

        let encrypted_entropy = encrypted.entropy();
        assert!(encrypted_entropy > original_entropy, "{name}: Encrypted entropy {encrypted_entropy} should be higher than the original entropy {original_entropy}");
        if name != "xor" {
            assert!(
                encrypted_entropy > 7.0,
                "{name}: Entropy was {encrypted_entropy}, expected >7"
            );
        }

        let decrypted = encryptor.decrypt(&encrypted, nonce).unwrap();
        let duration = start.elapsed();
        println!("{name} Time elapsed: {:?}", duration);
        assert_eq!(BYTES, decrypted);
    }
}
