use std::io::{Cursor, Write};

use aes_gcm::aead::{Aead, Nonce};
use aes_gcm::aes::Aes128;
use aes_gcm::{Aes128Gcm, AesGcm, Key, KeyInit};
use anyhow::{bail, ensure, Result};
use md5::digest::consts::U12;
use rc4::{Rc4, StreamCipher};
use xor_utils::Xor;
use zeroize::Zeroize;

/// Some of these algorithms are not secure, and that's fine, since the goal isn't true data secrecy.
/// The purpose is to store malware on disk without upsetting anti-virus systems.
#[derive(Zeroize)]
pub enum FileEncryption {
    /// AES-128
    AES128(Vec<u8>),

    /// RC4 with a 16-byte key
    RC4(Vec<u8>),

    /// Exclusive OR
    Xor(Vec<u8>),
}

impl FileEncryption {
    pub fn new(name: &str, bytes: Vec<u8>) -> Result<Self> {
        match name {
            "aes128" => Ok(FileEncryption::AES128(bytes)),
            "rc4" => {
                ensure!(bytes.len() == 16);
                Ok(FileEncryption::RC4(bytes))
            }
            "xor" => Ok(FileEncryption::Xor(bytes)),
            _ => bail!("Unknown algorithm {}", name),
        }
    }

    pub fn decrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let decrypted = cipher.decrypt(nonce, data)?;
                    Ok(decrypted)
                } else {
                    bail!("Nonce requires for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }

    pub fn encrypt(&self, data: &[u8], nonce: Option<Vec<u8>>) -> Result<Vec<u8>> {
        match self {
            FileEncryption::AES128(key) => {
                if let Some(nonce) = nonce {
                    let nonce = Nonce::<AesGcm<Aes128, U12>>::from_slice(&nonce);
                    let key = Key::<Aes128Gcm>::from_slice(key);
                    let cipher = Aes128Gcm::new(key);
                    let encrypted = cipher.encrypt(nonce, data)?;
                    Ok(encrypted)
                } else {
                    bail!("Nonce requires for AES");
                }
            }
            FileEncryption::RC4(key) => {
                let mut key: Rc4<rc4::consts::U16> = Rc4::new_from_slice(key)?;
                let mut output = vec![0u8; data.len()];
                key.apply_keystream_b2b(data, &mut output)?;
                Ok(output)
            }
            FileEncryption::Xor(key) => {
                let mut reader = Cursor::new(data.to_vec());
                let result = reader.by_ref().xor(key);
                Ok(result)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::FileEncryption;

    use std::time::Instant;

    use rstest::rstest;

    #[rstest]
    #[case("rc4", None)]
    #[case("xor", None)]
    #[case("aes128", Some(vec![0xd6, 0xbe, 0xda, 0x2d, 0x4c, 0xad, 0x8b, 0xd3, 0xee, 0xb6, 0xf7, 0x70]))]
    #[test]
    fn enc_dec(#[case] name: &str, #[case] nonce: Option<Vec<u8>>) {
        const KEY: [u8; 16] = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
            0x0E, 0x0F,
        ];
        const BYTES: &[u8] = include_bytes!("../../types/testdata/exe/pe32_dotnet.exe");

        let encryptor = FileEncryption::new(name, KEY.to_vec()).unwrap();

        let start = Instant::now();
        let encrypted = encryptor.encrypt(BYTES, nonce.clone()).unwrap();
        assert_ne!(BYTES, encrypted);

        let decrypted = encryptor.decrypt(&encrypted, nonce).unwrap();
        let duration = start.elapsed();
        println!("{name} Time elapsed: {:?}", duration);
        assert_eq!(BYTES, decrypted);
    }
}
